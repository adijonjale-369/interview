{"version":3,"sources":["../../../../node_modules/next/src/server/route-modules/pages/module.compiled.js","../../../../node_modules/next/src/server/route-kind.ts","../../../../node_modules/next/src/build/templates/helpers.ts","../../../../node_modules/next/dist/compiled/%40edge-runtime/cookies/index.js","../../../../node_modules/next/dist/compiled/fresh/index.js","../../../../node_modules/next/dist/esm/server/client-component-renderer-logger.js","../../../../node_modules/next/dist/esm/server/lib/trace/constants.js","../../../../node_modules/next/dist/esm/shared/lib/segment-cache/output-export-prefetch-encoding.js","../../../../node_modules/next/dist/esm/shared/lib/i18n/normalize-locale-path.js","../../../../node_modules/next/dist/esm/server/web/spec-extension/cookies.js","../../../../node_modules/next/dist/esm/server/route-modules/pages/pages-handler.js","../../../../node_modules/next/dist/esm/client/components/app-router-headers.js","../../../../node_modules/next/dist/esm/server/response-cache/types.js","../../../../node_modules/next/dist/esm/server/stream-utils/encoded-tags.js","../../../../node_modules/next/dist/esm/shared/lib/errors/constants.js","../../../../node_modules/next/dist/esm/shared/lib/router/utils/querystring.js","../../../../node_modules/next/dist/esm/shared/lib/i18n/detect-domain-locale.js","../../../../node_modules/next/dist/esm/server/instrumentation/utils.js","../../../../node_modules/next/dist/esm/server/web/error.js","../../../../node_modules/next/dist/esm/shared/lib/invariant-error.js","../../../../node_modules/next/dist/esm/client/components/redirect-status-code.js","../../../../node_modules/next/dist/esm/lib/constants.js","../../../../node_modules/next/dist/esm/shared/lib/router/utils/is-bot.js","../../../../node_modules/next/dist/esm/shared/lib/router/utils/cache-busting-search-param.js","../../../../node_modules/next/dist/esm/server/lib/cache-control.js","../../../../node_modules/next/dist/esm/server/request-meta.js","../../../../node_modules/next/dist/esm/lib/redirect-status.js","../../../../node_modules/next/dist/esm/server/lib/trace/tracer.js","../../../../node_modules/next/dist/esm/server/send-payload.js","../../../../node_modules/next/dist/esm/server/app-render/interop-default.js","../../../../node_modules/next/dist/esm/server/stream-utils/uint8array-helpers.js","../../../../node_modules/next/dist/esm/shared/lib/router/utils/get-next-pathname-info.js","../../../../node_modules/next/dist/esm/shared/lib/utils.js","../../../../node_modules/next/dist/esm/shared/lib/page-path/normalize-data-path.js","../../../../node_modules/next/dist/esm/server/render-result.js","../../../../node_modules/next/dist/esm/server/web/next-url.js","../../../../node_modules/next/dist/esm/shared/lib/router/utils/format-next-pathname-info.js","../../../../node_modules/next/dist/esm/server/web/spec-extension/request.js","../../../../node_modules/next/dist/esm/server/web/spec-extension/adapters/next-request.js","../../../../node_modules/next/dist/esm/server/response-cache/utils.js","../../../../node_modules/next/dist/esm/shared/lib/router/utils/html-bots.js","../../../../node_modules/next/dist/esm/shared/lib/router/utils/parse-path.js","../../../../node_modules/next/dist/esm/lib/batcher.js","../../../../node_modules/next/dist/esm/shared/lib/router/utils/add-path-prefix.js","../../../../node_modules/next/dist/esm/server/response-cache/index.js","../../../../node_modules/next/dist/esm/server/pipe-readable.js","../../../../node_modules/next/dist/esm/lib/detached-promise.js","../../../../node_modules/next/dist/esm/shared/lib/get-hostname.js","../../../../node_modules/next/dist/esm/shared/lib/router/utils/add-path-suffix.js","../../../../node_modules/next/dist/esm/lib/scheduler.js","../../../../node_modules/next/dist/esm/shared/lib/is-thenable.js","../../../../node_modules/next/dist/esm/shared/lib/router/utils/remove-trailing-slash.js","../../../../node_modules/next/dist/esm/shared/lib/router/utils/add-locale.js","../../../../node_modules/next/dist/esm/shared/lib/hash.js","../../../../node_modules/next/dist/esm/shared/lib/router/utils/path-has-prefix.js","../../../../node_modules/next/dist/esm/server/lib/etag.js","../../../../node_modules/next/dist/esm/shared/lib/router/utils/remove-path-prefix.js","../../../../node_modules/next/dist/esm/server/web/utils.js","../../../../node_modules/next/dist/esm/server/stream-utils/node-web-streams-helper.js","../../../../node_modules/next/dist/esm/server/base-http/helpers.js","../../../../node_modules/next/dist/esm/shared/lib/router/utils/format-url.js"],"sourcesContent":["if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/pages/module.js')\n} else {\n  if (process.env.NODE_ENV === 'development') {\n    if (process.env.TURBOPACK) {\n      module.exports = require('next/dist/compiled/next-server/pages-turbo.runtime.dev.js')\n    } else {\n      module.exports = require('next/dist/compiled/next-server/pages.runtime.dev.js')\n    }\n  } else {\n    if (process.env.TURBOPACK) {\n      module.exports = require('next/dist/compiled/next-server/pages-turbo.runtime.prod.js')\n    } else {\n      module.exports = require('next/dist/compiled/next-server/pages.runtime.prod.js')\n    }\n  }\n}\n","export const enum RouteKind {\n  /**\n   * `PAGES` represents all the React pages that are under `pages/`.\n   */\n  PAGES = 'PAGES',\n  /**\n   * `PAGES_API` represents all the API routes under `pages/api/`.\n   */\n  PAGES_API = 'PAGES_API',\n  /**\n   * `APP_PAGE` represents all the React pages that are under `app/` with the\n   * filename of `page.{j,t}s{,x}`.\n   */\n  APP_PAGE = 'APP_PAGE',\n  /**\n   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the\n   * filename of `route.{j,t}s{,x}`.\n   */\n  APP_ROUTE = 'APP_ROUTE',\n\n  /**\n   * `IMAGE` represents all the images that are generated by `next/image`.\n   */\n  IMAGE = 'IMAGE',\n}\n","/**\n * Hoists a name from a module or promised module.\n *\n * @param module the module to hoist the name from\n * @param name the name to hoist\n * @returns the value on the module (or promised module)\n */\nexport function hoist(module: any, name: string) {\n  // If the name is available in the module, return it.\n  if (name in module) {\n    return module[name]\n  }\n\n  // If a property called `then` exists, assume it's a promise and\n  // return a promise that resolves to the name.\n  if ('then' in module && typeof module.then === 'function') {\n    return module.then((mod: any) => hoist(mod, name))\n  }\n\n  // If we're trying to hoise the default export, and the module is a function,\n  // return the module itself.\n  if (typeof module === 'function' && name === 'default') {\n    return module\n  }\n\n  // Otherwise, return undefined.\n  return undefined\n}\n","\"use strict\";\r\nvar __defProp = Object.defineProperty;\r\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\r\nvar __getOwnPropNames = Object.getOwnPropertyNames;\r\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\r\nvar __export = (target, all) => {\r\n  for (var name in all)\r\n    __defProp(target, name, { get: all[name], enumerable: true });\r\n};\r\nvar __copyProps = (to, from, except, desc) => {\r\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\r\n    for (let key of __getOwnPropNames(from))\r\n      if (!__hasOwnProp.call(to, key) && key !== except)\r\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\r\n  }\r\n  return to;\r\n};\r\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\r\n\r\n// src/index.ts\r\nvar src_exports = {};\r\n__export(src_exports, {\r\n  RequestCookies: () => RequestCookies,\r\n  ResponseCookies: () => ResponseCookies,\r\n  parseCookie: () => parseCookie,\r\n  parseSetCookie: () => parseSetCookie,\r\n  stringifyCookie: () => stringifyCookie\r\n});\r\nmodule.exports = __toCommonJS(src_exports);\r\n\r\n// src/serialize.ts\r\nfunction stringifyCookie(c) {\r\n  var _a;\r\n  const attrs = [\r\n    \"path\" in c && c.path && `Path=${c.path}`,\r\n    \"expires\" in c && (c.expires || c.expires === 0) && `Expires=${(typeof c.expires === \"number\" ? new Date(c.expires) : c.expires).toUTCString()}`,\r\n    \"maxAge\" in c && typeof c.maxAge === \"number\" && `Max-Age=${c.maxAge}`,\r\n    \"domain\" in c && c.domain && `Domain=${c.domain}`,\r\n    \"secure\" in c && c.secure && \"Secure\",\r\n    \"httpOnly\" in c && c.httpOnly && \"HttpOnly\",\r\n    \"sameSite\" in c && c.sameSite && `SameSite=${c.sameSite}`,\r\n    \"partitioned\" in c && c.partitioned && \"Partitioned\",\r\n    \"priority\" in c && c.priority && `Priority=${c.priority}`\r\n  ].filter(Boolean);\r\n  const stringified = `${c.name}=${encodeURIComponent((_a = c.value) != null ? _a : \"\")}`;\r\n  return attrs.length === 0 ? stringified : `${stringified}; ${attrs.join(\"; \")}`;\r\n}\r\nfunction parseCookie(cookie) {\r\n  const map = /* @__PURE__ */ new Map();\r\n  for (const pair of cookie.split(/; */)) {\r\n    if (!pair)\r\n      continue;\r\n    const splitAt = pair.indexOf(\"=\");\r\n    if (splitAt === -1) {\r\n      map.set(pair, \"true\");\r\n      continue;\r\n    }\r\n    const [key, value] = [pair.slice(0, splitAt), pair.slice(splitAt + 1)];\r\n    try {\r\n      map.set(key, decodeURIComponent(value != null ? value : \"true\"));\r\n    } catch {\r\n    }\r\n  }\r\n  return map;\r\n}\r\nfunction parseSetCookie(setCookie) {\r\n  if (!setCookie) {\r\n    return void 0;\r\n  }\r\n  const [[name, value], ...attributes] = parseCookie(setCookie);\r\n  const {\r\n    domain,\r\n    expires,\r\n    httponly,\r\n    maxage,\r\n    path,\r\n    samesite,\r\n    secure,\r\n    partitioned,\r\n    priority\r\n  } = Object.fromEntries(\r\n    attributes.map(([key, value2]) => [\r\n      key.toLowerCase().replace(/-/g, \"\"),\r\n      value2\r\n    ])\r\n  );\r\n  const cookie = {\r\n    name,\r\n    value: decodeURIComponent(value),\r\n    domain,\r\n    ...expires && { expires: new Date(expires) },\r\n    ...httponly && { httpOnly: true },\r\n    ...typeof maxage === \"string\" && { maxAge: Number(maxage) },\r\n    path,\r\n    ...samesite && { sameSite: parseSameSite(samesite) },\r\n    ...secure && { secure: true },\r\n    ...priority && { priority: parsePriority(priority) },\r\n    ...partitioned && { partitioned: true }\r\n  };\r\n  return compact(cookie);\r\n}\r\nfunction compact(t) {\r\n  const newT = {};\r\n  for (const key in t) {\r\n    if (t[key]) {\r\n      newT[key] = t[key];\r\n    }\r\n  }\r\n  return newT;\r\n}\r\nvar SAME_SITE = [\"strict\", \"lax\", \"none\"];\r\nfunction parseSameSite(string) {\r\n  string = string.toLowerCase();\r\n  return SAME_SITE.includes(string) ? string : void 0;\r\n}\r\nvar PRIORITY = [\"low\", \"medium\", \"high\"];\r\nfunction parsePriority(string) {\r\n  string = string.toLowerCase();\r\n  return PRIORITY.includes(string) ? string : void 0;\r\n}\r\nfunction splitCookiesString(cookiesString) {\r\n  if (!cookiesString)\r\n    return [];\r\n  var cookiesStrings = [];\r\n  var pos = 0;\r\n  var start;\r\n  var ch;\r\n  var lastComma;\r\n  var nextStart;\r\n  var cookiesSeparatorFound;\r\n  function skipWhitespace() {\r\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\r\n      pos += 1;\r\n    }\r\n    return pos < cookiesString.length;\r\n  }\r\n  function notSpecialChar() {\r\n    ch = cookiesString.charAt(pos);\r\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\r\n  }\r\n  while (pos < cookiesString.length) {\r\n    start = pos;\r\n    cookiesSeparatorFound = false;\r\n    while (skipWhitespace()) {\r\n      ch = cookiesString.charAt(pos);\r\n      if (ch === \",\") {\r\n        lastComma = pos;\r\n        pos += 1;\r\n        skipWhitespace();\r\n        nextStart = pos;\r\n        while (pos < cookiesString.length && notSpecialChar()) {\r\n          pos += 1;\r\n        }\r\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\r\n          cookiesSeparatorFound = true;\r\n          pos = nextStart;\r\n          cookiesStrings.push(cookiesString.substring(start, lastComma));\r\n          start = pos;\r\n        } else {\r\n          pos = lastComma + 1;\r\n        }\r\n      } else {\r\n        pos += 1;\r\n      }\r\n    }\r\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\r\n      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\r\n    }\r\n  }\r\n  return cookiesStrings;\r\n}\r\n\r\n// src/request-cookies.ts\r\nvar RequestCookies = class {\r\n  constructor(requestHeaders) {\r\n    /** @internal */\r\n    this._parsed = /* @__PURE__ */ new Map();\r\n    this._headers = requestHeaders;\r\n    const header = requestHeaders.get(\"cookie\");\r\n    if (header) {\r\n      const parsed = parseCookie(header);\r\n      for (const [name, value] of parsed) {\r\n        this._parsed.set(name, { name, value });\r\n      }\r\n    }\r\n  }\r\n  [Symbol.iterator]() {\r\n    return this._parsed[Symbol.iterator]();\r\n  }\r\n  /**\r\n   * The amount of cookies received from the client\r\n   */\r\n  get size() {\r\n    return this._parsed.size;\r\n  }\r\n  get(...args) {\r\n    const name = typeof args[0] === \"string\" ? args[0] : args[0].name;\r\n    return this._parsed.get(name);\r\n  }\r\n  getAll(...args) {\r\n    var _a;\r\n    const all = Array.from(this._parsed);\r\n    if (!args.length) {\r\n      return all.map(([_, value]) => value);\r\n    }\r\n    const name = typeof args[0] === \"string\" ? args[0] : (_a = args[0]) == null ? void 0 : _a.name;\r\n    return all.filter(([n]) => n === name).map(([_, value]) => value);\r\n  }\r\n  has(name) {\r\n    return this._parsed.has(name);\r\n  }\r\n  set(...args) {\r\n    const [name, value] = args.length === 1 ? [args[0].name, args[0].value] : args;\r\n    const map = this._parsed;\r\n    map.set(name, { name, value });\r\n    this._headers.set(\r\n      \"cookie\",\r\n      Array.from(map).map(([_, value2]) => stringifyCookie(value2)).join(\"; \")\r\n    );\r\n    return this;\r\n  }\r\n  /**\r\n   * Delete the cookies matching the passed name or names in the request.\r\n   */\r\n  delete(names) {\r\n    const map = this._parsed;\r\n    const result = !Array.isArray(names) ? map.delete(names) : names.map((name) => map.delete(name));\r\n    this._headers.set(\r\n      \"cookie\",\r\n      Array.from(map).map(([_, value]) => stringifyCookie(value)).join(\"; \")\r\n    );\r\n    return result;\r\n  }\r\n  /**\r\n   * Delete all the cookies in the cookies in the request.\r\n   */\r\n  clear() {\r\n    this.delete(Array.from(this._parsed.keys()));\r\n    return this;\r\n  }\r\n  /**\r\n   * Format the cookies in the request as a string for logging\r\n   */\r\n  [Symbol.for(\"edge-runtime.inspect.custom\")]() {\r\n    return `RequestCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;\r\n  }\r\n  toString() {\r\n    return [...this._parsed.values()].map((v) => `${v.name}=${encodeURIComponent(v.value)}`).join(\"; \");\r\n  }\r\n};\r\n\r\n// src/response-cookies.ts\r\nvar ResponseCookies = class {\r\n  constructor(responseHeaders) {\r\n    /** @internal */\r\n    this._parsed = /* @__PURE__ */ new Map();\r\n    var _a, _b, _c;\r\n    this._headers = responseHeaders;\r\n    const setCookie = (_c = (_b = (_a = responseHeaders.getSetCookie) == null ? void 0 : _a.call(responseHeaders)) != null ? _b : responseHeaders.get(\"set-cookie\")) != null ? _c : [];\r\n    const cookieStrings = Array.isArray(setCookie) ? setCookie : splitCookiesString(setCookie);\r\n    for (const cookieString of cookieStrings) {\r\n      const parsed = parseSetCookie(cookieString);\r\n      if (parsed)\r\n        this._parsed.set(parsed.name, parsed);\r\n    }\r\n  }\r\n  /**\r\n   * {@link https://wicg.github.io/cookie-store/#CookieStore-get CookieStore#get} without the Promise.\r\n   */\r\n  get(...args) {\r\n    const key = typeof args[0] === \"string\" ? args[0] : args[0].name;\r\n    return this._parsed.get(key);\r\n  }\r\n  /**\r\n   * {@link https://wicg.github.io/cookie-store/#CookieStore-getAll CookieStore#getAll} without the Promise.\r\n   */\r\n  getAll(...args) {\r\n    var _a;\r\n    const all = Array.from(this._parsed.values());\r\n    if (!args.length) {\r\n      return all;\r\n    }\r\n    const key = typeof args[0] === \"string\" ? args[0] : (_a = args[0]) == null ? void 0 : _a.name;\r\n    return all.filter((c) => c.name === key);\r\n  }\r\n  has(name) {\r\n    return this._parsed.has(name);\r\n  }\r\n  /**\r\n   * {@link https://wicg.github.io/cookie-store/#CookieStore-set CookieStore#set} without the Promise.\r\n   */\r\n  set(...args) {\r\n    const [name, value, cookie] = args.length === 1 ? [args[0].name, args[0].value, args[0]] : args;\r\n    const map = this._parsed;\r\n    map.set(name, normalizeCookie({ name, value, ...cookie }));\r\n    replace(map, this._headers);\r\n    return this;\r\n  }\r\n  /**\r\n   * {@link https://wicg.github.io/cookie-store/#CookieStore-delete CookieStore#delete} without the Promise.\r\n   */\r\n  delete(...args) {\r\n    const [name, options] = typeof args[0] === \"string\" ? [args[0]] : [args[0].name, args[0]];\r\n    return this.set({ ...options, name, value: \"\", expires: /* @__PURE__ */ new Date(0) });\r\n  }\r\n  [Symbol.for(\"edge-runtime.inspect.custom\")]() {\r\n    return `ResponseCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;\r\n  }\r\n  toString() {\r\n    return [...this._parsed.values()].map(stringifyCookie).join(\"; \");\r\n  }\r\n};\r\nfunction replace(bag, headers) {\r\n  headers.delete(\"set-cookie\");\r\n  for (const [, value] of bag) {\r\n    const serialized = stringifyCookie(value);\r\n    headers.append(\"set-cookie\", serialized);\r\n  }\r\n}\r\nfunction normalizeCookie(cookie = { name: \"\", value: \"\" }) {\r\n  if (typeof cookie.expires === \"number\") {\r\n    cookie.expires = new Date(cookie.expires);\r\n  }\r\n  if (cookie.maxAge) {\r\n    cookie.expires = new Date(Date.now() + cookie.maxAge * 1e3);\r\n  }\r\n  if (cookie.path === null || cookie.path === void 0) {\r\n    cookie.path = \"/\";\r\n  }\r\n  return cookie;\r\n}\r\n// Annotate the CommonJS export names for ESM import in node:\r\n0 && (module.exports = {\r\n  RequestCookies,\r\n  ResponseCookies,\r\n  parseCookie,\r\n  parseSetCookie,\r\n  stringifyCookie\r\n});\r\n","(()=>{\"use strict\";var e={695:e=>{\r\n/*!\r\n * fresh\r\n * Copyright(c) 2012 TJ Holowaychuk\r\n * Copyright(c) 2016-2017 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\r\nvar r=/(?:^|,)\\s*?no-cache\\s*?(?:,|$)/;e.exports=fresh;function fresh(e,a){var t=e[\"if-modified-since\"];var s=e[\"if-none-match\"];if(!t&&!s){return false}var i=e[\"cache-control\"];if(i&&r.test(i)){return false}if(s&&s!==\"*\"){var f=a[\"etag\"];if(!f){return false}var n=true;var u=parseTokenList(s);for(var _=0;_<u.length;_++){var o=u[_];if(o===f||o===\"W/\"+f||\"W/\"+o===f){n=false;break}}if(n){return false}}if(t){var p=a[\"last-modified\"];var v=!p||!(parseHttpDate(p)<=parseHttpDate(t));if(v){return false}}return true}function parseHttpDate(e){var r=e&&Date.parse(e);return typeof r===\"number\"?r:NaN}function parseTokenList(e){var r=0;var a=[];var t=0;for(var s=0,i=e.length;s<i;s++){switch(e.charCodeAt(s)){case 32:if(t===r){t=r=s+1}break;case 44:a.push(e.substring(t,r));t=r=s+1;break;default:r=s+1;break}}a.push(e.substring(t,r));return a}}};var r={};function __nccwpck_require__(a){var t=r[a];if(t!==undefined){return t.exports}var s=r[a]={exports:{}};var i=true;try{e[a](s,s.exports,__nccwpck_require__);i=false}finally{if(i)delete r[a]}return s.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var a=__nccwpck_require__(695);module.exports=a})();","// Combined load times for loading client components\r\nlet clientComponentLoadStart = 0;\r\nlet clientComponentLoadTimes = 0;\r\nlet clientComponentLoadCount = 0;\r\nexport function wrapClientComponentLoader(ComponentMod) {\r\n    if (!('performance' in globalThis)) {\r\n        return ComponentMod.__next_app__;\r\n    }\r\n    return {\r\n        require: (...args)=>{\r\n            const startTime = performance.now();\r\n            if (clientComponentLoadStart === 0) {\r\n                clientComponentLoadStart = startTime;\r\n            }\r\n            try {\r\n                clientComponentLoadCount += 1;\r\n                return ComponentMod.__next_app__.require(...args);\r\n            } finally{\r\n                clientComponentLoadTimes += performance.now() - startTime;\r\n            }\r\n        },\r\n        loadChunk: (...args)=>{\r\n            const startTime = performance.now();\r\n            const result = ComponentMod.__next_app__.loadChunk(...args);\r\n            // Avoid wrapping `loadChunk`'s result in an extra promise in case something like React depends on its identity.\r\n            // We only need to know when it's settled.\r\n            result.finally(()=>{\r\n                clientComponentLoadTimes += performance.now() - startTime;\r\n            });\r\n            return result;\r\n        }\r\n    };\r\n}\r\nexport function getClientComponentLoaderMetrics(options = {}) {\r\n    const metrics = clientComponentLoadStart === 0 ? undefined : {\r\n        clientComponentLoadStart,\r\n        clientComponentLoadTimes,\r\n        clientComponentLoadCount\r\n    };\r\n    if (options.reset) {\r\n        clientComponentLoadStart = 0;\r\n        clientComponentLoadTimes = 0;\r\n        clientComponentLoadCount = 0;\r\n    }\r\n    return metrics;\r\n}\r\n\r\n//# sourceMappingURL=client-component-renderer-logger.js.map","/**\r\n * Contains predefined constants for the trace span name in next/server.\r\n *\r\n * Currently, next/server/tracer is internal implementation only for tracking\r\n * next.js's implementation only with known span names defined here.\r\n **/ // eslint typescript has a bug with TS enums\r\nvar BaseServerSpan = /*#__PURE__*/ function(BaseServerSpan) {\r\n    BaseServerSpan[\"handleRequest\"] = \"BaseServer.handleRequest\";\r\n    BaseServerSpan[\"run\"] = \"BaseServer.run\";\r\n    BaseServerSpan[\"pipe\"] = \"BaseServer.pipe\";\r\n    BaseServerSpan[\"getStaticHTML\"] = \"BaseServer.getStaticHTML\";\r\n    BaseServerSpan[\"render\"] = \"BaseServer.render\";\r\n    BaseServerSpan[\"renderToResponseWithComponents\"] = \"BaseServer.renderToResponseWithComponents\";\r\n    BaseServerSpan[\"renderToResponse\"] = \"BaseServer.renderToResponse\";\r\n    BaseServerSpan[\"renderToHTML\"] = \"BaseServer.renderToHTML\";\r\n    BaseServerSpan[\"renderError\"] = \"BaseServer.renderError\";\r\n    BaseServerSpan[\"renderErrorToResponse\"] = \"BaseServer.renderErrorToResponse\";\r\n    BaseServerSpan[\"renderErrorToHTML\"] = \"BaseServer.renderErrorToHTML\";\r\n    BaseServerSpan[\"render404\"] = \"BaseServer.render404\";\r\n    return BaseServerSpan;\r\n}(BaseServerSpan || {});\r\nvar LoadComponentsSpan = /*#__PURE__*/ function(LoadComponentsSpan) {\r\n    LoadComponentsSpan[\"loadDefaultErrorComponents\"] = \"LoadComponents.loadDefaultErrorComponents\";\r\n    LoadComponentsSpan[\"loadComponents\"] = \"LoadComponents.loadComponents\";\r\n    return LoadComponentsSpan;\r\n}(LoadComponentsSpan || {});\r\nvar NextServerSpan = /*#__PURE__*/ function(NextServerSpan) {\r\n    NextServerSpan[\"getRequestHandler\"] = \"NextServer.getRequestHandler\";\r\n    NextServerSpan[\"getRequestHandlerWithMetadata\"] = \"NextServer.getRequestHandlerWithMetadata\";\r\n    NextServerSpan[\"getServer\"] = \"NextServer.getServer\";\r\n    NextServerSpan[\"getServerRequestHandler\"] = \"NextServer.getServerRequestHandler\";\r\n    NextServerSpan[\"createServer\"] = \"createServer.createServer\";\r\n    return NextServerSpan;\r\n}(NextServerSpan || {});\r\nvar NextNodeServerSpan = /*#__PURE__*/ function(NextNodeServerSpan) {\r\n    NextNodeServerSpan[\"compression\"] = \"NextNodeServer.compression\";\r\n    NextNodeServerSpan[\"getBuildId\"] = \"NextNodeServer.getBuildId\";\r\n    NextNodeServerSpan[\"createComponentTree\"] = \"NextNodeServer.createComponentTree\";\r\n    NextNodeServerSpan[\"clientComponentLoading\"] = \"NextNodeServer.clientComponentLoading\";\r\n    NextNodeServerSpan[\"getLayoutOrPageModule\"] = \"NextNodeServer.getLayoutOrPageModule\";\r\n    NextNodeServerSpan[\"generateStaticRoutes\"] = \"NextNodeServer.generateStaticRoutes\";\r\n    NextNodeServerSpan[\"generateFsStaticRoutes\"] = \"NextNodeServer.generateFsStaticRoutes\";\r\n    NextNodeServerSpan[\"generatePublicRoutes\"] = \"NextNodeServer.generatePublicRoutes\";\r\n    NextNodeServerSpan[\"generateImageRoutes\"] = \"NextNodeServer.generateImageRoutes.route\";\r\n    NextNodeServerSpan[\"sendRenderResult\"] = \"NextNodeServer.sendRenderResult\";\r\n    NextNodeServerSpan[\"proxyRequest\"] = \"NextNodeServer.proxyRequest\";\r\n    NextNodeServerSpan[\"runApi\"] = \"NextNodeServer.runApi\";\r\n    NextNodeServerSpan[\"render\"] = \"NextNodeServer.render\";\r\n    NextNodeServerSpan[\"renderHTML\"] = \"NextNodeServer.renderHTML\";\r\n    NextNodeServerSpan[\"imageOptimizer\"] = \"NextNodeServer.imageOptimizer\";\r\n    NextNodeServerSpan[\"getPagePath\"] = \"NextNodeServer.getPagePath\";\r\n    NextNodeServerSpan[\"getRoutesManifest\"] = \"NextNodeServer.getRoutesManifest\";\r\n    NextNodeServerSpan[\"findPageComponents\"] = \"NextNodeServer.findPageComponents\";\r\n    NextNodeServerSpan[\"getFontManifest\"] = \"NextNodeServer.getFontManifest\";\r\n    NextNodeServerSpan[\"getServerComponentManifest\"] = \"NextNodeServer.getServerComponentManifest\";\r\n    NextNodeServerSpan[\"getRequestHandler\"] = \"NextNodeServer.getRequestHandler\";\r\n    NextNodeServerSpan[\"renderToHTML\"] = \"NextNodeServer.renderToHTML\";\r\n    NextNodeServerSpan[\"renderError\"] = \"NextNodeServer.renderError\";\r\n    NextNodeServerSpan[\"renderErrorToHTML\"] = \"NextNodeServer.renderErrorToHTML\";\r\n    NextNodeServerSpan[\"render404\"] = \"NextNodeServer.render404\";\r\n    NextNodeServerSpan[\"startResponse\"] = \"NextNodeServer.startResponse\";\r\n    // nested inner span, does not require parent scope name\r\n    NextNodeServerSpan[\"route\"] = \"route\";\r\n    NextNodeServerSpan[\"onProxyReq\"] = \"onProxyReq\";\r\n    NextNodeServerSpan[\"apiResolver\"] = \"apiResolver\";\r\n    NextNodeServerSpan[\"internalFetch\"] = \"internalFetch\";\r\n    return NextNodeServerSpan;\r\n}(NextNodeServerSpan || {});\r\nvar StartServerSpan = /*#__PURE__*/ function(StartServerSpan) {\r\n    StartServerSpan[\"startServer\"] = \"startServer.startServer\";\r\n    return StartServerSpan;\r\n}(StartServerSpan || {});\r\nvar RenderSpan = /*#__PURE__*/ function(RenderSpan) {\r\n    RenderSpan[\"getServerSideProps\"] = \"Render.getServerSideProps\";\r\n    RenderSpan[\"getStaticProps\"] = \"Render.getStaticProps\";\r\n    RenderSpan[\"renderToString\"] = \"Render.renderToString\";\r\n    RenderSpan[\"renderDocument\"] = \"Render.renderDocument\";\r\n    RenderSpan[\"createBodyResult\"] = \"Render.createBodyResult\";\r\n    return RenderSpan;\r\n}(RenderSpan || {});\r\nvar AppRenderSpan = /*#__PURE__*/ function(AppRenderSpan) {\r\n    AppRenderSpan[\"renderToString\"] = \"AppRender.renderToString\";\r\n    AppRenderSpan[\"renderToReadableStream\"] = \"AppRender.renderToReadableStream\";\r\n    AppRenderSpan[\"getBodyResult\"] = \"AppRender.getBodyResult\";\r\n    AppRenderSpan[\"fetch\"] = \"AppRender.fetch\";\r\n    return AppRenderSpan;\r\n}(AppRenderSpan || {});\r\nvar RouterSpan = /*#__PURE__*/ function(RouterSpan) {\r\n    RouterSpan[\"executeRoute\"] = \"Router.executeRoute\";\r\n    return RouterSpan;\r\n}(RouterSpan || {});\r\nvar NodeSpan = /*#__PURE__*/ function(NodeSpan) {\r\n    NodeSpan[\"runHandler\"] = \"Node.runHandler\";\r\n    return NodeSpan;\r\n}(NodeSpan || {});\r\nvar AppRouteRouteHandlersSpan = /*#__PURE__*/ function(AppRouteRouteHandlersSpan) {\r\n    AppRouteRouteHandlersSpan[\"runHandler\"] = \"AppRouteRouteHandlers.runHandler\";\r\n    return AppRouteRouteHandlersSpan;\r\n}(AppRouteRouteHandlersSpan || {});\r\nvar ResolveMetadataSpan = /*#__PURE__*/ function(ResolveMetadataSpan) {\r\n    ResolveMetadataSpan[\"generateMetadata\"] = \"ResolveMetadata.generateMetadata\";\r\n    ResolveMetadataSpan[\"generateViewport\"] = \"ResolveMetadata.generateViewport\";\r\n    return ResolveMetadataSpan;\r\n}(ResolveMetadataSpan || {});\r\nvar MiddlewareSpan = /*#__PURE__*/ function(MiddlewareSpan) {\r\n    MiddlewareSpan[\"execute\"] = \"Middleware.execute\";\r\n    return MiddlewareSpan;\r\n}(MiddlewareSpan || {});\r\n// This list is used to filter out spans that are not relevant to the user\r\nexport const NextVanillaSpanAllowlist = new Set([\r\n    \"Middleware.execute\",\r\n    \"BaseServer.handleRequest\",\r\n    \"Render.getServerSideProps\",\r\n    \"Render.getStaticProps\",\r\n    \"AppRender.fetch\",\r\n    \"AppRender.getBodyResult\",\r\n    \"Render.renderDocument\",\r\n    \"Node.runHandler\",\r\n    \"AppRouteRouteHandlers.runHandler\",\r\n    \"ResolveMetadata.generateMetadata\",\r\n    \"ResolveMetadata.generateViewport\",\r\n    \"NextNodeServer.createComponentTree\",\r\n    \"NextNodeServer.findPageComponents\",\r\n    \"NextNodeServer.getLayoutOrPageModule\",\r\n    \"NextNodeServer.startResponse\",\r\n    \"NextNodeServer.clientComponentLoading\"\r\n]);\r\n// These Spans are allowed to be always logged\r\n// when the otel log prefix env is set\r\nexport const LogSpanAllowList = new Set([\r\n    \"NextNodeServer.findPageComponents\",\r\n    \"NextNodeServer.createComponentTree\",\r\n    \"NextNodeServer.clientComponentLoading\"\r\n]);\r\nexport { BaseServerSpan, LoadComponentsSpan, NextServerSpan, NextNodeServerSpan, StartServerSpan, RenderSpan, RouterSpan, AppRenderSpan, NodeSpan, AppRouteRouteHandlersSpan, ResolveMetadataSpan, MiddlewareSpan,  };\r\n\r\n//# sourceMappingURL=constants.js.map","// In output: export mode, the build id is added to the start of the HTML\r\n// document, directly after the doctype declaration. During a prefetch, the\r\n// client performs a range request to get the build id, so it can check whether\r\n// the target page belongs to the same build.\r\n//\r\n// The first 64 bytes of the document are requested. The exact number isn't\r\n// too important; it must be larger than the build id + doctype + closing and\r\n// ending comment markers, but it doesn't need to match the end of the\r\n// comment exactly.\r\n//\r\n// Build ids are 21 bytes long in the default implementation, though this\r\n// can be overridden in the Next.js config. For the purposes of this check,\r\n// it's OK to only match the start of the id, so we'll truncate it if exceeds\r\n// a certain length.\r\nconst DOCTYPE_PREFIX = '<!DOCTYPE html>' // 15 bytes\r\n;\r\nconst MAX_BUILD_ID_LENGTH = 24;\r\n// Request the first 64 bytes. The Range header is inclusive of the end value.\r\nexport const DOC_PREFETCH_RANGE_HEADER_VALUE = 'bytes=0-63';\r\nfunction escapeBuildId(buildId) {\r\n    // If the build id is longer than the given limit, it's OK for our purposes\r\n    // to only match the beginning.\r\n    const truncated = buildId.slice(0, MAX_BUILD_ID_LENGTH);\r\n    // Replace hyphens with underscores so it doesn't break the HTML comment.\r\n    // (Unlikely, but if this did happen it would break the whole document.)\r\n    return truncated.replace(/-/g, '_');\r\n}\r\nexport function insertBuildIdComment(originalHtml, buildId) {\r\n    if (// Skip if the build id contains a closing comment marker.\r\n    buildId.includes('-->') || // React always inserts a doctype at the start of the document. Skip if it\r\n    // isn't present. Shouldn't happen; suggests an issue elsewhere.\r\n    !originalHtml.startsWith(DOCTYPE_PREFIX)) {\r\n        // Return the original HTML unchanged. This means the document will not\r\n        // be prefetched.\r\n        // TODO: The build id comment is currently only used during prefetches, but\r\n        // if we eventually use this mechanism for regular navigations, we may need\r\n        // to error during build if we fail to insert it for some reason.\r\n        return originalHtml;\r\n    }\r\n    // The comment must be inserted after the doctype.\r\n    return originalHtml.replace(DOCTYPE_PREFIX, DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->');\r\n}\r\nexport function doesExportedHtmlMatchBuildId(partialHtmlDocument, buildId) {\r\n    // Check whether the document starts with the expected buildId.\r\n    return partialHtmlDocument.startsWith(DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->');\r\n}\r\n\r\n//# sourceMappingURL=output-export-prefetch-encoding.js.map","/**\r\n * A cache of lowercased locales for each list of locales. This is stored as a\r\n * WeakMap so if the locales are garbage collected, the cache entry will be\r\n * removed as well.\r\n */ const cache = new WeakMap();\r\n/**\r\n * For a pathname that may include a locale from a list of locales, it\r\n * removes the locale from the pathname returning it alongside with the\r\n * detected locale.\r\n *\r\n * @param pathname A pathname that may include a locale.\r\n * @param locales A list of locales.\r\n * @returns The detected locale and pathname without locale\r\n */ export function normalizeLocalePath(pathname, locales) {\r\n    // If locales is undefined, return the pathname as is.\r\n    if (!locales) return {\r\n        pathname\r\n    };\r\n    // Get the cached lowercased locales or create a new cache entry.\r\n    let lowercasedLocales = cache.get(locales);\r\n    if (!lowercasedLocales) {\r\n        lowercasedLocales = locales.map((locale)=>locale.toLowerCase());\r\n        cache.set(locales, lowercasedLocales);\r\n    }\r\n    let detectedLocale;\r\n    // The first segment will be empty, because it has a leading `/`. If\r\n    // there is no further segment, there is no locale (or it's the default).\r\n    const segments = pathname.split('/', 2);\r\n    // If there's no second segment (ie, the pathname is just `/`), there's no\r\n    // locale.\r\n    if (!segments[1]) return {\r\n        pathname\r\n    };\r\n    // The second segment will contain the locale part if any.\r\n    const segment = segments[1].toLowerCase();\r\n    // See if the segment matches one of the locales. If it doesn't, there is\r\n    // no locale (or it's the default).\r\n    const index = lowercasedLocales.indexOf(segment);\r\n    if (index < 0) return {\r\n        pathname\r\n    };\r\n    // Return the case-sensitive locale.\r\n    detectedLocale = locales[index];\r\n    // Remove the `/${locale}` part of the pathname.\r\n    pathname = pathname.slice(detectedLocale.length + 1) || '/';\r\n    return {\r\n        pathname,\r\n        detectedLocale\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=normalize-locale-path.js.map","export { RequestCookies, ResponseCookies, stringifyCookie } from 'next/dist/compiled/@edge-runtime/cookies';\r\n\r\n//# sourceMappingURL=cookies.js.map","import { RouteKind } from '../../route-kind';\r\nimport { BaseServerSpan } from '../../lib/trace/constants';\r\nimport { getTracer, SpanKind } from '../../lib/trace/tracer';\r\nimport { formatUrl } from '../../../shared/lib/router/utils/format-url';\r\nimport { addRequestMeta, getRequestMeta } from '../../request-meta';\r\nimport { interopDefault } from '../../app-render/interop-default';\r\nimport { getRevalidateReason } from '../../instrumentation/utils';\r\nimport { normalizeDataPath } from '../../../shared/lib/page-path/normalize-data-path';\r\nimport { CachedRouteKind } from '../../response-cache';\r\nimport { getCacheControlHeader } from '../../lib/cache-control';\r\nimport { normalizeRepeatedSlashes } from '../../../shared/lib/utils';\r\nimport { getRedirectStatus } from '../../../lib/redirect-status';\r\nimport { CACHE_ONE_YEAR, HTML_CONTENT_TYPE_HEADER, JSON_CONTENT_TYPE_HEADER } from '../../../lib/constants';\r\nimport path from 'path';\r\nimport { sendRenderResult } from '../../send-payload';\r\nimport RenderResult from '../../render-result';\r\nimport { toResponseCacheEntry } from '../../response-cache/utils';\r\nimport { NoFallbackError } from '../../../shared/lib/no-fallback-error.external';\r\nimport { RedirectStatusCode } from '../../../client/components/redirect-status-code';\r\nimport { isBot } from '../../../shared/lib/router/utils/is-bot';\r\nimport { addPathPrefix } from '../../../shared/lib/router/utils/add-path-prefix';\r\nimport { removeTrailingSlash } from '../../../shared/lib/router/utils/remove-trailing-slash';\r\nexport const getHandler = ({ srcPage: originalSrcPage, config, userland, routeModule, isFallbackError, getStaticPaths, getStaticProps, getServerSideProps })=>{\r\n    return async function handler(req, res, ctx) {\r\n        var _serverFilesManifest_config_experimental, _serverFilesManifest_config;\r\n        if (routeModule.isDev) {\r\n            addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\r\n        }\r\n        let srcPage = originalSrcPage;\r\n        // turbopack doesn't normalize `/index` in the page name\r\n        // so we need to to process dynamic routes properly\r\n        // TODO: fix turbopack providing differing value from webpack\r\n        if (process.env.TURBOPACK) {\r\n            srcPage = srcPage.replace(/\\/index$/, '') || '/';\r\n        } else if (srcPage === '/index') {\r\n            // we always normalize /index specifically\r\n            srcPage = '/';\r\n        }\r\n        const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\r\n        const prepareResult = await routeModule.prepare(req, res, {\r\n            srcPage,\r\n            multiZoneDraftMode\r\n        });\r\n        if (!prepareResult) {\r\n            res.statusCode = 400;\r\n            res.end('Bad Request');\r\n            ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\r\n            return;\r\n        }\r\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\r\n        const render404 = async ()=>{\r\n            // TODO: should route-module itself handle rendering the 404\r\n            if (routerServerContext == null ? void 0 : routerServerContext.render404) {\r\n                await routerServerContext.render404(req, res, parsedUrl, false);\r\n            } else {\r\n                res.end('This page could not be found');\r\n            }\r\n        };\r\n        const { buildId, query, params, parsedUrl, originalQuery, originalPathname, buildManifest, fallbackBuildManifest, nextFontManifest, serverFilesManifest, reactLoadableManifest, prerenderManifest, isDraftMode, isOnDemandRevalidate, revalidateOnlyGenerated, locale, locales, defaultLocale, routerServerContext, nextConfig, resolvedPathname, encodedResolvedPathname } = prepareResult;\r\n        const isExperimentalCompile = serverFilesManifest == null ? void 0 : (_serverFilesManifest_config = serverFilesManifest.config) == null ? void 0 : (_serverFilesManifest_config_experimental = _serverFilesManifest_config.experimental) == null ? void 0 : _serverFilesManifest_config_experimental.isExperimentalCompile;\r\n        const hasServerProps = Boolean(getServerSideProps);\r\n        const hasStaticProps = Boolean(getStaticProps);\r\n        const hasStaticPaths = Boolean(getStaticPaths);\r\n        const hasGetInitialProps = Boolean((userland.default || userland).getInitialProps);\r\n        let cacheKey = null;\r\n        let isIsrFallback = false;\r\n        let isNextDataRequest = prepareResult.isNextDataRequest && (hasStaticProps || hasServerProps);\r\n        const is404Page = srcPage === '/404';\r\n        const is500Page = srcPage === '/500';\r\n        const isErrorPage = srcPage === '/_error';\r\n        if (!routeModule.isDev && !isDraftMode && hasStaticProps) {\r\n            cacheKey = `${locale ? `/${locale}` : ''}${(srcPage === '/' || resolvedPathname === '/') && locale ? '' : resolvedPathname}`;\r\n            if (is404Page || is500Page || isErrorPage) {\r\n                cacheKey = `${locale ? `/${locale}` : ''}${srcPage}`;\r\n            }\r\n            // ensure /index and / is normalized to one key\r\n            cacheKey = cacheKey === '/index' ? '/' : cacheKey;\r\n        }\r\n        if (hasStaticPaths && !isDraftMode) {\r\n            const decodedPathname = removeTrailingSlash(locale ? addPathPrefix(resolvedPathname, `/${locale}`) : resolvedPathname);\r\n            const isPrerendered = Boolean(prerenderManifest.routes[decodedPathname]) || prerenderManifest.notFoundRoutes.includes(decodedPathname);\r\n            const prerenderInfo = prerenderManifest.dynamicRoutes[srcPage];\r\n            if (prerenderInfo) {\r\n                if (prerenderInfo.fallback === false && !isPrerendered) {\r\n                    if (nextConfig.experimental.adapterPath) {\r\n                        return await render404();\r\n                    }\r\n                    throw new NoFallbackError();\r\n                }\r\n                if (typeof prerenderInfo.fallback === 'string' && !isPrerendered && !isNextDataRequest) {\r\n                    isIsrFallback = true;\r\n                }\r\n            }\r\n        }\r\n        // When serving a bot request, we want to serve a blocking render and not\r\n        // the prerendered page. This ensures that the correct content is served\r\n        // to the bot in the head.\r\n        if (isIsrFallback && isBot(req.headers['user-agent'] || '') || isMinimalMode) {\r\n            isIsrFallback = false;\r\n        }\r\n        const tracer = getTracer();\r\n        const activeSpan = tracer.getActiveScopeSpan();\r\n        try {\r\n            var _parsedUrl_pathname;\r\n            const method = req.method || 'GET';\r\n            const resolvedUrl = formatUrl({\r\n                pathname: nextConfig.trailingSlash ? `${encodedResolvedPathname}${!encodedResolvedPathname.endsWith('/') && ((_parsedUrl_pathname = parsedUrl.pathname) == null ? void 0 : _parsedUrl_pathname.endsWith('/')) ? '/' : ''}` : removeTrailingSlash(encodedResolvedPathname || '/'),\r\n                // make sure to only add query values from original URL\r\n                query: hasStaticProps ? {} : originalQuery\r\n            });\r\n            const handleResponse = async (span)=>{\r\n                const responseGenerator = async ({ previousCacheEntry })=>{\r\n                    var _previousCacheEntry_value;\r\n                    const doRender = async ()=>{\r\n                        try {\r\n                            var _nextConfig_i18n;\r\n                            return await routeModule.render(req, res, {\r\n                                query: hasStaticProps && !isExperimentalCompile ? {\r\n                                    ...params\r\n                                } : {\r\n                                    ...query,\r\n                                    ...params\r\n                                },\r\n                                params,\r\n                                page: srcPage,\r\n                                renderContext: {\r\n                                    isDraftMode,\r\n                                    isFallback: isIsrFallback,\r\n                                    developmentNotFoundSourcePage: getRequestMeta(req, 'developmentNotFoundSourcePage')\r\n                                },\r\n                                sharedContext: {\r\n                                    buildId,\r\n                                    customServer: Boolean(routerServerContext == null ? void 0 : routerServerContext.isCustomServer) || undefined,\r\n                                    deploymentId: process.env.NEXT_DEPLOYMENT_ID\r\n                                },\r\n                                renderOpts: {\r\n                                    params,\r\n                                    routeModule,\r\n                                    page: srcPage,\r\n                                    pageConfig: config || {},\r\n                                    Component: interopDefault(userland),\r\n                                    ComponentMod: userland,\r\n                                    getStaticProps,\r\n                                    getStaticPaths,\r\n                                    getServerSideProps,\r\n                                    supportsDynamicResponse: !hasStaticProps,\r\n                                    buildManifest: isFallbackError ? fallbackBuildManifest : buildManifest,\r\n                                    nextFontManifest,\r\n                                    reactLoadableManifest,\r\n                                    assetPrefix: nextConfig.assetPrefix,\r\n                                    previewProps: prerenderManifest.preview,\r\n                                    images: nextConfig.images,\r\n                                    nextConfigOutput: nextConfig.output,\r\n                                    optimizeCss: Boolean(nextConfig.experimental.optimizeCss),\r\n                                    nextScriptWorkers: Boolean(nextConfig.experimental.nextScriptWorkers),\r\n                                    domainLocales: (_nextConfig_i18n = nextConfig.i18n) == null ? void 0 : _nextConfig_i18n.domains,\r\n                                    crossOrigin: nextConfig.crossOrigin,\r\n                                    multiZoneDraftMode,\r\n                                    basePath: nextConfig.basePath,\r\n                                    disableOptimizedLoading: nextConfig.experimental.disableOptimizedLoading,\r\n                                    largePageDataBytes: nextConfig.experimental.largePageDataBytes,\r\n                                    isExperimentalCompile,\r\n                                    experimental: {\r\n                                        clientTraceMetadata: nextConfig.experimental.clientTraceMetadata || []\r\n                                    },\r\n                                    locale,\r\n                                    locales,\r\n                                    defaultLocale,\r\n                                    setIsrStatus: routerServerContext == null ? void 0 : routerServerContext.setIsrStatus,\r\n                                    isNextDataRequest: isNextDataRequest && (hasServerProps || hasStaticProps),\r\n                                    resolvedUrl,\r\n                                    // For getServerSideProps and getInitialProps we need to ensure we use the original URL\r\n                                    // and not the resolved URL to prevent a hydration mismatch on\r\n                                    // asPath\r\n                                    resolvedAsPath: hasServerProps || hasGetInitialProps ? formatUrl({\r\n                                        // we use the original URL pathname less the _next/data prefix if\r\n                                        // present\r\n                                        pathname: isNextDataRequest ? normalizeDataPath(originalPathname) : originalPathname,\r\n                                        query: originalQuery\r\n                                    }) : resolvedUrl,\r\n                                    isOnDemandRevalidate,\r\n                                    ErrorDebug: getRequestMeta(req, 'PagesErrorDebug'),\r\n                                    err: getRequestMeta(req, 'invokeError'),\r\n                                    dev: routeModule.isDev,\r\n                                    // needed for experimental.optimizeCss feature\r\n                                    distDir: path.join(/* turbopackIgnore: true */ process.cwd(), routeModule.relativeProjectDir, routeModule.distDir)\r\n                                }\r\n                            }).then((renderResult)=>{\r\n                                const { metadata } = renderResult;\r\n                                let cacheControl = metadata.cacheControl;\r\n                                if ('isNotFound' in metadata && metadata.isNotFound) {\r\n                                    return {\r\n                                        value: null,\r\n                                        cacheControl\r\n                                    };\r\n                                }\r\n                                // Handle `isRedirect`.\r\n                                if (metadata.isRedirect) {\r\n                                    return {\r\n                                        value: {\r\n                                            kind: CachedRouteKind.REDIRECT,\r\n                                            props: metadata.pageData ?? metadata.flightData\r\n                                        },\r\n                                        cacheControl\r\n                                    };\r\n                                }\r\n                                return {\r\n                                    value: {\r\n                                        kind: CachedRouteKind.PAGES,\r\n                                        html: renderResult,\r\n                                        pageData: renderResult.metadata.pageData,\r\n                                        headers: renderResult.metadata.headers,\r\n                                        status: renderResult.metadata.statusCode\r\n                                    },\r\n                                    cacheControl\r\n                                };\r\n                            }).finally(()=>{\r\n                                if (!span) return;\r\n                                span.setAttributes({\r\n                                    'http.status_code': res.statusCode,\r\n                                    'next.rsc': false\r\n                                });\r\n                                const rootSpanAttributes = tracer.getRootSpanAttributes();\r\n                                // We were unable to get attributes, probably OTEL is not enabled\r\n                                if (!rootSpanAttributes) {\r\n                                    return;\r\n                                }\r\n                                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\r\n                                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\r\n                                    return;\r\n                                }\r\n                                const route = rootSpanAttributes.get('next.route');\r\n                                if (route) {\r\n                                    const name = `${method} ${route}`;\r\n                                    span.setAttributes({\r\n                                        'next.route': route,\r\n                                        'http.route': route,\r\n                                        'next.span_name': name\r\n                                    });\r\n                                    span.updateName(name);\r\n                                } else {\r\n                                    span.updateName(`${method} ${srcPage}`);\r\n                                }\r\n                            });\r\n                        } catch (err) {\r\n                            // if this is a background revalidate we need to report\r\n                            // the request error here as it won't be bubbled\r\n                            if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\r\n                                await routeModule.onRequestError(req, err, {\r\n                                    routerKind: 'Pages Router',\r\n                                    routePath: srcPage,\r\n                                    routeType: 'render',\r\n                                    revalidateReason: getRevalidateReason({\r\n                                        isStaticGeneration: hasStaticProps,\r\n                                        isOnDemandRevalidate\r\n                                    })\r\n                                }, routerServerContext);\r\n                            }\r\n                            throw err;\r\n                        }\r\n                    };\r\n                    // if we've already generated this page we no longer\r\n                    // serve the fallback\r\n                    if (previousCacheEntry) {\r\n                        isIsrFallback = false;\r\n                    }\r\n                    if (isIsrFallback) {\r\n                        const fallbackResponse = await routeModule.getResponseCache(req).get(routeModule.isDev ? null : locale ? `/${locale}${srcPage}` : srcPage, async ({ previousCacheEntry: previousFallbackCacheEntry = null })=>{\r\n                            if (!routeModule.isDev) {\r\n                                return toResponseCacheEntry(previousFallbackCacheEntry);\r\n                            }\r\n                            return doRender();\r\n                        }, {\r\n                            routeKind: RouteKind.PAGES,\r\n                            isFallback: true,\r\n                            isRoutePPREnabled: false,\r\n                            isOnDemandRevalidate: false,\r\n                            incrementalCache: await routeModule.getIncrementalCache(req, nextConfig, prerenderManifest, isMinimalMode),\r\n                            waitUntil: ctx.waitUntil\r\n                        });\r\n                        if (fallbackResponse) {\r\n                            // Remove the cache control from the response to prevent it from being\r\n                            // used in the surrounding cache.\r\n                            delete fallbackResponse.cacheControl;\r\n                            fallbackResponse.isMiss = true;\r\n                            return fallbackResponse;\r\n                        }\r\n                    }\r\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\r\n                        res.statusCode = 404;\r\n                        // on-demand revalidate always sets this header\r\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\r\n                        res.end('This page could not be found');\r\n                        return null;\r\n                    }\r\n                    if (isIsrFallback && (previousCacheEntry == null ? void 0 : (_previousCacheEntry_value = previousCacheEntry.value) == null ? void 0 : _previousCacheEntry_value.kind) === CachedRouteKind.PAGES) {\r\n                        return {\r\n                            value: {\r\n                                kind: CachedRouteKind.PAGES,\r\n                                html: new RenderResult(Buffer.from(previousCacheEntry.value.html), {\r\n                                    contentType: HTML_CONTENT_TYPE_HEADER,\r\n                                    metadata: {\r\n                                        statusCode: previousCacheEntry.value.status,\r\n                                        headers: previousCacheEntry.value.headers\r\n                                    }\r\n                                }),\r\n                                pageData: {},\r\n                                status: previousCacheEntry.value.status,\r\n                                headers: previousCacheEntry.value.headers\r\n                            },\r\n                            cacheControl: {\r\n                                revalidate: 0,\r\n                                expire: undefined\r\n                            }\r\n                        };\r\n                    }\r\n                    return doRender();\r\n                };\r\n                const result = await routeModule.handleResponse({\r\n                    cacheKey,\r\n                    req,\r\n                    nextConfig,\r\n                    routeKind: RouteKind.PAGES,\r\n                    isOnDemandRevalidate,\r\n                    revalidateOnlyGenerated,\r\n                    waitUntil: ctx.waitUntil,\r\n                    responseGenerator: responseGenerator,\r\n                    prerenderManifest,\r\n                    isMinimalMode\r\n                });\r\n                // if we got a cache hit this wasn't an ISR fallback\r\n                // but it wasn't generated during build so isn't in the\r\n                // prerender-manifest\r\n                if (isIsrFallback && !(result == null ? void 0 : result.isMiss)) {\r\n                    isIsrFallback = false;\r\n                }\r\n                // response is finished is no cache entry\r\n                if (!result) {\r\n                    return;\r\n                }\r\n                if (hasStaticProps && !isMinimalMode) {\r\n                    res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : result.isMiss ? 'MISS' : result.isStale ? 'STALE' : 'HIT');\r\n                }\r\n                let cacheControl;\r\n                if (!hasStaticProps || isIsrFallback) {\r\n                    if (!res.getHeader('Cache-Control')) {\r\n                        cacheControl = {\r\n                            revalidate: 0,\r\n                            expire: undefined\r\n                        };\r\n                    }\r\n                } else if (is404Page) {\r\n                    const notFoundRevalidate = getRequestMeta(req, 'notFoundRevalidate');\r\n                    cacheControl = {\r\n                        revalidate: typeof notFoundRevalidate === 'undefined' ? 0 : notFoundRevalidate,\r\n                        expire: undefined\r\n                    };\r\n                } else if (is500Page) {\r\n                    cacheControl = {\r\n                        revalidate: 0,\r\n                        expire: undefined\r\n                    };\r\n                } else if (result.cacheControl) {\r\n                    // If the cache entry has a cache control with a revalidate value that's\r\n                    // a number, use it.\r\n                    if (typeof result.cacheControl.revalidate === 'number') {\r\n                        var _result_cacheControl;\r\n                        if (result.cacheControl.revalidate < 1) {\r\n                            throw Object.defineProperty(new Error(`Invalid revalidate configuration provided: ${result.cacheControl.revalidate} < 1`), \"__NEXT_ERROR_CODE\", {\r\n                                value: \"E22\",\r\n                                enumerable: false,\r\n                                configurable: true\r\n                            });\r\n                        }\r\n                        cacheControl = {\r\n                            revalidate: result.cacheControl.revalidate,\r\n                            expire: ((_result_cacheControl = result.cacheControl) == null ? void 0 : _result_cacheControl.expire) ?? nextConfig.expireTime\r\n                        };\r\n                    } else {\r\n                        // revalidate: false\r\n                        cacheControl = {\r\n                            revalidate: CACHE_ONE_YEAR,\r\n                            expire: undefined\r\n                        };\r\n                    }\r\n                }\r\n                // If cache control is already set on the response we don't\r\n                // override it to allow users to customize it via next.config\r\n                if (cacheControl && !res.getHeader('Cache-Control')) {\r\n                    res.setHeader('Cache-Control', getCacheControlHeader(cacheControl));\r\n                }\r\n                // notFound: true case\r\n                if (!result.value) {\r\n                    var _result_cacheControl1;\r\n                    // add revalidate metadata before rendering 404 page\r\n                    // so that we can use this as source of truth for the\r\n                    // cache-control header instead of what the 404 page returns\r\n                    // for the revalidate value\r\n                    addRequestMeta(req, 'notFoundRevalidate', (_result_cacheControl1 = result.cacheControl) == null ? void 0 : _result_cacheControl1.revalidate);\r\n                    res.statusCode = 404;\r\n                    if (isNextDataRequest) {\r\n                        res.end('{\"notFound\":true}');\r\n                        return;\r\n                    }\r\n                    return await render404();\r\n                }\r\n                if (result.value.kind === CachedRouteKind.REDIRECT) {\r\n                    if (isNextDataRequest) {\r\n                        res.setHeader('content-type', JSON_CONTENT_TYPE_HEADER);\r\n                        res.end(JSON.stringify(result.value.props));\r\n                        return;\r\n                    } else {\r\n                        const handleRedirect = (pageData)=>{\r\n                            const redirect = {\r\n                                destination: pageData.pageProps.__N_REDIRECT,\r\n                                statusCode: pageData.pageProps.__N_REDIRECT_STATUS,\r\n                                basePath: pageData.pageProps.__N_REDIRECT_BASE_PATH\r\n                            };\r\n                            const statusCode = getRedirectStatus(redirect);\r\n                            const { basePath } = nextConfig;\r\n                            if (basePath && redirect.basePath !== false && redirect.destination.startsWith('/')) {\r\n                                redirect.destination = `${basePath}${redirect.destination}`;\r\n                            }\r\n                            if (redirect.destination.startsWith('/')) {\r\n                                redirect.destination = normalizeRepeatedSlashes(redirect.destination);\r\n                            }\r\n                            res.statusCode = statusCode;\r\n                            res.setHeader('Location', redirect.destination);\r\n                            if (statusCode === RedirectStatusCode.PermanentRedirect) {\r\n                                res.setHeader('Refresh', `0;url=${redirect.destination}`);\r\n                            }\r\n                            res.end(redirect.destination);\r\n                        };\r\n                        await handleRedirect(result.value.props);\r\n                        return null;\r\n                    }\r\n                }\r\n                if (result.value.kind !== CachedRouteKind.PAGES) {\r\n                    throw Object.defineProperty(new Error(`Invariant: received non-pages cache entry in pages handler`), \"__NEXT_ERROR_CODE\", {\r\n                        value: \"E695\",\r\n                        enumerable: false,\r\n                        configurable: true\r\n                    });\r\n                }\r\n                // In dev, we should not cache pages for any reason.\r\n                if (routeModule.isDev) {\r\n                    res.setHeader('Cache-Control', 'no-store, must-revalidate');\r\n                }\r\n                // Draft mode should never be cached\r\n                if (isDraftMode) {\r\n                    res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\r\n                }\r\n                // when invoking _error before pages/500 we don't actually\r\n                // send the _error response\r\n                if (getRequestMeta(req, 'customErrorRender') || isErrorPage && isMinimalMode && res.statusCode === 500) {\r\n                    return null;\r\n                }\r\n                await sendRenderResult({\r\n                    req,\r\n                    res,\r\n                    // If we are rendering the error page it's not a data request\r\n                    // anymore\r\n                    result: isNextDataRequest && !isErrorPage && !is500Page ? new RenderResult(Buffer.from(JSON.stringify(result.value.pageData)), {\r\n                        contentType: JSON_CONTENT_TYPE_HEADER,\r\n                        metadata: result.value.html.metadata\r\n                    }) : result.value.html,\r\n                    generateEtags: nextConfig.generateEtags,\r\n                    poweredByHeader: nextConfig.poweredByHeader,\r\n                    cacheControl: routeModule.isDev ? undefined : cacheControl\r\n                });\r\n            };\r\n            // TODO: activeSpan code path is for when wrapped by\r\n            // next-server can be removed when this is no longer used\r\n            if (activeSpan) {\r\n                await handleResponse();\r\n            } else {\r\n                await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\r\n                        spanName: `${method} ${srcPage}`,\r\n                        kind: SpanKind.SERVER,\r\n                        attributes: {\r\n                            'http.method': method,\r\n                            'http.target': req.url\r\n                        }\r\n                    }, handleResponse));\r\n            }\r\n        } catch (err) {\r\n            if (!(err instanceof NoFallbackError)) {\r\n                await routeModule.onRequestError(req, err, {\r\n                    routerKind: 'Pages Router',\r\n                    routePath: srcPage,\r\n                    routeType: 'render',\r\n                    revalidateReason: getRevalidateReason({\r\n                        isStaticGeneration: hasStaticProps,\r\n                        isOnDemandRevalidate\r\n                    })\r\n                }, routerServerContext);\r\n            }\r\n            // rethrow so that we can handle serving error page\r\n            throw err;\r\n        }\r\n    };\r\n};\r\n\r\n//# sourceMappingURL=pages-handler.js.map","export const RSC_HEADER = 'rsc';\r\nexport const ACTION_HEADER = 'next-action';\r\n// TODO: Instead of sending the full router state, we only need to send the\r\n// segment path. Saves bytes. Then we could also use this field for segment\r\n// prefetches, which also need to specify a particular segment.\r\nexport const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree';\r\nexport const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch';\r\n// This contains the path to the segment being prefetched.\r\n// TODO: If we change next-router-state-tree to be a segment path, we can use\r\n// that instead. Then next-router-prefetch and next-router-segment-prefetch can\r\n// be merged into a single enum.\r\nexport const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER = 'next-router-segment-prefetch';\r\nexport const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh';\r\nexport const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__';\r\nexport const NEXT_URL = 'next-url';\r\nexport const RSC_CONTENT_TYPE_HEADER = 'text/x-component';\r\nexport const FLIGHT_HEADERS = [\r\n    RSC_HEADER,\r\n    NEXT_ROUTER_STATE_TREE_HEADER,\r\n    NEXT_ROUTER_PREFETCH_HEADER,\r\n    NEXT_HMR_REFRESH_HEADER,\r\n    NEXT_ROUTER_SEGMENT_PREFETCH_HEADER\r\n];\r\nexport const NEXT_RSC_UNION_QUERY = '_rsc';\r\nexport const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time';\r\nexport const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed';\r\nexport const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path';\r\nexport const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query';\r\nexport const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender';\r\nexport const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found';\r\nexport const NEXT_REQUEST_ID_HEADER = 'x-nextjs-request-id';\r\nexport const NEXT_HTML_REQUEST_ID_HEADER = 'x-nextjs-html-request-id';\r\n\r\n//# sourceMappingURL=app-router-headers.js.map","export var CachedRouteKind = /*#__PURE__*/ function(CachedRouteKind) {\r\n    CachedRouteKind[\"APP_PAGE\"] = \"APP_PAGE\";\r\n    CachedRouteKind[\"APP_ROUTE\"] = \"APP_ROUTE\";\r\n    CachedRouteKind[\"PAGES\"] = \"PAGES\";\r\n    CachedRouteKind[\"FETCH\"] = \"FETCH\";\r\n    CachedRouteKind[\"REDIRECT\"] = \"REDIRECT\";\r\n    CachedRouteKind[\"IMAGE\"] = \"IMAGE\";\r\n    return CachedRouteKind;\r\n}({});\r\nexport var IncrementalCacheKind = /*#__PURE__*/ function(IncrementalCacheKind) {\r\n    IncrementalCacheKind[\"APP_PAGE\"] = \"APP_PAGE\";\r\n    IncrementalCacheKind[\"APP_ROUTE\"] = \"APP_ROUTE\";\r\n    IncrementalCacheKind[\"PAGES\"] = \"PAGES\";\r\n    IncrementalCacheKind[\"FETCH\"] = \"FETCH\";\r\n    IncrementalCacheKind[\"IMAGE\"] = \"IMAGE\";\r\n    return IncrementalCacheKind;\r\n}({});\r\n\r\n//# sourceMappingURL=types.js.map","export const ENCODED_TAGS = {\r\n    // opening tags do not have the closing `>` since they can contain other attributes such as `<body className=''>`\r\n    OPENING: {\r\n        // <html\r\n        HTML: new Uint8Array([\r\n            60,\r\n            104,\r\n            116,\r\n            109,\r\n            108\r\n        ]),\r\n        // <body\r\n        BODY: new Uint8Array([\r\n            60,\r\n            98,\r\n            111,\r\n            100,\r\n            121\r\n        ])\r\n    },\r\n    CLOSED: {\r\n        // </head>\r\n        HEAD: new Uint8Array([\r\n            60,\r\n            47,\r\n            104,\r\n            101,\r\n            97,\r\n            100,\r\n            62\r\n        ]),\r\n        // </body>\r\n        BODY: new Uint8Array([\r\n            60,\r\n            47,\r\n            98,\r\n            111,\r\n            100,\r\n            121,\r\n            62\r\n        ]),\r\n        // </html>\r\n        HTML: new Uint8Array([\r\n            60,\r\n            47,\r\n            104,\r\n            116,\r\n            109,\r\n            108,\r\n            62\r\n        ]),\r\n        // </body></html>\r\n        BODY_AND_HTML: new Uint8Array([\r\n            60,\r\n            47,\r\n            98,\r\n            111,\r\n            100,\r\n            121,\r\n            62,\r\n            60,\r\n            47,\r\n            104,\r\n            116,\r\n            109,\r\n            108,\r\n            62\r\n        ])\r\n    },\r\n    META: {\r\n        // Only the match the prefix cause the suffix can be different wether it's xml compatible or not \">\" or \"/>\"\r\n        // <meta name=\"nxt-icon\"\r\n        // This is a special mark that will be replaced by the icon insertion script tag.\r\n        ICON_MARK: new Uint8Array([\r\n            60,\r\n            109,\r\n            101,\r\n            116,\r\n            97,\r\n            32,\r\n            110,\r\n            97,\r\n            109,\r\n            101,\r\n            61,\r\n            34,\r\n            194,\r\n            171,\r\n            110,\r\n            120,\r\n            116,\r\n            45,\r\n            105,\r\n            99,\r\n            111,\r\n            110,\r\n            194,\r\n            187,\r\n            34\r\n        ])\r\n    }\r\n};\r\n\r\n//# sourceMappingURL=encoded-tags.js.map","export const MISSING_ROOT_TAGS_ERROR = 'NEXT_MISSING_ROOT_TAGS';\r\n\r\n//# sourceMappingURL=constants.js.map","export function searchParamsToUrlQuery(searchParams) {\r\n    const query = {};\r\n    for (const [key, value] of searchParams.entries()){\r\n        const existing = query[key];\r\n        if (typeof existing === 'undefined') {\r\n            query[key] = value;\r\n        } else if (Array.isArray(existing)) {\r\n            existing.push(value);\r\n        } else {\r\n            query[key] = [\r\n                existing,\r\n                value\r\n            ];\r\n        }\r\n    }\r\n    return query;\r\n}\r\nfunction stringifyUrlQueryParam(param) {\r\n    if (typeof param === 'string') {\r\n        return param;\r\n    }\r\n    if (typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {\r\n        return String(param);\r\n    } else {\r\n        return '';\r\n    }\r\n}\r\nexport function urlQueryToSearchParams(query) {\r\n    const searchParams = new URLSearchParams();\r\n    for (const [key, value] of Object.entries(query)){\r\n        if (Array.isArray(value)) {\r\n            for (const item of value){\r\n                searchParams.append(key, stringifyUrlQueryParam(item));\r\n            }\r\n        } else {\r\n            searchParams.set(key, stringifyUrlQueryParam(value));\r\n        }\r\n    }\r\n    return searchParams;\r\n}\r\nexport function assign(target, ...searchParamsList) {\r\n    for (const searchParams of searchParamsList){\r\n        for (const key of searchParams.keys()){\r\n            target.delete(key);\r\n        }\r\n        for (const [key, value] of searchParams.entries()){\r\n            target.append(key, value);\r\n        }\r\n    }\r\n    return target;\r\n}\r\n\r\n//# sourceMappingURL=querystring.js.map","export function detectDomainLocale(domainItems, hostname, detectedLocale) {\r\n    if (!domainItems) return;\r\n    if (detectedLocale) {\r\n        detectedLocale = detectedLocale.toLowerCase();\r\n    }\r\n    for (const item of domainItems){\r\n        // remove port if present\r\n        const domainHostname = item.domain?.split(':', 1)[0].toLowerCase();\r\n        if (hostname === domainHostname || detectedLocale === item.defaultLocale.toLowerCase() || item.locales?.some((locale)=>locale.toLowerCase() === detectedLocale)) {\r\n            return item;\r\n        }\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=detect-domain-locale.js.map","export function getRevalidateReason(params) {\r\n    if (params.isOnDemandRevalidate) {\r\n        return 'on-demand';\r\n    }\r\n    if (params.isStaticGeneration) {\r\n        return 'stale';\r\n    }\r\n    return undefined;\r\n}\r\n\r\n//# sourceMappingURL=utils.js.map","export class PageSignatureError extends Error {\r\n    constructor({ page }){\r\n        super(`The middleware \"${page}\" accepts an async API directly with the form:\r\n  \r\n  export function middleware(request, event) {\r\n    return NextResponse.redirect('/new-location')\r\n  }\r\n  \r\n  Read more: https://nextjs.org/docs/messages/middleware-new-signature\r\n  `);\r\n    }\r\n}\r\nexport class RemovedPageError extends Error {\r\n    constructor(){\r\n        super(`The request.page has been deprecated in favour of \\`URLPattern\\`.\r\n  Read more: https://nextjs.org/docs/messages/middleware-request-page\r\n  `);\r\n    }\r\n}\r\nexport class RemovedUAError extends Error {\r\n    constructor(){\r\n        super(`The request.ua has been removed in favour of \\`userAgent\\` function.\r\n  Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent\r\n  `);\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=error.js.map","export class InvariantError extends Error {\r\n    constructor(message, options){\r\n        super(`Invariant: ${message.endsWith('.') ? message : message + '.'} This is a bug in Next.js.`, options);\r\n        this.name = 'InvariantError';\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=invariant-error.js.map","export var RedirectStatusCode = /*#__PURE__*/ function(RedirectStatusCode) {\r\n    RedirectStatusCode[RedirectStatusCode[\"SeeOther\"] = 303] = \"SeeOther\";\r\n    RedirectStatusCode[RedirectStatusCode[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\r\n    RedirectStatusCode[RedirectStatusCode[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\r\n    return RedirectStatusCode;\r\n}({});\r\n\r\n//# sourceMappingURL=redirect-status-code.js.map","export const TEXT_PLAIN_CONTENT_TYPE_HEADER = 'text/plain';\r\nexport const HTML_CONTENT_TYPE_HEADER = 'text/html; charset=utf-8';\r\nexport const JSON_CONTENT_TYPE_HEADER = 'application/json; charset=utf-8';\r\nexport const NEXT_QUERY_PARAM_PREFIX = 'nxtP';\r\nexport const NEXT_INTERCEPTION_MARKER_PREFIX = 'nxtI';\r\nexport const MATCHED_PATH_HEADER = 'x-matched-path';\r\nexport const PRERENDER_REVALIDATE_HEADER = 'x-prerender-revalidate';\r\nexport const PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER = 'x-prerender-revalidate-if-generated';\r\nexport const RSC_PREFETCH_SUFFIX = '.prefetch.rsc';\r\nexport const RSC_SEGMENTS_DIR_SUFFIX = '.segments';\r\nexport const RSC_SEGMENT_SUFFIX = '.segment.rsc';\r\nexport const RSC_SUFFIX = '.rsc';\r\nexport const ACTION_SUFFIX = '.action';\r\nexport const NEXT_DATA_SUFFIX = '.json';\r\nexport const NEXT_META_SUFFIX = '.meta';\r\nexport const NEXT_BODY_SUFFIX = '.body';\r\nexport const NEXT_CACHE_TAGS_HEADER = 'x-next-cache-tags';\r\nexport const NEXT_CACHE_REVALIDATED_TAGS_HEADER = 'x-next-revalidated-tags';\r\nexport const NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER = 'x-next-revalidate-tag-token';\r\nexport const NEXT_RESUME_HEADER = 'next-resume';\r\n// if these change make sure we update the related\r\n// documentation as well\r\nexport const NEXT_CACHE_TAG_MAX_ITEMS = 128;\r\nexport const NEXT_CACHE_TAG_MAX_LENGTH = 256;\r\nexport const NEXT_CACHE_SOFT_TAG_MAX_LENGTH = 1024;\r\nexport const NEXT_CACHE_IMPLICIT_TAG_ID = '_N_T_';\r\n// in seconds\r\nexport const CACHE_ONE_YEAR = 31536000;\r\n// in seconds, represents revalidate=false. I.e. never revaliate.\r\n// We use this value since it can be represented as a V8 SMI for optimal performance.\r\n// It can also be serialized as JSON if it ever leaks accidentally as an actual value.\r\nexport const INFINITE_CACHE = 0xfffffffe;\r\n// Patterns to detect middleware files\r\nexport const MIDDLEWARE_FILENAME = 'middleware';\r\nexport const MIDDLEWARE_LOCATION_REGEXP = `(?:src/)?${MIDDLEWARE_FILENAME}`;\r\n// Patterns to detect proxy files (replacement for middleware)\r\nexport const PROXY_FILENAME = 'proxy';\r\nexport const PROXY_LOCATION_REGEXP = `(?:src/)?${PROXY_FILENAME}`;\r\n// Pattern to detect instrumentation hooks file\r\nexport const INSTRUMENTATION_HOOK_FILENAME = 'instrumentation';\r\n// Because on Windows absolute paths in the generated code can break because of numbers, eg 1 in the path,\r\n// we have to use a private alias\r\nexport const PAGES_DIR_ALIAS = 'private-next-pages';\r\nexport const DOT_NEXT_ALIAS = 'private-dot-next';\r\nexport const ROOT_DIR_ALIAS = 'private-next-root-dir';\r\nexport const APP_DIR_ALIAS = 'private-next-app-dir';\r\nexport const RSC_MOD_REF_PROXY_ALIAS = 'private-next-rsc-mod-ref-proxy';\r\nexport const RSC_ACTION_VALIDATE_ALIAS = 'private-next-rsc-action-validate';\r\nexport const RSC_ACTION_PROXY_ALIAS = 'private-next-rsc-server-reference';\r\nexport const RSC_CACHE_WRAPPER_ALIAS = 'private-next-rsc-cache-wrapper';\r\nexport const RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS = 'private-next-rsc-track-dynamic-import';\r\nexport const RSC_ACTION_ENCRYPTION_ALIAS = 'private-next-rsc-action-encryption';\r\nexport const RSC_ACTION_CLIENT_WRAPPER_ALIAS = 'private-next-rsc-action-client-wrapper';\r\nexport const PUBLIC_DIR_MIDDLEWARE_CONFLICT = `You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://nextjs.org/docs/messages/public-next-folder-conflict`;\r\nexport const SSG_GET_INITIAL_PROPS_CONFLICT = `You can not use getInitialProps with getStaticProps. To use SSG, please remove your getInitialProps`;\r\nexport const SERVER_PROPS_GET_INIT_PROPS_CONFLICT = `You can not use getInitialProps with getServerSideProps. Please remove getInitialProps.`;\r\nexport const SERVER_PROPS_SSG_CONFLICT = `You can not use getStaticProps or getStaticPaths with getServerSideProps. To use SSG, please remove getServerSideProps`;\r\nexport const STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR = `can not have getInitialProps/getServerSideProps, https://nextjs.org/docs/messages/404-get-initial-props`;\r\nexport const SERVER_PROPS_EXPORT_ERROR = `pages with \\`getServerSideProps\\` can not be exported. See more info here: https://nextjs.org/docs/messages/gssp-export`;\r\nexport const GSP_NO_RETURNED_VALUE = 'Your `getStaticProps` function did not return an object. Did you forget to add a `return`?';\r\nexport const GSSP_NO_RETURNED_VALUE = 'Your `getServerSideProps` function did not return an object. Did you forget to add a `return`?';\r\nexport const UNSTABLE_REVALIDATE_RENAME_ERROR = 'The `unstable_revalidate` property is available for general use.\\n' + 'Please use `revalidate` instead.';\r\nexport const GSSP_COMPONENT_MEMBER_ERROR = `can not be attached to a page's component and must be exported from the page. See more info here: https://nextjs.org/docs/messages/gssp-component-member`;\r\nexport const NON_STANDARD_NODE_ENV = `You are using a non-standard \"NODE_ENV\" value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env`;\r\nexport const SSG_FALLBACK_EXPORT_ERROR = `Pages with \\`fallback\\` enabled in \\`getStaticPaths\\` can not be exported. See more info here: https://nextjs.org/docs/messages/ssg-fallback-true-export`;\r\nexport const ESLINT_DEFAULT_DIRS = [\r\n    'app',\r\n    'pages',\r\n    'components',\r\n    'lib',\r\n    'src'\r\n];\r\nexport const SERVER_RUNTIME = {\r\n    edge: 'edge',\r\n    experimentalEdge: 'experimental-edge',\r\n    nodejs: 'nodejs'\r\n};\r\nexport const WEB_SOCKET_MAX_RECONNECTIONS = 12;\r\n/**\r\n * The names of the webpack layers. These layers are the primitives for the\r\n * webpack chunks.\r\n */ const WEBPACK_LAYERS_NAMES = {\r\n    /**\r\n   * The layer for the shared code between the client and server bundles.\r\n   */ shared: 'shared',\r\n    /**\r\n   * The layer for server-only runtime and picking up `react-server` export conditions.\r\n   * Including app router RSC pages and app router custom routes and metadata routes.\r\n   */ reactServerComponents: 'rsc',\r\n    /**\r\n   * Server Side Rendering layer for app (ssr).\r\n   */ serverSideRendering: 'ssr',\r\n    /**\r\n   * The browser client bundle layer for actions.\r\n   */ actionBrowser: 'action-browser',\r\n    /**\r\n   * The Node.js bundle layer for the API routes.\r\n   */ apiNode: 'api-node',\r\n    /**\r\n   * The Edge Lite bundle layer for the API routes.\r\n   */ apiEdge: 'api-edge',\r\n    /**\r\n   * The layer for the middleware code.\r\n   */ middleware: 'middleware',\r\n    /**\r\n   * The layer for the instrumentation hooks.\r\n   */ instrument: 'instrument',\r\n    /**\r\n   * The layer for assets on the edge.\r\n   */ edgeAsset: 'edge-asset',\r\n    /**\r\n   * The browser client bundle layer for App directory.\r\n   */ appPagesBrowser: 'app-pages-browser',\r\n    /**\r\n   * The browser client bundle layer for Pages directory.\r\n   */ pagesDirBrowser: 'pages-dir-browser',\r\n    /**\r\n   * The Edge Lite bundle layer for Pages directory.\r\n   */ pagesDirEdge: 'pages-dir-edge',\r\n    /**\r\n   * The Node.js bundle layer for Pages directory.\r\n   */ pagesDirNode: 'pages-dir-node'\r\n};\r\nconst WEBPACK_LAYERS = {\r\n    ...WEBPACK_LAYERS_NAMES,\r\n    GROUP: {\r\n        builtinReact: [\r\n            WEBPACK_LAYERS_NAMES.reactServerComponents,\r\n            WEBPACK_LAYERS_NAMES.actionBrowser\r\n        ],\r\n        serverOnly: [\r\n            WEBPACK_LAYERS_NAMES.reactServerComponents,\r\n            WEBPACK_LAYERS_NAMES.actionBrowser,\r\n            WEBPACK_LAYERS_NAMES.instrument,\r\n            WEBPACK_LAYERS_NAMES.middleware\r\n        ],\r\n        neutralTarget: [\r\n            // pages api\r\n            WEBPACK_LAYERS_NAMES.apiNode,\r\n            WEBPACK_LAYERS_NAMES.apiEdge\r\n        ],\r\n        clientOnly: [\r\n            WEBPACK_LAYERS_NAMES.serverSideRendering,\r\n            WEBPACK_LAYERS_NAMES.appPagesBrowser\r\n        ],\r\n        bundled: [\r\n            WEBPACK_LAYERS_NAMES.reactServerComponents,\r\n            WEBPACK_LAYERS_NAMES.actionBrowser,\r\n            WEBPACK_LAYERS_NAMES.serverSideRendering,\r\n            WEBPACK_LAYERS_NAMES.appPagesBrowser,\r\n            WEBPACK_LAYERS_NAMES.shared,\r\n            WEBPACK_LAYERS_NAMES.instrument,\r\n            WEBPACK_LAYERS_NAMES.middleware\r\n        ],\r\n        appPages: [\r\n            // app router pages and layouts\r\n            WEBPACK_LAYERS_NAMES.reactServerComponents,\r\n            WEBPACK_LAYERS_NAMES.serverSideRendering,\r\n            WEBPACK_LAYERS_NAMES.appPagesBrowser,\r\n            WEBPACK_LAYERS_NAMES.actionBrowser\r\n        ]\r\n    }\r\n};\r\nconst WEBPACK_RESOURCE_QUERIES = {\r\n    edgeSSREntry: '__next_edge_ssr_entry__',\r\n    metadata: '__next_metadata__',\r\n    metadataRoute: '__next_metadata_route__',\r\n    metadataImageMeta: '__next_metadata_image_meta__'\r\n};\r\nexport { WEBPACK_LAYERS, WEBPACK_RESOURCE_QUERIES };\r\n\r\n//# sourceMappingURL=constants.js.map","import { HTML_LIMITED_BOT_UA_RE } from './html-bots';\r\n// Bot crawler that will spin up a headless browser and execute JS.\r\n// Only the main Googlebot search crawler executes JavaScript, not other Google crawlers.\r\n// x-ref: https://developers.google.com/search/docs/crawling-indexing/google-common-crawlers\r\n// This regex specifically matches \"Googlebot\" but NOT \"Mediapartners-Google\", \"AdsBot-Google\", etc.\r\nconst HEADLESS_BROWSER_BOT_UA_RE = /Googlebot(?!-)|Googlebot$/i;\r\nexport const HTML_LIMITED_BOT_UA_RE_STRING = HTML_LIMITED_BOT_UA_RE.source;\r\nexport { HTML_LIMITED_BOT_UA_RE };\r\nfunction isDomBotUA(userAgent) {\r\n    return HEADLESS_BROWSER_BOT_UA_RE.test(userAgent);\r\n}\r\nfunction isHtmlLimitedBotUA(userAgent) {\r\n    return HTML_LIMITED_BOT_UA_RE.test(userAgent);\r\n}\r\nexport function isBot(userAgent) {\r\n    return isDomBotUA(userAgent) || isHtmlLimitedBotUA(userAgent);\r\n}\r\nexport function getBotType(userAgent) {\r\n    if (isDomBotUA(userAgent)) {\r\n        return 'dom';\r\n    }\r\n    if (isHtmlLimitedBotUA(userAgent)) {\r\n        return 'html';\r\n    }\r\n    return undefined;\r\n}\r\n\r\n//# sourceMappingURL=is-bot.js.map","import { hexHash } from '../../hash';\r\nexport function computeCacheBustingSearchParam(prefetchHeader, segmentPrefetchHeader, stateTreeHeader, nextUrlHeader) {\r\n    if ((prefetchHeader === undefined || prefetchHeader === '0') && segmentPrefetchHeader === undefined && stateTreeHeader === undefined && nextUrlHeader === undefined) {\r\n        return '';\r\n    }\r\n    return hexHash([\r\n        prefetchHeader || '0',\r\n        segmentPrefetchHeader || '0',\r\n        stateTreeHeader || '0',\r\n        nextUrlHeader || '0'\r\n    ].join(','));\r\n}\r\n\r\n//# sourceMappingURL=cache-busting-search-param.js.map","import { CACHE_ONE_YEAR } from '../../lib/constants';\r\nexport function getCacheControlHeader({ revalidate, expire }) {\r\n    const swrHeader = typeof revalidate === 'number' && expire !== undefined && revalidate < expire ? `, stale-while-revalidate=${expire - revalidate}` : '';\r\n    if (revalidate === 0) {\r\n        return 'private, no-cache, no-store, max-age=0, must-revalidate';\r\n    } else if (typeof revalidate === 'number') {\r\n        return `s-maxage=${revalidate}${swrHeader}`;\r\n    }\r\n    return `s-maxage=${CACHE_ONE_YEAR}${swrHeader}`;\r\n}\r\n\r\n//# sourceMappingURL=cache-control.js.map","// FIXME: (wyattjoh) this is a temporary solution to allow us to pass data between bundled modules\r\nexport const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta');\r\nexport function getRequestMeta(req, key) {\r\n    const meta = req[NEXT_REQUEST_META] || {};\r\n    return typeof key === 'string' ? meta[key] : meta;\r\n}\r\n/**\r\n * Sets the request metadata.\r\n *\r\n * @param req the request to set the metadata on\r\n * @param meta the metadata to set\r\n * @returns the mutated request metadata\r\n */ export function setRequestMeta(req, meta) {\r\n    req[NEXT_REQUEST_META] = meta;\r\n    return meta;\r\n}\r\n/**\r\n * Adds a value to the request metadata.\r\n *\r\n * @param request the request to mutate\r\n * @param key the key to set\r\n * @param value the value to set\r\n * @returns the mutated request metadata\r\n */ export function addRequestMeta(request, key, value) {\r\n    const meta = getRequestMeta(request);\r\n    meta[key] = value;\r\n    return setRequestMeta(request, meta);\r\n}\r\n/**\r\n * Removes a key from the request metadata.\r\n *\r\n * @param request the request to mutate\r\n * @param key the key to remove\r\n * @returns the mutated request metadata\r\n */ export function removeRequestMeta(request, key) {\r\n    const meta = getRequestMeta(request);\r\n    delete meta[key];\r\n    return setRequestMeta(request, meta);\r\n}\r\n\r\n//# sourceMappingURL=request-meta.js.map","import { RedirectStatusCode } from '../client/components/redirect-status-code';\r\nexport const allowedStatusCodes = new Set([\r\n    301,\r\n    302,\r\n    303,\r\n    307,\r\n    308\r\n]);\r\nexport function getRedirectStatus(route) {\r\n    return route.statusCode || (route.permanent ? RedirectStatusCode.PermanentRedirect : RedirectStatusCode.TemporaryRedirect);\r\n}\r\n// for redirects we restrict matching /_next and for all routes\r\n// we add an optional trailing slash at the end for easier\r\n// configuring between trailingSlash: true/false\r\nexport function modifyRouteRegex(regex, restrictedPaths) {\r\n    if (restrictedPaths) {\r\n        regex = regex.replace(/\\^/, `^(?!${restrictedPaths.map((path)=>path.replace(/\\//g, '\\\\/')).join('|')})`);\r\n    }\r\n    regex = regex.replace(/\\$$/, '(?:\\\\/)?$');\r\n    return regex;\r\n}\r\n\r\n//# sourceMappingURL=redirect-status.js.map","import { LogSpanAllowList, NextVanillaSpanAllowlist } from './constants';\r\nimport { isThenable } from '../../../shared/lib/is-thenable';\r\nconst NEXT_OTEL_PERFORMANCE_PREFIX = process.env.NEXT_OTEL_PERFORMANCE_PREFIX;\r\nlet api;\r\n// we want to allow users to use their own version of @opentelemetry/api if they\r\n// want to, so we try to require it first, and if it fails we fall back to the\r\n// version that is bundled with Next.js\r\n// this is because @opentelemetry/api has to be synced with the version of\r\n// @opentelemetry/tracing that is used, and we don't want to force users to use\r\n// the version that is bundled with Next.js.\r\n// the API is ~stable, so this should be fine\r\nif (process.env.NEXT_RUNTIME === 'edge') {\r\n    api = require('@opentelemetry/api');\r\n} else {\r\n    try {\r\n        api = require('@opentelemetry/api');\r\n    } catch (err) {\r\n        api = require('next/dist/compiled/@opentelemetry/api');\r\n    }\r\n}\r\nconst { context, propagation, trace, SpanStatusCode, SpanKind, ROOT_CONTEXT } = api;\r\nexport class BubbledError extends Error {\r\n    constructor(bubble, result){\r\n        super(), this.bubble = bubble, this.result = result;\r\n    }\r\n}\r\nexport function isBubbledError(error) {\r\n    if (typeof error !== 'object' || error === null) return false;\r\n    return error instanceof BubbledError;\r\n}\r\nconst closeSpanWithError = (span, error)=>{\r\n    if (isBubbledError(error) && error.bubble) {\r\n        span.setAttribute('next.bubble', true);\r\n    } else {\r\n        if (error) {\r\n            span.recordException(error);\r\n            span.setAttribute('error.type', error.name);\r\n        }\r\n        span.setStatus({\r\n            code: SpanStatusCode.ERROR,\r\n            message: error == null ? void 0 : error.message\r\n        });\r\n    }\r\n    span.end();\r\n};\r\n/** we use this map to propagate attributes from nested spans to the top span */ const rootSpanAttributesStore = new Map();\r\nconst rootSpanIdKey = api.createContextKey('next.rootSpanId');\r\nlet lastSpanId = 0;\r\nconst getSpanId = ()=>lastSpanId++;\r\nconst clientTraceDataSetter = {\r\n    set (carrier, key, value) {\r\n        carrier.push({\r\n            key,\r\n            value\r\n        });\r\n    }\r\n};\r\nclass NextTracerImpl {\r\n    /**\r\n   * Returns an instance to the trace with configured name.\r\n   * Since wrap / trace can be defined in any place prior to actual trace subscriber initialization,\r\n   * This should be lazily evaluated.\r\n   */ getTracerInstance() {\r\n        return trace.getTracer('next.js', '0.0.1');\r\n    }\r\n    getContext() {\r\n        return context;\r\n    }\r\n    getTracePropagationData() {\r\n        const activeContext = context.active();\r\n        const entries = [];\r\n        propagation.inject(activeContext, entries, clientTraceDataSetter);\r\n        return entries;\r\n    }\r\n    getActiveScopeSpan() {\r\n        return trace.getSpan(context == null ? void 0 : context.active());\r\n    }\r\n    withPropagatedContext(carrier, fn, getter) {\r\n        const activeContext = context.active();\r\n        if (trace.getSpanContext(activeContext)) {\r\n            // Active span is already set, too late to propagate.\r\n            return fn();\r\n        }\r\n        const remoteContext = propagation.extract(activeContext, carrier, getter);\r\n        return context.with(remoteContext, fn);\r\n    }\r\n    trace(...args) {\r\n        const [type, fnOrOptions, fnOrEmpty] = args;\r\n        // coerce options form overload\r\n        const { fn, options } = typeof fnOrOptions === 'function' ? {\r\n            fn: fnOrOptions,\r\n            options: {}\r\n        } : {\r\n            fn: fnOrEmpty,\r\n            options: {\r\n                ...fnOrOptions\r\n            }\r\n        };\r\n        const spanName = options.spanName ?? type;\r\n        if (!NextVanillaSpanAllowlist.has(type) && process.env.NEXT_OTEL_VERBOSE !== '1' || options.hideSpan) {\r\n            return fn();\r\n        }\r\n        // Trying to get active scoped span to assign parent. If option specifies parent span manually, will try to use it.\r\n        let spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());\r\n        if (!spanContext) {\r\n            spanContext = (context == null ? void 0 : context.active()) ?? ROOT_CONTEXT;\r\n        }\r\n        // Check if there's already a root span in the store for this trace\r\n        // We are intentionally not checking whether there is an active context\r\n        // from outside of nextjs to ensure that we can provide the same level\r\n        // of telemetry when using a custom server\r\n        const existingRootSpanId = spanContext.getValue(rootSpanIdKey);\r\n        const isRootSpan = typeof existingRootSpanId !== 'number' || !rootSpanAttributesStore.has(existingRootSpanId);\r\n        const spanId = getSpanId();\r\n        options.attributes = {\r\n            'next.span_name': spanName,\r\n            'next.span_type': type,\r\n            ...options.attributes\r\n        };\r\n        return context.with(spanContext.setValue(rootSpanIdKey, spanId), ()=>this.getTracerInstance().startActiveSpan(spanName, options, (span)=>{\r\n                let startTime;\r\n                if (NEXT_OTEL_PERFORMANCE_PREFIX && type && LogSpanAllowList.has(type)) {\r\n                    startTime = 'performance' in globalThis && 'measure' in performance ? globalThis.performance.now() : undefined;\r\n                }\r\n                let cleanedUp = false;\r\n                const onCleanup = ()=>{\r\n                    if (cleanedUp) return;\r\n                    cleanedUp = true;\r\n                    rootSpanAttributesStore.delete(spanId);\r\n                    if (startTime) {\r\n                        performance.measure(`${NEXT_OTEL_PERFORMANCE_PREFIX}:next-${(type.split('.').pop() || '').replace(/[A-Z]/g, (match)=>'-' + match.toLowerCase())}`, {\r\n                            start: startTime,\r\n                            end: performance.now()\r\n                        });\r\n                    }\r\n                };\r\n                if (isRootSpan) {\r\n                    rootSpanAttributesStore.set(spanId, new Map(Object.entries(options.attributes ?? {})));\r\n                }\r\n                if (fn.length > 1) {\r\n                    try {\r\n                        return fn(span, (err)=>closeSpanWithError(span, err));\r\n                    } catch (err) {\r\n                        closeSpanWithError(span, err);\r\n                        throw err;\r\n                    } finally{\r\n                        onCleanup();\r\n                    }\r\n                }\r\n                try {\r\n                    const result = fn(span);\r\n                    if (isThenable(result)) {\r\n                        // If there's error make sure it throws\r\n                        return result.then((res)=>{\r\n                            span.end();\r\n                            // Need to pass down the promise result,\r\n                            // it could be react stream response with error { error, stream }\r\n                            return res;\r\n                        }).catch((err)=>{\r\n                            closeSpanWithError(span, err);\r\n                            throw err;\r\n                        }).finally(onCleanup);\r\n                    } else {\r\n                        span.end();\r\n                        onCleanup();\r\n                    }\r\n                    return result;\r\n                } catch (err) {\r\n                    closeSpanWithError(span, err);\r\n                    onCleanup();\r\n                    throw err;\r\n                }\r\n            }));\r\n    }\r\n    wrap(...args) {\r\n        const tracer = this;\r\n        const [name, options, fn] = args.length === 3 ? args : [\r\n            args[0],\r\n            {},\r\n            args[1]\r\n        ];\r\n        if (!NextVanillaSpanAllowlist.has(name) && process.env.NEXT_OTEL_VERBOSE !== '1') {\r\n            return fn;\r\n        }\r\n        return function() {\r\n            let optionsObj = options;\r\n            if (typeof optionsObj === 'function' && typeof fn === 'function') {\r\n                optionsObj = optionsObj.apply(this, arguments);\r\n            }\r\n            const lastArgId = arguments.length - 1;\r\n            const cb = arguments[lastArgId];\r\n            if (typeof cb === 'function') {\r\n                const scopeBoundCb = tracer.getContext().bind(context.active(), cb);\r\n                return tracer.trace(name, optionsObj, (_span, done)=>{\r\n                    arguments[lastArgId] = function(err) {\r\n                        done == null ? void 0 : done(err);\r\n                        return scopeBoundCb.apply(this, arguments);\r\n                    };\r\n                    return fn.apply(this, arguments);\r\n                });\r\n            } else {\r\n                return tracer.trace(name, optionsObj, ()=>fn.apply(this, arguments));\r\n            }\r\n        };\r\n    }\r\n    startSpan(...args) {\r\n        const [type, options] = args;\r\n        const spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());\r\n        return this.getTracerInstance().startSpan(type, options, spanContext);\r\n    }\r\n    getSpanContext(parentSpan) {\r\n        const spanContext = parentSpan ? trace.setSpan(context.active(), parentSpan) : undefined;\r\n        return spanContext;\r\n    }\r\n    getRootSpanAttributes() {\r\n        const spanId = context.active().getValue(rootSpanIdKey);\r\n        return rootSpanAttributesStore.get(spanId);\r\n    }\r\n    setRootSpanAttribute(key, value) {\r\n        const spanId = context.active().getValue(rootSpanIdKey);\r\n        const attributes = rootSpanAttributesStore.get(spanId);\r\n        if (attributes && !attributes.has(key)) {\r\n            attributes.set(key, value);\r\n        }\r\n    }\r\n}\r\nconst getTracer = (()=>{\r\n    const tracer = new NextTracerImpl();\r\n    return ()=>tracer;\r\n})();\r\nexport { getTracer, SpanStatusCode, SpanKind };\r\n\r\n//# sourceMappingURL=tracer.js.map","import { isResSent } from '../shared/lib/utils';\r\nimport { generateETag } from './lib/etag';\r\nimport fresh from 'next/dist/compiled/fresh';\r\nimport { getCacheControlHeader } from './lib/cache-control';\r\nimport { HTML_CONTENT_TYPE_HEADER } from '../lib/constants';\r\nexport function sendEtagResponse(req, res, etag) {\r\n    if (etag) {\r\n        /**\r\n     * The server generating a 304 response MUST generate any of the\r\n     * following header fields that would have been sent in a 200 (OK)\r\n     * response to the same request: Cache-Control, Content-Location, Date,\r\n     * ETag, Expires, and Vary. https://tools.ietf.org/html/rfc7232#section-4.1\r\n     */ res.setHeader('ETag', etag);\r\n    }\r\n    if (fresh(req.headers, {\r\n        etag\r\n    })) {\r\n        res.statusCode = 304;\r\n        res.end();\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexport async function sendRenderResult({ req, res, result, generateEtags, poweredByHeader, cacheControl }) {\r\n    if (isResSent(res)) {\r\n        return;\r\n    }\r\n    if (poweredByHeader && result.contentType === HTML_CONTENT_TYPE_HEADER) {\r\n        res.setHeader('X-Powered-By', 'Next.js');\r\n    }\r\n    // If cache control is already set on the response we don't\r\n    // override it to allow users to customize it via next.config\r\n    if (cacheControl && !res.getHeader('Cache-Control')) {\r\n        res.setHeader('Cache-Control', getCacheControlHeader(cacheControl));\r\n    }\r\n    const payload = result.isDynamic ? null : result.toUnchunkedString();\r\n    if (generateEtags && payload !== null) {\r\n        const etag = generateETag(payload);\r\n        if (sendEtagResponse(req, res, etag)) {\r\n            return;\r\n        }\r\n    }\r\n    if (!res.getHeader('Content-Type') && result.contentType) {\r\n        res.setHeader('Content-Type', result.contentType);\r\n    }\r\n    if (payload) {\r\n        res.setHeader('Content-Length', Buffer.byteLength(payload));\r\n    }\r\n    if (req.method === 'HEAD') {\r\n        res.end(null);\r\n        return;\r\n    }\r\n    if (payload !== null) {\r\n        res.end(payload);\r\n        return;\r\n    }\r\n    // Pipe the render result to the response after we get a writer for it.\r\n    await result.pipeToNodeResponse(res);\r\n}\r\n\r\n//# sourceMappingURL=send-payload.js.map","/**\r\n * Interop between \"export default\" and \"module.exports\".\r\n */ export function interopDefault(mod) {\r\n    return mod.default || mod;\r\n}\r\n\r\n//# sourceMappingURL=interop-default.js.map","/**\r\n * Find the starting index of Uint8Array `b` within Uint8Array `a`.\r\n */ export function indexOfUint8Array(a, b) {\r\n    if (b.length === 0) return 0;\r\n    if (a.length === 0 || b.length > a.length) return -1;\r\n    // start iterating through `a`\r\n    for(let i = 0; i <= a.length - b.length; i++){\r\n        let completeMatch = true;\r\n        // from index `i`, iterate through `b` and check for mismatch\r\n        for(let j = 0; j < b.length; j++){\r\n            // if the values do not match, then this isn't a complete match, exit `b` iteration early and iterate to next index of `a`.\r\n            if (a[i + j] !== b[j]) {\r\n                completeMatch = false;\r\n                break;\r\n            }\r\n        }\r\n        if (completeMatch) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n/**\r\n * Check if two Uint8Arrays are strictly equivalent.\r\n */ export function isEquivalentUint8Arrays(a, b) {\r\n    if (a.length !== b.length) return false;\r\n    for(let i = 0; i < a.length; i++){\r\n        if (a[i] !== b[i]) return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Remove Uint8Array `b` from Uint8Array `a`.\r\n *\r\n * If `b` is not in `a`, `a` is returned unchanged.\r\n *\r\n * Otherwise, the function returns a new Uint8Array instance with size `a.length - b.length`\r\n */ export function removeFromUint8Array(a, b) {\r\n    const tagIndex = indexOfUint8Array(a, b);\r\n    if (tagIndex === 0) return a.subarray(b.length);\r\n    if (tagIndex > -1) {\r\n        const removed = new Uint8Array(a.length - b.length);\r\n        removed.set(a.slice(0, tagIndex));\r\n        removed.set(a.slice(tagIndex + b.length), tagIndex);\r\n        return removed;\r\n    } else {\r\n        return a;\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=uint8array-helpers.js.map","import { normalizeLocalePath } from '../../i18n/normalize-locale-path';\r\nimport { removePathPrefix } from './remove-path-prefix';\r\nimport { pathHasPrefix } from './path-has-prefix';\r\nexport function getNextPathnameInfo(pathname, options) {\r\n    const { basePath, i18n, trailingSlash } = options.nextConfig ?? {};\r\n    const info = {\r\n        pathname,\r\n        trailingSlash: pathname !== '/' ? pathname.endsWith('/') : trailingSlash\r\n    };\r\n    if (basePath && pathHasPrefix(info.pathname, basePath)) {\r\n        info.pathname = removePathPrefix(info.pathname, basePath);\r\n        info.basePath = basePath;\r\n    }\r\n    let pathnameNoDataPrefix = info.pathname;\r\n    if (info.pathname.startsWith('/_next/data/') && info.pathname.endsWith('.json')) {\r\n        const paths = info.pathname.replace(/^\\/_next\\/data\\//, '').replace(/\\.json$/, '').split('/');\r\n        const buildId = paths[0];\r\n        info.buildId = buildId;\r\n        pathnameNoDataPrefix = paths[1] !== 'index' ? `/${paths.slice(1).join('/')}` : '/';\r\n        // update pathname with normalized if enabled although\r\n        // we use normalized to populate locale info still\r\n        if (options.parseData === true) {\r\n            info.pathname = pathnameNoDataPrefix;\r\n        }\r\n    }\r\n    // If provided, use the locale route normalizer to detect the locale instead\r\n    // of the function below.\r\n    if (i18n) {\r\n        let result = options.i18nProvider ? options.i18nProvider.analyze(info.pathname) : normalizeLocalePath(info.pathname, i18n.locales);\r\n        info.locale = result.detectedLocale;\r\n        info.pathname = result.pathname ?? info.pathname;\r\n        if (!result.detectedLocale && info.buildId) {\r\n            result = options.i18nProvider ? options.i18nProvider.analyze(pathnameNoDataPrefix) : normalizeLocalePath(pathnameNoDataPrefix, i18n.locales);\r\n            if (result.detectedLocale) {\r\n                info.locale = result.detectedLocale;\r\n            }\r\n        }\r\n    }\r\n    return info;\r\n}\r\n\r\n//# sourceMappingURL=get-next-pathname-info.js.map","/**\r\n * Web vitals provided to _app.reportWebVitals by Core Web Vitals plugin developed by Google Chrome team.\r\n * https://nextjs.org/blog/next-9-4#integrated-web-vitals-reporting\r\n */ export const WEB_VITALS = [\r\n    'CLS',\r\n    'FCP',\r\n    'FID',\r\n    'INP',\r\n    'LCP',\r\n    'TTFB'\r\n];\r\n/**\r\n * Utils\r\n */ export function execOnce(fn) {\r\n    let used = false;\r\n    let result;\r\n    return (...args)=>{\r\n        if (!used) {\r\n            used = true;\r\n            result = fn(...args);\r\n        }\r\n        return result;\r\n    };\r\n}\r\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\r\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\r\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\r\nexport const isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\r\nexport function getLocationOrigin() {\r\n    const { protocol, hostname, port } = window.location;\r\n    return `${protocol}//${hostname}${port ? ':' + port : ''}`;\r\n}\r\nexport function getURL() {\r\n    const { href } = window.location;\r\n    const origin = getLocationOrigin();\r\n    return href.substring(origin.length);\r\n}\r\nexport function getDisplayName(Component) {\r\n    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';\r\n}\r\nexport function isResSent(res) {\r\n    return res.finished || res.headersSent;\r\n}\r\nexport function normalizeRepeatedSlashes(url) {\r\n    const urlParts = url.split('?');\r\n    const urlNoQuery = urlParts[0];\r\n    return urlNoQuery// first we replace any non-encoded backslashes with forward\r\n    // then normalize repeated forward slashes\r\n    .replace(/\\\\/g, '/').replace(/\\/\\/+/g, '/') + (urlParts[1] ? `?${urlParts.slice(1).join('?')}` : '');\r\n}\r\nexport async function loadGetInitialProps(App, ctx) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (App.prototype?.getInitialProps) {\r\n            const message = `\"${getDisplayName(App)}.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`;\r\n            throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\r\n                value: \"E394\",\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n        }\r\n    }\r\n    // when called from _app `ctx` is nested in `ctx`\r\n    const res = ctx.res || ctx.ctx && ctx.ctx.res;\r\n    if (!App.getInitialProps) {\r\n        if (ctx.ctx && ctx.Component) {\r\n            // @ts-ignore pageProps default\r\n            return {\r\n                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)\r\n            };\r\n        }\r\n        return {};\r\n    }\r\n    const props = await App.getInitialProps(ctx);\r\n    if (res && isResSent(res)) {\r\n        return props;\r\n    }\r\n    if (!props) {\r\n        const message = `\"${getDisplayName(App)}.getInitialProps()\" should resolve to an object. But found \"${props}\" instead.`;\r\n        throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E394\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (Object.keys(props).length === 0 && !ctx.ctx) {\r\n            console.warn(`${getDisplayName(App)} returned an empty object from \\`getInitialProps\\`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`);\r\n        }\r\n    }\r\n    return props;\r\n}\r\nexport const SP = typeof performance !== 'undefined';\r\nexport const ST = SP && [\r\n    'mark',\r\n    'measure',\r\n    'getEntriesByName'\r\n].every((method)=>typeof performance[method] === 'function');\r\nexport class DecodeError extends Error {\r\n}\r\nexport class NormalizeError extends Error {\r\n}\r\nexport class PageNotFoundError extends Error {\r\n    constructor(page){\r\n        super();\r\n        this.code = 'ENOENT';\r\n        this.name = 'PageNotFoundError';\r\n        this.message = `Cannot find module for page: ${page}`;\r\n    }\r\n}\r\nexport class MissingStaticPage extends Error {\r\n    constructor(page, message){\r\n        super();\r\n        this.message = `Failed to load static file for page: ${page} ${message}`;\r\n    }\r\n}\r\nexport class MiddlewareNotFoundError extends Error {\r\n    constructor(){\r\n        super();\r\n        this.code = 'ENOENT';\r\n        this.message = `Cannot find the middleware module`;\r\n    }\r\n}\r\nexport function stringifyError(error) {\r\n    return JSON.stringify({\r\n        message: error.message,\r\n        stack: error.stack\r\n    });\r\n}\r\n\r\n//# sourceMappingURL=utils.js.map","import { pathHasPrefix } from '../router/utils/path-has-prefix';\r\n/**\r\n * strip _next/data/<build-id>/ prefix and .json suffix\r\n */ export function normalizeDataPath(pathname) {\r\n    if (!pathHasPrefix(pathname || '/', '/_next/data')) {\r\n        return pathname;\r\n    }\r\n    pathname = pathname.replace(/\\/_next\\/data\\/[^/]{1,}/, '').replace(/\\.json$/, '');\r\n    if (pathname === '/index') {\r\n        return '/';\r\n    }\r\n    return pathname;\r\n}\r\n\r\n//# sourceMappingURL=normalize-data-path.js.map","import { chainStreams, streamFromBuffer, streamFromString, streamToString } from './stream-utils/node-web-streams-helper';\r\nimport { isAbortError, pipeToNodeResponse } from './pipe-readable';\r\nimport { InvariantError } from '../shared/lib/invariant-error';\r\nexport default class RenderResult {\r\n    static #_ = /**\r\n   * A render result that represents an empty response. This is used to\r\n   * represent a response that was not found or was already sent.\r\n   */ this.EMPTY = new RenderResult(null, {\r\n        metadata: {},\r\n        contentType: null\r\n    });\r\n    /**\r\n   * Creates a new RenderResult instance from a static response.\r\n   *\r\n   * @param value the static response value\r\n   * @param contentType the content type of the response\r\n   * @returns a new RenderResult instance\r\n   */ static fromStatic(value, contentType) {\r\n        return new RenderResult(value, {\r\n            metadata: {},\r\n            contentType\r\n        });\r\n    }\r\n    constructor(response, { contentType, waitUntil, metadata }){\r\n        this.response = response;\r\n        this.contentType = contentType;\r\n        this.metadata = metadata;\r\n        this.waitUntil = waitUntil;\r\n    }\r\n    assignMetadata(metadata) {\r\n        Object.assign(this.metadata, metadata);\r\n    }\r\n    /**\r\n   * Returns true if the response is null. It can be null if the response was\r\n   * not found or was already sent.\r\n   */ get isNull() {\r\n        return this.response === null;\r\n    }\r\n    /**\r\n   * Returns false if the response is a string. It can be a string if the page\r\n   * was prerendered. If it's not, then it was generated dynamically.\r\n   */ get isDynamic() {\r\n        return typeof this.response !== 'string';\r\n    }\r\n    toUnchunkedString(stream = false) {\r\n        if (this.response === null) {\r\n            // If the response is null, return an empty string. This behavior is\r\n            // intentional as we're now providing the `RenderResult.EMPTY` value.\r\n            return '';\r\n        }\r\n        if (typeof this.response !== 'string') {\r\n            if (!stream) {\r\n                throw Object.defineProperty(new InvariantError('dynamic responses cannot be unchunked. This is a bug in Next.js'), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E732\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            }\r\n            return streamToString(this.readable);\r\n        }\r\n        return this.response;\r\n    }\r\n    /**\r\n   * Returns a readable stream of the response.\r\n   */ get readable() {\r\n        if (this.response === null) {\r\n            // If the response is null, return an empty stream. This behavior is\r\n            // intentional as we're now providing the `RenderResult.EMPTY` value.\r\n            return new ReadableStream({\r\n                start (controller) {\r\n                    controller.close();\r\n                }\r\n            });\r\n        }\r\n        if (typeof this.response === 'string') {\r\n            return streamFromString(this.response);\r\n        }\r\n        if (Buffer.isBuffer(this.response)) {\r\n            return streamFromBuffer(this.response);\r\n        }\r\n        // If the response is an array of streams, then chain them together.\r\n        if (Array.isArray(this.response)) {\r\n            return chainStreams(...this.response);\r\n        }\r\n        return this.response;\r\n    }\r\n    /**\r\n   * Coerces the response to an array of streams. This will convert the response\r\n   * to an array of streams if it is not already one.\r\n   *\r\n   * @returns An array of streams\r\n   */ coerce() {\r\n        if (this.response === null) {\r\n            // If the response is null, return an empty stream. This behavior is\r\n            // intentional as we're now providing the `RenderResult.EMPTY` value.\r\n            return [];\r\n        }\r\n        if (typeof this.response === 'string') {\r\n            return [\r\n                streamFromString(this.response)\r\n            ];\r\n        } else if (Array.isArray(this.response)) {\r\n            return this.response;\r\n        } else if (Buffer.isBuffer(this.response)) {\r\n            return [\r\n                streamFromBuffer(this.response)\r\n            ];\r\n        } else {\r\n            return [\r\n                this.response\r\n            ];\r\n        }\r\n    }\r\n    /**\r\n   * Unshifts a new stream to the response. This will convert the response to an\r\n   * array of streams if it is not already one and will add the new stream to\r\n   * the start of the array. When this response is piped, all of the streams\r\n   * will be piped one after the other.\r\n   *\r\n   * @param readable The new stream to unshift\r\n   */ unshift(readable) {\r\n        // Coerce the response to an array of streams.\r\n        this.response = this.coerce();\r\n        // Add the new stream to the start of the array.\r\n        this.response.unshift(readable);\r\n    }\r\n    /**\r\n   * Chains a new stream to the response. This will convert the response to an\r\n   * array of streams if it is not already one and will add the new stream to\r\n   * the end. When this response is piped, all of the streams will be piped\r\n   * one after the other.\r\n   *\r\n   * @param readable The new stream to chain\r\n   */ push(readable) {\r\n        // Coerce the response to an array of streams.\r\n        this.response = this.coerce();\r\n        // Add the new stream to the end of the array.\r\n        this.response.push(readable);\r\n    }\r\n    /**\r\n   * Pipes the response to a writable stream. This will close/cancel the\r\n   * writable stream if an error is encountered. If this doesn't throw, then\r\n   * the writable stream will be closed or aborted.\r\n   *\r\n   * @param writable Writable stream to pipe the response to\r\n   */ async pipeTo(writable) {\r\n        try {\r\n            await this.readable.pipeTo(writable, {\r\n                // We want to close the writable stream ourselves so that we can wait\r\n                // for the waitUntil promise to resolve before closing it. If an error\r\n                // is encountered, we'll abort the writable stream if we swallowed the\r\n                // error.\r\n                preventClose: true\r\n            });\r\n            // If there is a waitUntil promise, wait for it to resolve before\r\n            // closing the writable stream.\r\n            if (this.waitUntil) await this.waitUntil;\r\n            // Close the writable stream.\r\n            await writable.close();\r\n        } catch (err) {\r\n            // If this is an abort error, we should abort the writable stream (as we\r\n            // took ownership of it when we started piping). We don't need to re-throw\r\n            // because we handled the error.\r\n            if (isAbortError(err)) {\r\n                // Abort the writable stream if an error is encountered.\r\n                await writable.abort(err);\r\n                return;\r\n            }\r\n            // We're not aborting the writer here as when this method throws it's not\r\n            // clear as to how so the caller should assume it's their responsibility\r\n            // to clean up the writer.\r\n            throw err;\r\n        }\r\n    }\r\n    /**\r\n   * Pipes the response to a node response. This will close/cancel the node\r\n   * response if an error is encountered.\r\n   *\r\n   * @param res\r\n   */ async pipeToNodeResponse(res) {\r\n        await pipeToNodeResponse(this.readable, res, this.waitUntil);\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=render-result.js.map","import { detectDomainLocale } from '../../shared/lib/i18n/detect-domain-locale';\r\nimport { formatNextPathnameInfo } from '../../shared/lib/router/utils/format-next-pathname-info';\r\nimport { getHostname } from '../../shared/lib/get-hostname';\r\nimport { getNextPathnameInfo } from '../../shared/lib/router/utils/get-next-pathname-info';\r\nconst REGEX_LOCALHOST_HOSTNAME = /(?!^https?:\\/\\/)(127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}|\\[::1\\]|localhost)/;\r\nfunction parseURL(url, base) {\r\n    return new URL(String(url).replace(REGEX_LOCALHOST_HOSTNAME, 'localhost'), base && String(base).replace(REGEX_LOCALHOST_HOSTNAME, 'localhost'));\r\n}\r\nconst Internal = Symbol('NextURLInternal');\r\nexport class NextURL {\r\n    constructor(input, baseOrOpts, opts){\r\n        let base;\r\n        let options;\r\n        if (typeof baseOrOpts === 'object' && 'pathname' in baseOrOpts || typeof baseOrOpts === 'string') {\r\n            base = baseOrOpts;\r\n            options = opts || {};\r\n        } else {\r\n            options = opts || baseOrOpts || {};\r\n        }\r\n        this[Internal] = {\r\n            url: parseURL(input, base ?? options.base),\r\n            options: options,\r\n            basePath: ''\r\n        };\r\n        this.analyze();\r\n    }\r\n    analyze() {\r\n        var _this_Internal_options_nextConfig_i18n, _this_Internal_options_nextConfig, _this_Internal_domainLocale, _this_Internal_options_nextConfig_i18n1, _this_Internal_options_nextConfig1;\r\n        const info = getNextPathnameInfo(this[Internal].url.pathname, {\r\n            nextConfig: this[Internal].options.nextConfig,\r\n            parseData: !process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE,\r\n            i18nProvider: this[Internal].options.i18nProvider\r\n        });\r\n        const hostname = getHostname(this[Internal].url, this[Internal].options.headers);\r\n        this[Internal].domainLocale = this[Internal].options.i18nProvider ? this[Internal].options.i18nProvider.detectDomainLocale(hostname) : detectDomainLocale((_this_Internal_options_nextConfig = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n = _this_Internal_options_nextConfig.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n.domains, hostname);\r\n        const defaultLocale = ((_this_Internal_domainLocale = this[Internal].domainLocale) == null ? void 0 : _this_Internal_domainLocale.defaultLocale) || ((_this_Internal_options_nextConfig1 = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n1 = _this_Internal_options_nextConfig1.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n1.defaultLocale);\r\n        this[Internal].url.pathname = info.pathname;\r\n        this[Internal].defaultLocale = defaultLocale;\r\n        this[Internal].basePath = info.basePath ?? '';\r\n        this[Internal].buildId = info.buildId;\r\n        this[Internal].locale = info.locale ?? defaultLocale;\r\n        this[Internal].trailingSlash = info.trailingSlash;\r\n    }\r\n    formatPathname() {\r\n        return formatNextPathnameInfo({\r\n            basePath: this[Internal].basePath,\r\n            buildId: this[Internal].buildId,\r\n            defaultLocale: !this[Internal].options.forceLocale ? this[Internal].defaultLocale : undefined,\r\n            locale: this[Internal].locale,\r\n            pathname: this[Internal].url.pathname,\r\n            trailingSlash: this[Internal].trailingSlash\r\n        });\r\n    }\r\n    formatSearch() {\r\n        return this[Internal].url.search;\r\n    }\r\n    get buildId() {\r\n        return this[Internal].buildId;\r\n    }\r\n    set buildId(buildId) {\r\n        this[Internal].buildId = buildId;\r\n    }\r\n    get locale() {\r\n        return this[Internal].locale ?? '';\r\n    }\r\n    set locale(locale) {\r\n        var _this_Internal_options_nextConfig_i18n, _this_Internal_options_nextConfig;\r\n        if (!this[Internal].locale || !((_this_Internal_options_nextConfig = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n = _this_Internal_options_nextConfig.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n.locales.includes(locale))) {\r\n            throw Object.defineProperty(new TypeError(`The NextURL configuration includes no locale \"${locale}\"`), \"__NEXT_ERROR_CODE\", {\r\n                value: \"E597\",\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n        }\r\n        this[Internal].locale = locale;\r\n    }\r\n    get defaultLocale() {\r\n        return this[Internal].defaultLocale;\r\n    }\r\n    get domainLocale() {\r\n        return this[Internal].domainLocale;\r\n    }\r\n    get searchParams() {\r\n        return this[Internal].url.searchParams;\r\n    }\r\n    get host() {\r\n        return this[Internal].url.host;\r\n    }\r\n    set host(value) {\r\n        this[Internal].url.host = value;\r\n    }\r\n    get hostname() {\r\n        return this[Internal].url.hostname;\r\n    }\r\n    set hostname(value) {\r\n        this[Internal].url.hostname = value;\r\n    }\r\n    get port() {\r\n        return this[Internal].url.port;\r\n    }\r\n    set port(value) {\r\n        this[Internal].url.port = value;\r\n    }\r\n    get protocol() {\r\n        return this[Internal].url.protocol;\r\n    }\r\n    set protocol(value) {\r\n        this[Internal].url.protocol = value;\r\n    }\r\n    get href() {\r\n        const pathname = this.formatPathname();\r\n        const search = this.formatSearch();\r\n        return `${this.protocol}//${this.host}${pathname}${search}${this.hash}`;\r\n    }\r\n    set href(url) {\r\n        this[Internal].url = parseURL(url);\r\n        this.analyze();\r\n    }\r\n    get origin() {\r\n        return this[Internal].url.origin;\r\n    }\r\n    get pathname() {\r\n        return this[Internal].url.pathname;\r\n    }\r\n    set pathname(value) {\r\n        this[Internal].url.pathname = value;\r\n    }\r\n    get hash() {\r\n        return this[Internal].url.hash;\r\n    }\r\n    set hash(value) {\r\n        this[Internal].url.hash = value;\r\n    }\r\n    get search() {\r\n        return this[Internal].url.search;\r\n    }\r\n    set search(value) {\r\n        this[Internal].url.search = value;\r\n    }\r\n    get password() {\r\n        return this[Internal].url.password;\r\n    }\r\n    set password(value) {\r\n        this[Internal].url.password = value;\r\n    }\r\n    get username() {\r\n        return this[Internal].url.username;\r\n    }\r\n    set username(value) {\r\n        this[Internal].url.username = value;\r\n    }\r\n    get basePath() {\r\n        return this[Internal].basePath;\r\n    }\r\n    set basePath(value) {\r\n        this[Internal].basePath = value.startsWith('/') ? value : `/${value}`;\r\n    }\r\n    toString() {\r\n        return this.href;\r\n    }\r\n    toJSON() {\r\n        return this.href;\r\n    }\r\n    [Symbol.for('edge-runtime.inspect.custom')]() {\r\n        return {\r\n            href: this.href,\r\n            origin: this.origin,\r\n            protocol: this.protocol,\r\n            username: this.username,\r\n            password: this.password,\r\n            host: this.host,\r\n            hostname: this.hostname,\r\n            port: this.port,\r\n            pathname: this.pathname,\r\n            search: this.search,\r\n            searchParams: this.searchParams,\r\n            hash: this.hash\r\n        };\r\n    }\r\n    clone() {\r\n        return new NextURL(String(this), this[Internal].options);\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=next-url.js.map","import { removeTrailingSlash } from './remove-trailing-slash';\r\nimport { addPathPrefix } from './add-path-prefix';\r\nimport { addPathSuffix } from './add-path-suffix';\r\nimport { addLocale } from './add-locale';\r\nexport function formatNextPathnameInfo(info) {\r\n    let pathname = addLocale(info.pathname, info.locale, info.buildId ? undefined : info.defaultLocale, info.ignorePrefix);\r\n    if (info.buildId || !info.trailingSlash) {\r\n        pathname = removeTrailingSlash(pathname);\r\n    }\r\n    if (info.buildId) {\r\n        pathname = addPathSuffix(addPathPrefix(pathname, `/_next/data/${info.buildId}`), info.pathname === '/' ? 'index.json' : '.json');\r\n    }\r\n    pathname = addPathPrefix(pathname, info.basePath);\r\n    return !info.buildId && info.trailingSlash ? !pathname.endsWith('/') ? addPathSuffix(pathname, '/') : pathname : removeTrailingSlash(pathname);\r\n}\r\n\r\n//# sourceMappingURL=format-next-pathname-info.js.map","import { NextURL } from '../next-url';\r\nimport { toNodeOutgoingHttpHeaders, validateURL } from '../utils';\r\nimport { RemovedUAError, RemovedPageError } from '../error';\r\nimport { RequestCookies } from './cookies';\r\nexport const INTERNALS = Symbol('internal request');\r\n/**\r\n * This class extends the [Web `Request` API](https://developer.mozilla.org/docs/Web/API/Request) with additional convenience methods.\r\n *\r\n * Read more: [Next.js Docs: `NextRequest`](https://nextjs.org/docs/app/api-reference/functions/next-request)\r\n */ export class NextRequest extends Request {\r\n    constructor(input, init = {}){\r\n        const url = typeof input !== 'string' && 'url' in input ? input.url : String(input);\r\n        validateURL(url);\r\n        // node Request instance requires duplex option when a body\r\n        // is present or it errors, we don't handle this for\r\n        // Request being passed in since it would have already\r\n        // errored if this wasn't configured\r\n        if (process.env.NEXT_RUNTIME !== 'edge') {\r\n            if (init.body && init.duplex !== 'half') {\r\n                init.duplex = 'half';\r\n            }\r\n        }\r\n        if (input instanceof Request) super(input, init);\r\n        else super(url, init);\r\n        const nextUrl = new NextURL(url, {\r\n            headers: toNodeOutgoingHttpHeaders(this.headers),\r\n            nextConfig: init.nextConfig\r\n        });\r\n        this[INTERNALS] = {\r\n            cookies: new RequestCookies(this.headers),\r\n            nextUrl,\r\n            url: process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE ? url : nextUrl.toString()\r\n        };\r\n    }\r\n    [Symbol.for('edge-runtime.inspect.custom')]() {\r\n        return {\r\n            cookies: this.cookies,\r\n            nextUrl: this.nextUrl,\r\n            url: this.url,\r\n            // rest of props come from Request\r\n            bodyUsed: this.bodyUsed,\r\n            cache: this.cache,\r\n            credentials: this.credentials,\r\n            destination: this.destination,\r\n            headers: Object.fromEntries(this.headers),\r\n            integrity: this.integrity,\r\n            keepalive: this.keepalive,\r\n            method: this.method,\r\n            mode: this.mode,\r\n            redirect: this.redirect,\r\n            referrer: this.referrer,\r\n            referrerPolicy: this.referrerPolicy,\r\n            signal: this.signal\r\n        };\r\n    }\r\n    get cookies() {\r\n        return this[INTERNALS].cookies;\r\n    }\r\n    get nextUrl() {\r\n        return this[INTERNALS].nextUrl;\r\n    }\r\n    /**\r\n   * @deprecated\r\n   * `page` has been deprecated in favour of `URLPattern`.\r\n   * Read more: https://nextjs.org/docs/messages/middleware-request-page\r\n   */ get page() {\r\n        throw new RemovedPageError();\r\n    }\r\n    /**\r\n   * @deprecated\r\n   * `ua` has been removed in favour of \\`userAgent\\` function.\r\n   * Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent\r\n   */ get ua() {\r\n        throw new RemovedUAError();\r\n    }\r\n    get url() {\r\n        return this[INTERNALS].url;\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=request.js.map","import { getRequestMeta } from '../../../request-meta';\r\nimport { fromNodeOutgoingHttpHeaders } from '../../utils';\r\nimport { NextRequest } from '../request';\r\nimport { isNodeNextRequest, isWebNextRequest } from '../../../base-http/helpers';\r\nexport const ResponseAbortedName = 'ResponseAborted';\r\nexport class ResponseAborted extends Error {\r\n    constructor(...args){\r\n        super(...args), this.name = ResponseAbortedName;\r\n    }\r\n}\r\n/**\r\n * Creates an AbortController tied to the closing of a ServerResponse (or other\r\n * appropriate Writable).\r\n *\r\n * If the `close` event is fired before the `finish` event, then we'll send the\r\n * `abort` signal.\r\n */ export function createAbortController(response) {\r\n    const controller = new AbortController();\r\n    // If `finish` fires first, then `res.end()` has been called and the close is\r\n    // just us finishing the stream on our side. If `close` fires first, then we\r\n    // know the client disconnected before we finished.\r\n    response.once('close', ()=>{\r\n        if (response.writableFinished) return;\r\n        controller.abort(new ResponseAborted());\r\n    });\r\n    return controller;\r\n}\r\n/**\r\n * Creates an AbortSignal tied to the closing of a ServerResponse (or other\r\n * appropriate Writable).\r\n *\r\n * This cannot be done with the request (IncomingMessage or Readable) because\r\n * the `abort` event will not fire if to data has been fully read (because that\r\n * will \"close\" the readable stream and nothing fires after that).\r\n */ export function signalFromNodeResponse(response) {\r\n    const { errored, destroyed } = response;\r\n    if (errored || destroyed) {\r\n        return AbortSignal.abort(errored ?? new ResponseAborted());\r\n    }\r\n    const { signal } = createAbortController(response);\r\n    return signal;\r\n}\r\nexport class NextRequestAdapter {\r\n    static fromBaseNextRequest(request, signal) {\r\n        if (// The type check here ensures that `req` is correctly typed, and the\r\n        // environment variable check provides dead code elimination.\r\n        process.env.NEXT_RUNTIME === 'edge' && isWebNextRequest(request)) {\r\n            return NextRequestAdapter.fromWebNextRequest(request);\r\n        } else if (// The type check here ensures that `req` is correctly typed, and the\r\n        // environment variable check provides dead code elimination.\r\n        process.env.NEXT_RUNTIME !== 'edge' && isNodeNextRequest(request)) {\r\n            return NextRequestAdapter.fromNodeNextRequest(request, signal);\r\n        } else {\r\n            throw Object.defineProperty(new Error('Invariant: Unsupported NextRequest type'), \"__NEXT_ERROR_CODE\", {\r\n                value: \"E345\",\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n        }\r\n    }\r\n    static fromNodeNextRequest(request, signal) {\r\n        // HEAD and GET requests can not have a body.\r\n        let body = null;\r\n        if (request.method !== 'GET' && request.method !== 'HEAD' && request.body) {\r\n            // @ts-expect-error - this is handled by undici, when streams/web land use it instead\r\n            body = request.body;\r\n        }\r\n        let url;\r\n        if (request.url.startsWith('http')) {\r\n            url = new URL(request.url);\r\n        } else {\r\n            // Grab the full URL from the request metadata.\r\n            const base = getRequestMeta(request, 'initURL');\r\n            if (!base || !base.startsWith('http')) {\r\n                // Because the URL construction relies on the fact that the URL provided\r\n                // is absolute, we need to provide a base URL. We can't use the request\r\n                // URL because it's relative, so we use a dummy URL instead.\r\n                url = new URL(request.url, 'http://n');\r\n            } else {\r\n                url = new URL(request.url, base);\r\n            }\r\n        }\r\n        return new NextRequest(url, {\r\n            method: request.method,\r\n            headers: fromNodeOutgoingHttpHeaders(request.headers),\r\n            duplex: 'half',\r\n            signal,\r\n            // geo\r\n            // ip\r\n            // nextConfig\r\n            // body can not be passed if request was aborted\r\n            // or we get a Request body was disturbed error\r\n            ...signal.aborted ? {} : {\r\n                body\r\n            }\r\n        });\r\n    }\r\n    static fromWebNextRequest(request) {\r\n        // HEAD and GET requests can not have a body.\r\n        let body = null;\r\n        if (request.method !== 'GET' && request.method !== 'HEAD') {\r\n            body = request.body;\r\n        }\r\n        return new NextRequest(request.url, {\r\n            method: request.method,\r\n            headers: fromNodeOutgoingHttpHeaders(request.headers),\r\n            duplex: 'half',\r\n            signal: request.request.signal,\r\n            // geo\r\n            // ip\r\n            // nextConfig\r\n            // body can not be passed if request was aborted\r\n            // or we get a Request body was disturbed error\r\n            ...request.request.signal.aborted ? {} : {\r\n                body\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=next-request.js.map","import { CachedRouteKind, IncrementalCacheKind } from './types';\r\nimport RenderResult from '../render-result';\r\nimport { RouteKind } from '../route-kind';\r\nimport { HTML_CONTENT_TYPE_HEADER } from '../../lib/constants';\r\nexport async function fromResponseCacheEntry(cacheEntry) {\r\n    var _cacheEntry_value, _cacheEntry_value1;\r\n    return {\r\n        ...cacheEntry,\r\n        value: ((_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) === CachedRouteKind.PAGES ? {\r\n            kind: CachedRouteKind.PAGES,\r\n            html: await cacheEntry.value.html.toUnchunkedString(true),\r\n            pageData: cacheEntry.value.pageData,\r\n            headers: cacheEntry.value.headers,\r\n            status: cacheEntry.value.status\r\n        } : ((_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind) === CachedRouteKind.APP_PAGE ? {\r\n            kind: CachedRouteKind.APP_PAGE,\r\n            html: await cacheEntry.value.html.toUnchunkedString(true),\r\n            postponed: cacheEntry.value.postponed,\r\n            rscData: cacheEntry.value.rscData,\r\n            headers: cacheEntry.value.headers,\r\n            status: cacheEntry.value.status,\r\n            segmentData: cacheEntry.value.segmentData\r\n        } : cacheEntry.value\r\n    };\r\n}\r\nexport async function toResponseCacheEntry(response) {\r\n    var _response_value, _response_value1;\r\n    if (!response) return null;\r\n    return {\r\n        isMiss: response.isMiss,\r\n        isStale: response.isStale,\r\n        cacheControl: response.cacheControl,\r\n        value: ((_response_value = response.value) == null ? void 0 : _response_value.kind) === CachedRouteKind.PAGES ? {\r\n            kind: CachedRouteKind.PAGES,\r\n            html: RenderResult.fromStatic(response.value.html, HTML_CONTENT_TYPE_HEADER),\r\n            pageData: response.value.pageData,\r\n            headers: response.value.headers,\r\n            status: response.value.status\r\n        } : ((_response_value1 = response.value) == null ? void 0 : _response_value1.kind) === CachedRouteKind.APP_PAGE ? {\r\n            kind: CachedRouteKind.APP_PAGE,\r\n            html: RenderResult.fromStatic(response.value.html, HTML_CONTENT_TYPE_HEADER),\r\n            rscData: response.value.rscData,\r\n            headers: response.value.headers,\r\n            status: response.value.status,\r\n            postponed: response.value.postponed,\r\n            segmentData: response.value.segmentData\r\n        } : response.value\r\n    };\r\n}\r\nexport function routeKindToIncrementalCacheKind(routeKind) {\r\n    switch(routeKind){\r\n        case RouteKind.PAGES:\r\n            return IncrementalCacheKind.PAGES;\r\n        case RouteKind.APP_PAGE:\r\n            return IncrementalCacheKind.APP_PAGE;\r\n        case RouteKind.IMAGE:\r\n            return IncrementalCacheKind.IMAGE;\r\n        case RouteKind.APP_ROUTE:\r\n            return IncrementalCacheKind.APP_ROUTE;\r\n        case RouteKind.PAGES_API:\r\n            // Pages Router API routes are not cached in the incremental cache.\r\n            throw Object.defineProperty(new Error(`Unexpected route kind ${routeKind}`), \"__NEXT_ERROR_CODE\", {\r\n                value: \"E64\",\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n        default:\r\n            return routeKind;\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=utils.js.map","// This regex contains the bots that we need to do a blocking render for and can't safely stream the response\r\n// due to how they parse the DOM. For example, they might explicitly check for metadata in the `head` tag, so we can't stream metadata tags after the `head` was sent.\r\n// Note: The pattern [\\w-]+-Google captures all Google crawlers with \"-Google\" suffix (e.g., Mediapartners-Google, AdsBot-Google, Storebot-Google)\r\n// as well as crawlers starting with \"Google-\" (e.g., Google-PageRenderer, Google-InspectionTool)\r\nexport const HTML_LIMITED_BOT_UA_RE = /[\\w-]+-Google|Google-[\\w-]+|Chrome-Lighthouse|Slurp|DuckDuckBot|baiduspider|yandex|sogou|bitlybot|tumblr|vkShare|quora link preview|redditbot|ia_archiver|Bingbot|BingPreview|applebot|facebookexternalhit|facebookcatalog|Twitterbot|LinkedInBot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|Yeti|googleweblight/i;\r\n\r\n//# sourceMappingURL=html-bots.js.map","/**\r\n * Given a path this function will find the pathname, query and hash and return\r\n * them. This is useful to parse full paths on the client side.\r\n * @param path A path to parse e.g. /foo/bar?id=1#hash\r\n */ export function parsePath(path) {\r\n    const hashIndex = path.indexOf('#');\r\n    const queryIndex = path.indexOf('?');\r\n    const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);\r\n    if (hasQuery || hashIndex > -1) {\r\n        return {\r\n            pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),\r\n            query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined) : '',\r\n            hash: hashIndex > -1 ? path.slice(hashIndex) : ''\r\n        };\r\n    }\r\n    return {\r\n        pathname: path,\r\n        query: '',\r\n        hash: ''\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=parse-path.js.map","import { DetachedPromise } from './detached-promise';\r\n/**\r\n * A wrapper for a function that will only allow one call to the function to\r\n * execute at a time.\r\n */ export class Batcher {\r\n    constructor(cacheKeyFn, /**\r\n     * A function that will be called to schedule the wrapped function to be\r\n     * executed. This defaults to a function that will execute the function\r\n     * immediately.\r\n     */ schedulerFn = (fn)=>fn()){\r\n        this.cacheKeyFn = cacheKeyFn;\r\n        this.schedulerFn = schedulerFn;\r\n        this.pending = new Map();\r\n    }\r\n    static create(options) {\r\n        return new Batcher(options == null ? void 0 : options.cacheKeyFn, options == null ? void 0 : options.schedulerFn);\r\n    }\r\n    /**\r\n   * Wraps a function in a promise that will be resolved or rejected only once\r\n   * for a given key. This will allow multiple calls to the function to be\r\n   * made, but only one will be executed at a time. The result of the first\r\n   * call will be returned to all callers.\r\n   *\r\n   * @param key the key to use for the cache\r\n   * @param fn the function to wrap\r\n   * @returns a promise that resolves to the result of the function\r\n   */ async batch(key, fn) {\r\n        const cacheKey = this.cacheKeyFn ? await this.cacheKeyFn(key) : key;\r\n        if (cacheKey === null) {\r\n            return fn({\r\n                resolve: (value)=>Promise.resolve(value),\r\n                key\r\n            });\r\n        }\r\n        const pending = this.pending.get(cacheKey);\r\n        if (pending) return pending;\r\n        const { promise, resolve, reject } = new DetachedPromise();\r\n        this.pending.set(cacheKey, promise);\r\n        this.schedulerFn(async ()=>{\r\n            try {\r\n                const result = await fn({\r\n                    resolve,\r\n                    key\r\n                });\r\n                // Resolving a promise multiple times is a no-op, so we can safely\r\n                // resolve all pending promises with the same result.\r\n                resolve(result);\r\n            } catch (err) {\r\n                reject(err);\r\n            } finally{\r\n                this.pending.delete(cacheKey);\r\n            }\r\n        });\r\n        return promise;\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=batcher.js.map","import { parsePath } from './parse-path';\r\n/**\r\n * Adds the provided prefix to the given path. It first ensures that the path\r\n * is indeed starting with a slash.\r\n */ export function addPathPrefix(path, prefix) {\r\n    if (!path.startsWith('/') || !prefix) {\r\n        return path;\r\n    }\r\n    const { pathname, query, hash } = parsePath(path);\r\n    return `${prefix}${pathname}${query}${hash}`;\r\n}\r\n\r\n//# sourceMappingURL=add-path-prefix.js.map","import { Batcher } from '../../lib/batcher';\r\nimport { scheduleOnNextTick } from '../../lib/scheduler';\r\nimport { fromResponseCacheEntry, routeKindToIncrementalCacheKind, toResponseCacheEntry } from './utils';\r\nexport * from './types';\r\nexport default class ResponseCache {\r\n    constructor(minimal_mode){\r\n        this.getBatcher = Batcher.create({\r\n            // Ensure on-demand revalidate doesn't block normal requests, it should be\r\n            // safe to run an on-demand revalidate for the same key as a normal request.\r\n            cacheKeyFn: ({ key, isOnDemandRevalidate })=>`${key}-${isOnDemandRevalidate ? '1' : '0'}`,\r\n            // We wait to do any async work until after we've added our promise to\r\n            // `pendingResponses` to ensure that any any other calls will reuse the\r\n            // same promise until we've fully finished our work.\r\n            schedulerFn: scheduleOnNextTick\r\n        });\r\n        this.revalidateBatcher = Batcher.create({\r\n            // We wait to do any async work until after we've added our promise to\r\n            // `pendingResponses` to ensure that any any other calls will reuse the\r\n            // same promise until we've fully finished our work.\r\n            schedulerFn: scheduleOnNextTick\r\n        });\r\n        this.minimal_mode = minimal_mode;\r\n    }\r\n    /**\r\n   * Gets the response cache entry for the given key.\r\n   *\r\n   * @param key - The key to get the response cache entry for.\r\n   * @param responseGenerator - The response generator to use to generate the response cache entry.\r\n   * @param context - The context for the get request.\r\n   * @returns The response cache entry.\r\n   */ async get(key, responseGenerator, context) {\r\n        var _this_previousCacheItem;\r\n        // If there is no key for the cache, we can't possibly look this up in the\r\n        // cache so just return the result of the response generator.\r\n        if (!key) {\r\n            return responseGenerator({\r\n                hasResolved: false,\r\n                previousCacheEntry: null\r\n            });\r\n        }\r\n        // Check minimal mode cache before doing any other work\r\n        if (this.minimal_mode && ((_this_previousCacheItem = this.previousCacheItem) == null ? void 0 : _this_previousCacheItem.key) === key && this.previousCacheItem.expiresAt > Date.now()) {\r\n            return toResponseCacheEntry(this.previousCacheItem.entry);\r\n        }\r\n        const { incrementalCache, isOnDemandRevalidate = false, isFallback = false, isRoutePPREnabled = false, isPrefetch = false, waitUntil, routeKind } = context;\r\n        const response = await this.getBatcher.batch({\r\n            key,\r\n            isOnDemandRevalidate\r\n        }, ({ resolve })=>{\r\n            const promise = this.handleGet(key, responseGenerator, {\r\n                incrementalCache,\r\n                isOnDemandRevalidate,\r\n                isFallback,\r\n                isRoutePPREnabled,\r\n                isPrefetch,\r\n                routeKind\r\n            }, resolve);\r\n            // We need to ensure background revalidates are passed to waitUntil.\r\n            if (waitUntil) waitUntil(promise);\r\n            return promise;\r\n        });\r\n        return toResponseCacheEntry(response);\r\n    }\r\n    /**\r\n   * Handles the get request for the response cache.\r\n   *\r\n   * @param key - The key to get the response cache entry for.\r\n   * @param responseGenerator - The response generator to use to generate the response cache entry.\r\n   * @param context - The context for the get request.\r\n   * @param resolve - The resolve function to use to resolve the response cache entry.\r\n   * @returns The response cache entry.\r\n   */ async handleGet(key, responseGenerator, context, resolve) {\r\n        let previousIncrementalCacheEntry = null;\r\n        let resolved = false;\r\n        try {\r\n            // Get the previous cache entry if not in minimal mode\r\n            previousIncrementalCacheEntry = !this.minimal_mode ? await context.incrementalCache.get(key, {\r\n                kind: routeKindToIncrementalCacheKind(context.routeKind),\r\n                isRoutePPREnabled: context.isRoutePPREnabled,\r\n                isFallback: context.isFallback\r\n            }) : null;\r\n            if (previousIncrementalCacheEntry && !context.isOnDemandRevalidate) {\r\n                resolve(previousIncrementalCacheEntry);\r\n                resolved = true;\r\n                if (!previousIncrementalCacheEntry.isStale || context.isPrefetch) {\r\n                    // The cached value is still valid, so we don't need to update it yet.\r\n                    return previousIncrementalCacheEntry;\r\n                }\r\n            }\r\n            // Revalidate the cache entry\r\n            const incrementalResponseCacheEntry = await this.revalidate(key, context.incrementalCache, context.isRoutePPREnabled, context.isFallback, responseGenerator, previousIncrementalCacheEntry, previousIncrementalCacheEntry !== null && !context.isOnDemandRevalidate);\r\n            // Handle null response\r\n            if (!incrementalResponseCacheEntry) {\r\n                // Unset the previous cache item if it was set so we don't use it again.\r\n                if (this.minimal_mode) this.previousCacheItem = undefined;\r\n                return null;\r\n            }\r\n            // Resolve for on-demand revalidation or if not already resolved\r\n            if (context.isOnDemandRevalidate && !resolved) {\r\n                return incrementalResponseCacheEntry;\r\n            }\r\n            return incrementalResponseCacheEntry;\r\n        } catch (err) {\r\n            // If we've already resolved the cache entry, we can't reject as we\r\n            // already resolved the cache entry so log the error here.\r\n            if (resolved) {\r\n                console.error(err);\r\n                return null;\r\n            }\r\n            throw err;\r\n        }\r\n    }\r\n    /**\r\n   * Revalidates the cache entry for the given key.\r\n   *\r\n   * @param key - The key to revalidate the cache entry for.\r\n   * @param incrementalCache - The incremental cache to use to revalidate the cache entry.\r\n   * @param isRoutePPREnabled - Whether the route is PPR enabled.\r\n   * @param isFallback - Whether the route is a fallback.\r\n   * @param responseGenerator - The response generator to use to generate the response cache entry.\r\n   * @param previousIncrementalCacheEntry - The previous cache entry to use to revalidate the cache entry.\r\n   * @param hasResolved - Whether the response has been resolved.\r\n   * @returns The revalidated cache entry.\r\n   */ async revalidate(key, incrementalCache, isRoutePPREnabled, isFallback, responseGenerator, previousIncrementalCacheEntry, hasResolved, waitUntil) {\r\n        return this.revalidateBatcher.batch(key, ()=>{\r\n            const promise = this.handleRevalidate(key, incrementalCache, isRoutePPREnabled, isFallback, responseGenerator, previousIncrementalCacheEntry, hasResolved);\r\n            // We need to ensure background revalidates are passed to waitUntil.\r\n            if (waitUntil) waitUntil(promise);\r\n            return promise;\r\n        });\r\n    }\r\n    async handleRevalidate(key, incrementalCache, isRoutePPREnabled, isFallback, responseGenerator, previousIncrementalCacheEntry, hasResolved) {\r\n        try {\r\n            // Generate the response cache entry using the response generator.\r\n            const responseCacheEntry = await responseGenerator({\r\n                hasResolved,\r\n                previousCacheEntry: previousIncrementalCacheEntry,\r\n                isRevalidating: true\r\n            });\r\n            if (!responseCacheEntry) {\r\n                return null;\r\n            }\r\n            // Convert the response cache entry to an incremental response cache entry.\r\n            const incrementalResponseCacheEntry = await fromResponseCacheEntry({\r\n                ...responseCacheEntry,\r\n                isMiss: !previousIncrementalCacheEntry\r\n            });\r\n            // We want to persist the result only if it has a cache control value\r\n            // defined.\r\n            if (incrementalResponseCacheEntry.cacheControl) {\r\n                if (this.minimal_mode) {\r\n                    this.previousCacheItem = {\r\n                        key,\r\n                        entry: incrementalResponseCacheEntry,\r\n                        expiresAt: Date.now() + 1000\r\n                    };\r\n                } else {\r\n                    await incrementalCache.set(key, incrementalResponseCacheEntry.value, {\r\n                        cacheControl: incrementalResponseCacheEntry.cacheControl,\r\n                        isRoutePPREnabled,\r\n                        isFallback\r\n                    });\r\n                }\r\n            }\r\n            return incrementalResponseCacheEntry;\r\n        } catch (err) {\r\n            // When a path is erroring we automatically re-set the existing cache\r\n            // with new revalidate and expire times to prevent non-stop retrying.\r\n            if (previousIncrementalCacheEntry == null ? void 0 : previousIncrementalCacheEntry.cacheControl) {\r\n                const revalidate = Math.min(Math.max(previousIncrementalCacheEntry.cacheControl.revalidate || 3, 3), 30);\r\n                const expire = previousIncrementalCacheEntry.cacheControl.expire === undefined ? undefined : Math.max(revalidate + 3, previousIncrementalCacheEntry.cacheControl.expire);\r\n                await incrementalCache.set(key, previousIncrementalCacheEntry.value, {\r\n                    cacheControl: {\r\n                        revalidate: revalidate,\r\n                        expire: expire\r\n                    },\r\n                    isRoutePPREnabled,\r\n                    isFallback\r\n                });\r\n            }\r\n            // We haven't resolved yet, so let's throw to indicate an error.\r\n            throw err;\r\n        }\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=index.js.map","import { ResponseAbortedName, createAbortController } from './web/spec-extension/adapters/next-request';\r\nimport { DetachedPromise } from '../lib/detached-promise';\r\nimport { getTracer } from './lib/trace/tracer';\r\nimport { NextNodeServerSpan } from './lib/trace/constants';\r\nimport { getClientComponentLoaderMetrics } from './client-component-renderer-logger';\r\nexport function isAbortError(e) {\r\n    return (e == null ? void 0 : e.name) === 'AbortError' || (e == null ? void 0 : e.name) === ResponseAbortedName;\r\n}\r\nfunction createWriterFromResponse(res, waitUntilForEnd) {\r\n    let started = false;\r\n    // Create a promise that will resolve once the response has drained. See\r\n    // https://nodejs.org/api/stream.html#stream_event_drain\r\n    let drained = new DetachedPromise();\r\n    function onDrain() {\r\n        drained.resolve();\r\n    }\r\n    res.on('drain', onDrain);\r\n    // If the finish event fires, it means we shouldn't block and wait for the\r\n    // drain event.\r\n    res.once('close', ()=>{\r\n        res.off('drain', onDrain);\r\n        drained.resolve();\r\n    });\r\n    // Create a promise that will resolve once the response has finished. See\r\n    // https://nodejs.org/api/http.html#event-finish_1\r\n    const finished = new DetachedPromise();\r\n    res.once('finish', ()=>{\r\n        finished.resolve();\r\n    });\r\n    // Create a writable stream that will write to the response.\r\n    return new WritableStream({\r\n        write: async (chunk)=>{\r\n            // You'd think we'd want to use `start` instead of placing this in `write`\r\n            // but this ensures that we don't actually flush the headers until we've\r\n            // started writing chunks.\r\n            if (!started) {\r\n                started = true;\r\n                if ('performance' in globalThis && process.env.NEXT_OTEL_PERFORMANCE_PREFIX) {\r\n                    const metrics = getClientComponentLoaderMetrics();\r\n                    if (metrics) {\r\n                        performance.measure(`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-client-component-loading`, {\r\n                            start: metrics.clientComponentLoadStart,\r\n                            end: metrics.clientComponentLoadStart + metrics.clientComponentLoadTimes\r\n                        });\r\n                    }\r\n                }\r\n                res.flushHeaders();\r\n                getTracer().trace(NextNodeServerSpan.startResponse, {\r\n                    spanName: 'start response'\r\n                }, ()=>undefined);\r\n            }\r\n            try {\r\n                const ok = res.write(chunk);\r\n                // Added by the `compression` middleware, this is a function that will\r\n                // flush the partially-compressed response to the client.\r\n                if ('flush' in res && typeof res.flush === 'function') {\r\n                    res.flush();\r\n                }\r\n                // If the write returns false, it means there's some backpressure, so\r\n                // wait until it's streamed before continuing.\r\n                if (!ok) {\r\n                    await drained.promise;\r\n                    // Reset the drained promise so that we can wait for the next drain event.\r\n                    drained = new DetachedPromise();\r\n                }\r\n            } catch (err) {\r\n                res.end();\r\n                throw Object.defineProperty(new Error('failed to write chunk to response', {\r\n                    cause: err\r\n                }), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E321\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            }\r\n        },\r\n        abort: (err)=>{\r\n            if (res.writableFinished) return;\r\n            res.destroy(err);\r\n        },\r\n        close: async ()=>{\r\n            // if a waitUntil promise was passed, wait for it to resolve before\r\n            // ending the response.\r\n            if (waitUntilForEnd) {\r\n                await waitUntilForEnd;\r\n            }\r\n            if (res.writableFinished) return;\r\n            res.end();\r\n            return finished.promise;\r\n        }\r\n    });\r\n}\r\nexport async function pipeToNodeResponse(readable, res, waitUntilForEnd) {\r\n    try {\r\n        // If the response has already errored, then just return now.\r\n        const { errored, destroyed } = res;\r\n        if (errored || destroyed) return;\r\n        // Create a new AbortController so that we can abort the readable if the\r\n        // client disconnects.\r\n        const controller = createAbortController(res);\r\n        const writer = createWriterFromResponse(res, waitUntilForEnd);\r\n        await readable.pipeTo(writer, {\r\n            signal: controller.signal\r\n        });\r\n    } catch (err) {\r\n        // If this isn't related to an abort error, re-throw it.\r\n        if (isAbortError(err)) return;\r\n        throw Object.defineProperty(new Error('failed to pipe response', {\r\n            cause: err\r\n        }), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E180\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=pipe-readable.js.map","/**\r\n * A `Promise.withResolvers` implementation that exposes the `resolve` and\r\n * `reject` functions on a `Promise`.\r\n *\r\n * @see https://tc39.es/proposal-promise-with-resolvers/\r\n */ export class DetachedPromise {\r\n    constructor(){\r\n        let resolve;\r\n        let reject;\r\n        // Create the promise and assign the resolvers to the object.\r\n        this.promise = new Promise((res, rej)=>{\r\n            resolve = res;\r\n            reject = rej;\r\n        });\r\n        // We know that resolvers is defined because the Promise constructor runs\r\n        // synchronously.\r\n        this.resolve = resolve;\r\n        this.reject = reject;\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=detached-promise.js.map","/**\r\n * Takes an object with a hostname property (like a parsed URL) and some\r\n * headers that may contain Host and returns the preferred hostname.\r\n * @param parsed An object containing a hostname property.\r\n * @param headers A dictionary with headers containing a `host`.\r\n */ export function getHostname(parsed, headers) {\r\n    // Get the hostname from the headers if it exists, otherwise use the parsed\r\n    // hostname.\r\n    let hostname;\r\n    if (headers?.host && !Array.isArray(headers.host)) {\r\n        hostname = headers.host.toString().split(':', 1)[0];\r\n    } else if (parsed.hostname) {\r\n        hostname = parsed.hostname;\r\n    } else return;\r\n    return hostname.toLowerCase();\r\n}\r\n\r\n//# sourceMappingURL=get-hostname.js.map","import { parsePath } from './parse-path';\r\n/**\r\n * Similarly to `addPathPrefix`, this function adds a suffix at the end on the\r\n * provided path. It also works only for paths ensuring the argument starts\r\n * with a slash.\r\n */ export function addPathSuffix(path, suffix) {\r\n    if (!path.startsWith('/') || !suffix) {\r\n        return path;\r\n    }\r\n    const { pathname, query, hash } = parsePath(path);\r\n    return `${pathname}${suffix}${query}${hash}`;\r\n}\r\n\r\n//# sourceMappingURL=add-path-suffix.js.map","/**\r\n * Schedules a function to be called on the next tick after the other promises\r\n * have been resolved.\r\n *\r\n * @param cb the function to schedule\r\n */ export const scheduleOnNextTick = (cb)=>{\r\n    // We use Promise.resolve().then() here so that the operation is scheduled at\r\n    // the end of the promise job queue, we then add it to the next process tick\r\n    // to ensure it's evaluated afterwards.\r\n    //\r\n    // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255\r\n    //\r\n    Promise.resolve().then(()=>{\r\n        if (process.env.NEXT_RUNTIME === 'edge') {\r\n            setTimeout(cb, 0);\r\n        } else {\r\n            process.nextTick(cb);\r\n        }\r\n    });\r\n};\r\n/**\r\n * Schedules a function to be called using `setImmediate` or `setTimeout` if\r\n * `setImmediate` is not available (like in the Edge runtime).\r\n *\r\n * @param cb the function to schedule\r\n */ export const scheduleImmediate = (cb)=>{\r\n    if (process.env.NEXT_RUNTIME === 'edge') {\r\n        setTimeout(cb, 0);\r\n    } else {\r\n        setImmediate(cb);\r\n    }\r\n};\r\n/**\r\n * returns a promise than resolves in a future task. There is no guarantee that the task it resolves in\r\n * will be the next task but if you await it you can at least be sure that the current task is over and\r\n * most usefully that the entire microtask queue of the current task has been emptied.\r\n */ export function atLeastOneTask() {\r\n    return new Promise((resolve)=>scheduleImmediate(resolve));\r\n}\r\n/**\r\n * This utility function is extracted to make it easier to find places where we are doing\r\n * specific timing tricks to try to schedule work after React has rendered. This is especially\r\n * important at the moment because Next.js uses the edge builds of React which use setTimeout to\r\n * schedule work when you might expect that something like setImmediate would do the trick.\r\n *\r\n * Long term we should switch to the node versions of React rendering when possible and then\r\n * update this to use setImmediate rather than setTimeout\r\n */ export function waitAtLeastOneReactRenderTask() {\r\n    if (process.env.NEXT_RUNTIME === 'edge') {\r\n        return new Promise((r)=>setTimeout(r, 0));\r\n    } else {\r\n        return new Promise((r)=>setImmediate(r));\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=scheduler.js.map","/**\r\n * Check to see if a value is Thenable.\r\n *\r\n * @param promise the maybe-thenable value\r\n * @returns true if the value is thenable\r\n */ export function isThenable(promise) {\r\n    return promise !== null && typeof promise === 'object' && 'then' in promise && typeof promise.then === 'function';\r\n}\r\n\r\n//# sourceMappingURL=is-thenable.js.map","/**\r\n * Removes the trailing slash for a given route or page path. Preserves the\r\n * root page. Examples:\r\n *   - `/foo/bar/` -> `/foo/bar`\r\n *   - `/foo/bar` -> `/foo/bar`\r\n *   - `/` -> `/`\r\n */ export function removeTrailingSlash(route) {\r\n    return route.replace(/\\/$/, '') || '/';\r\n}\r\n\r\n//# sourceMappingURL=remove-trailing-slash.js.map","import { addPathPrefix } from './add-path-prefix';\r\nimport { pathHasPrefix } from './path-has-prefix';\r\n/**\r\n * For a given path and a locale, if the locale is given, it will prefix the\r\n * locale. The path shouldn't be an API path. If a default locale is given the\r\n * prefix will be omitted if the locale is already the default locale.\r\n */ export function addLocale(path, locale, defaultLocale, ignorePrefix) {\r\n    // If no locale was given or the locale is the default locale, we don't need\r\n    // to prefix the path.\r\n    if (!locale || locale === defaultLocale) return path;\r\n    const lower = path.toLowerCase();\r\n    // If the path is an API path or the path already has the locale prefix, we\r\n    // don't need to prefix the path.\r\n    if (!ignorePrefix) {\r\n        if (pathHasPrefix(lower, '/api')) return path;\r\n        if (pathHasPrefix(lower, `/${locale.toLowerCase()}`)) return path;\r\n    }\r\n    // Add the locale prefix to the path.\r\n    return addPathPrefix(path, `/${locale}`);\r\n}\r\n\r\n//# sourceMappingURL=add-locale.js.map","// http://www.cse.yorku.ca/~oz/hash.html\r\n// More specifically, 32-bit hash via djbxor\r\n// (ref: https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765)\r\n// This is due to number type differences between rust for turbopack to js number types,\r\n// where rust does not have easy way to repreesnt js's 53-bit float number type for the matching\r\n// overflow behavior. This is more `correct` in terms of having canonical hash across different runtime / implementation\r\n// as can gaurantee determinstic output from 32bit hash.\r\nexport function djb2Hash(str) {\r\n    let hash = 5381;\r\n    for(let i = 0; i < str.length; i++){\r\n        const char = str.charCodeAt(i);\r\n        hash = (hash << 5) + hash + char & 0xffffffff;\r\n    }\r\n    return hash >>> 0;\r\n}\r\nexport function hexHash(str) {\r\n    return djb2Hash(str).toString(36).slice(0, 5);\r\n}\r\n\r\n//# sourceMappingURL=hash.js.map","import { parsePath } from './parse-path';\r\n/**\r\n * Checks if a given path starts with a given prefix. It ensures it matches\r\n * exactly without containing extra chars. e.g. prefix /docs should replace\r\n * for /docs, /docs/, /docs/a but not /docsss\r\n * @param path The path to check.\r\n * @param prefix The prefix to check against.\r\n */ export function pathHasPrefix(path, prefix) {\r\n    if (typeof path !== 'string') {\r\n        return false;\r\n    }\r\n    const { pathname } = parsePath(path);\r\n    return pathname === prefix || pathname.startsWith(prefix + '/');\r\n}\r\n\r\n//# sourceMappingURL=path-has-prefix.js.map","/**\r\n * FNV-1a Hash implementation\r\n * @author Travis Webb (tjwebb) <me@traviswebb.com>\r\n *\r\n * Ported from https://github.com/tjwebb/fnv-plus/blob/master/index.js\r\n *\r\n * Simplified, optimized and add modified for 52 bit, which provides a larger hash space\r\n * and still making use of Javascript's 53-bit integer space.\r\n */ export const fnv1a52 = (str)=>{\r\n    const len = str.length;\r\n    let i = 0, t0 = 0, v0 = 0x2325, t1 = 0, v1 = 0x8422, t2 = 0, v2 = 0x9ce4, t3 = 0, v3 = 0xcbf2;\r\n    while(i < len){\r\n        v0 ^= str.charCodeAt(i++);\r\n        t0 = v0 * 435;\r\n        t1 = v1 * 435;\r\n        t2 = v2 * 435;\r\n        t3 = v3 * 435;\r\n        t2 += v0 << 8;\r\n        t3 += v1 << 8;\r\n        t1 += t0 >>> 16;\r\n        v0 = t0 & 65535;\r\n        t2 += t1 >>> 16;\r\n        v1 = t1 & 65535;\r\n        v3 = t3 + (t2 >>> 16) & 65535;\r\n        v2 = t2 & 65535;\r\n    }\r\n    return (v3 & 15) * 281474976710656 + v2 * 4294967296 + v1 * 65536 + (v0 ^ v3 >> 4);\r\n};\r\nexport const generateETag = (payload, weak = false)=>{\r\n    const prefix = weak ? 'W/\"' : '\"';\r\n    return prefix + fnv1a52(payload).toString(36) + payload.length.toString(36) + '\"';\r\n};\r\n\r\n//# sourceMappingURL=etag.js.map","import { pathHasPrefix } from './path-has-prefix';\r\n/**\r\n * Given a path and a prefix it will remove the prefix when it exists in the\r\n * given path. It ensures it matches exactly without containing extra chars\r\n * and if the prefix is not there it will be noop.\r\n *\r\n * @param path The path to remove the prefix from.\r\n * @param prefix The prefix to be removed.\r\n */ export function removePathPrefix(path, prefix) {\r\n    // If the path doesn't start with the prefix we can return it as is. This\r\n    // protects us from situations where the prefix is a substring of the path\r\n    // prefix such as:\r\n    //\r\n    // For prefix: /blog\r\n    //\r\n    //   /blog -> true\r\n    //   /blog/ -> true\r\n    //   /blog/1 -> true\r\n    //   /blogging -> false\r\n    //   /blogging/ -> false\r\n    //   /blogging/1 -> false\r\n    if (!pathHasPrefix(path, prefix)) {\r\n        return path;\r\n    }\r\n    // Remove the prefix from the path via slicing.\r\n    const withoutPrefix = path.slice(prefix.length);\r\n    // If the path without the prefix starts with a `/` we can return it as is.\r\n    if (withoutPrefix.startsWith('/')) {\r\n        return withoutPrefix;\r\n    }\r\n    // If the path without the prefix doesn't start with a `/` we need to add it\r\n    // back to the path to make sure it's a valid path.\r\n    return `/${withoutPrefix}`;\r\n}\r\n\r\n//# sourceMappingURL=remove-path-prefix.js.map","import { NEXT_INTERCEPTION_MARKER_PREFIX, NEXT_QUERY_PARAM_PREFIX } from '../../lib/constants';\r\n/**\r\n * Converts a Node.js IncomingHttpHeaders object to a Headers object. Any\r\n * headers with multiple values will be joined with a comma and space. Any\r\n * headers that have an undefined value will be ignored and others will be\r\n * coerced to strings.\r\n *\r\n * @param nodeHeaders the headers object to convert\r\n * @returns the converted headers object\r\n */ export function fromNodeOutgoingHttpHeaders(nodeHeaders) {\r\n    const headers = new Headers();\r\n    for (let [key, value] of Object.entries(nodeHeaders)){\r\n        const values = Array.isArray(value) ? value : [\r\n            value\r\n        ];\r\n        for (let v of values){\r\n            if (typeof v === 'undefined') continue;\r\n            if (typeof v === 'number') {\r\n                v = v.toString();\r\n            }\r\n            headers.append(key, v);\r\n        }\r\n    }\r\n    return headers;\r\n}\r\n/*\r\n  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas\r\n  that are within a single set-cookie field-value, such as in the Expires portion.\r\n  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2\r\n  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128\r\n  React Native's fetch does this for *every* header, including set-cookie.\r\n  \r\n  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25\r\n  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation\r\n*/ export function splitCookiesString(cookiesString) {\r\n    var cookiesStrings = [];\r\n    var pos = 0;\r\n    var start;\r\n    var ch;\r\n    var lastComma;\r\n    var nextStart;\r\n    var cookiesSeparatorFound;\r\n    function skipWhitespace() {\r\n        while(pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))){\r\n            pos += 1;\r\n        }\r\n        return pos < cookiesString.length;\r\n    }\r\n    function notSpecialChar() {\r\n        ch = cookiesString.charAt(pos);\r\n        return ch !== '=' && ch !== ';' && ch !== ',';\r\n    }\r\n    while(pos < cookiesString.length){\r\n        start = pos;\r\n        cookiesSeparatorFound = false;\r\n        while(skipWhitespace()){\r\n            ch = cookiesString.charAt(pos);\r\n            if (ch === ',') {\r\n                // ',' is a cookie separator if we have later first '=', not ';' or ','\r\n                lastComma = pos;\r\n                pos += 1;\r\n                skipWhitespace();\r\n                nextStart = pos;\r\n                while(pos < cookiesString.length && notSpecialChar()){\r\n                    pos += 1;\r\n                }\r\n                // currently special character\r\n                if (pos < cookiesString.length && cookiesString.charAt(pos) === '=') {\r\n                    // we found cookies separator\r\n                    cookiesSeparatorFound = true;\r\n                    // pos is inside the next cookie, so back up and return it.\r\n                    pos = nextStart;\r\n                    cookiesStrings.push(cookiesString.substring(start, lastComma));\r\n                    start = pos;\r\n                } else {\r\n                    // in param ',' or param separator ';',\r\n                    // we continue from that comma\r\n                    pos = lastComma + 1;\r\n                }\r\n            } else {\r\n                pos += 1;\r\n            }\r\n        }\r\n        if (!cookiesSeparatorFound || pos >= cookiesString.length) {\r\n            cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\r\n        }\r\n    }\r\n    return cookiesStrings;\r\n}\r\n/**\r\n * Converts a Headers object to a Node.js OutgoingHttpHeaders object. This is\r\n * required to support the set-cookie header, which may have multiple values.\r\n *\r\n * @param headers the headers object to convert\r\n * @returns the converted headers object\r\n */ export function toNodeOutgoingHttpHeaders(headers) {\r\n    const nodeHeaders = {};\r\n    const cookies = [];\r\n    if (headers) {\r\n        for (const [key, value] of headers.entries()){\r\n            if (key.toLowerCase() === 'set-cookie') {\r\n                // We may have gotten a comma joined string of cookies, or multiple\r\n                // set-cookie headers. We need to merge them into one header array\r\n                // to represent all the cookies.\r\n                cookies.push(...splitCookiesString(value));\r\n                nodeHeaders[key] = cookies.length === 1 ? cookies[0] : cookies;\r\n            } else {\r\n                nodeHeaders[key] = value;\r\n            }\r\n        }\r\n    }\r\n    return nodeHeaders;\r\n}\r\n/**\r\n * Validate the correctness of a user-provided URL.\r\n */ export function validateURL(url) {\r\n    try {\r\n        return String(new URL(String(url)));\r\n    } catch (error) {\r\n        throw Object.defineProperty(new Error(`URL is malformed \"${String(url)}\". Please use only absolute URLs - https://nextjs.org/docs/messages/middleware-relative-urls`, {\r\n            cause: error\r\n        }), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E61\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n}\r\n/**\r\n * Normalizes `nxtP` and `nxtI` query param values to remove the prefix.\r\n * This function does not mutate the input key.\r\n */ export function normalizeNextQueryParam(key) {\r\n    const prefixes = [\r\n        NEXT_QUERY_PARAM_PREFIX,\r\n        NEXT_INTERCEPTION_MARKER_PREFIX\r\n    ];\r\n    for (const prefix of prefixes){\r\n        if (key !== prefix && key.startsWith(prefix)) {\r\n            return key.substring(prefix.length);\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n//# sourceMappingURL=utils.js.map","import { getTracer } from '../lib/trace/tracer';\r\nimport { AppRenderSpan } from '../lib/trace/constants';\r\nimport { DetachedPromise } from '../../lib/detached-promise';\r\nimport { scheduleImmediate, atLeastOneTask } from '../../lib/scheduler';\r\nimport { ENCODED_TAGS } from './encoded-tags';\r\nimport { indexOfUint8Array, isEquivalentUint8Arrays, removeFromUint8Array } from './uint8array-helpers';\r\nimport { MISSING_ROOT_TAGS_ERROR } from '../../shared/lib/errors/constants';\r\nimport { insertBuildIdComment } from '../../shared/lib/segment-cache/output-export-prefetch-encoding';\r\nimport { RSC_HEADER, NEXT_ROUTER_PREFETCH_HEADER, NEXT_ROUTER_SEGMENT_PREFETCH_HEADER, NEXT_RSC_UNION_QUERY } from '../../client/components/app-router-headers';\r\nimport { computeCacheBustingSearchParam } from '../../shared/lib/router/utils/cache-busting-search-param';\r\nfunction voidCatch() {\r\n// this catcher is designed to be used with pipeTo where we expect the underlying\r\n// pipe implementation to forward errors but we don't want the pipeTo promise to reject\r\n// and be unhandled\r\n}\r\n// We can share the same encoder instance everywhere\r\n// Notably we cannot do the same for TextDecoder because it is stateful\r\n// when handling streaming data\r\nconst encoder = new TextEncoder();\r\nexport function chainStreams(...streams) {\r\n    // If we have no streams, return an empty stream. This behavior is\r\n    // intentional as we're now providing the `RenderResult.EMPTY` value.\r\n    if (streams.length === 0) {\r\n        return new ReadableStream({\r\n            start (controller) {\r\n                controller.close();\r\n            }\r\n        });\r\n    }\r\n    // If we only have 1 stream we fast path it by returning just this stream\r\n    if (streams.length === 1) {\r\n        return streams[0];\r\n    }\r\n    const { readable, writable } = new TransformStream();\r\n    // We always initiate pipeTo immediately. We know we have at least 2 streams\r\n    // so we need to avoid closing the writable when this one finishes.\r\n    let promise = streams[0].pipeTo(writable, {\r\n        preventClose: true\r\n    });\r\n    let i = 1;\r\n    for(; i < streams.length - 1; i++){\r\n        const nextStream = streams[i];\r\n        promise = promise.then(()=>nextStream.pipeTo(writable, {\r\n                preventClose: true\r\n            }));\r\n    }\r\n    // We can omit the length check because we halted before the last stream and there\r\n    // is at least two streams so the lastStream here will always be defined\r\n    const lastStream = streams[i];\r\n    promise = promise.then(()=>lastStream.pipeTo(writable));\r\n    // Catch any errors from the streams and ignore them, they will be handled\r\n    // by whatever is consuming the readable stream.\r\n    promise.catch(voidCatch);\r\n    return readable;\r\n}\r\nexport function streamFromString(str) {\r\n    return new ReadableStream({\r\n        start (controller) {\r\n            controller.enqueue(encoder.encode(str));\r\n            controller.close();\r\n        }\r\n    });\r\n}\r\nexport function streamFromBuffer(chunk) {\r\n    return new ReadableStream({\r\n        start (controller) {\r\n            controller.enqueue(chunk);\r\n            controller.close();\r\n        }\r\n    });\r\n}\r\nexport async function streamToBuffer(stream) {\r\n    const reader = stream.getReader();\r\n    const chunks = [];\r\n    while(true){\r\n        const { done, value } = await reader.read();\r\n        if (done) {\r\n            break;\r\n        }\r\n        chunks.push(value);\r\n    }\r\n    return Buffer.concat(chunks);\r\n}\r\nexport async function streamToString(stream, signal) {\r\n    const decoder = new TextDecoder('utf-8', {\r\n        fatal: true\r\n    });\r\n    let string = '';\r\n    for await (const chunk of stream){\r\n        if (signal == null ? void 0 : signal.aborted) {\r\n            return string;\r\n        }\r\n        string += decoder.decode(chunk, {\r\n            stream: true\r\n        });\r\n    }\r\n    string += decoder.decode();\r\n    return string;\r\n}\r\nexport function createBufferedTransformStream(options = {}) {\r\n    const { maxBufferByteLength = Infinity } = options;\r\n    let bufferedChunks = [];\r\n    let bufferByteLength = 0;\r\n    let pending;\r\n    const flush = (controller)=>{\r\n        try {\r\n            if (bufferedChunks.length === 0) {\r\n                return;\r\n            }\r\n            const chunk = new Uint8Array(bufferByteLength);\r\n            let copiedBytes = 0;\r\n            for(let i = 0; i < bufferedChunks.length; i++){\r\n                const bufferedChunk = bufferedChunks[i];\r\n                chunk.set(bufferedChunk, copiedBytes);\r\n                copiedBytes += bufferedChunk.byteLength;\r\n            }\r\n            // We just wrote all the buffered chunks so we need to reset the bufferedChunks array\r\n            // and our bufferByteLength to prepare for the next round of buffered chunks\r\n            bufferedChunks.length = 0;\r\n            bufferByteLength = 0;\r\n            controller.enqueue(chunk);\r\n        } catch  {\r\n        // If an error occurs while enqueuing, it can't be due to this\r\n        // transformer. It's most likely caused by the controller having been\r\n        // errored (for example, if the stream was cancelled).\r\n        }\r\n    };\r\n    const scheduleFlush = (controller)=>{\r\n        if (pending) {\r\n            return;\r\n        }\r\n        const detached = new DetachedPromise();\r\n        pending = detached;\r\n        scheduleImmediate(()=>{\r\n            try {\r\n                flush(controller);\r\n            } finally{\r\n                pending = undefined;\r\n                detached.resolve();\r\n            }\r\n        });\r\n    };\r\n    return new TransformStream({\r\n        transform (chunk, controller) {\r\n            // Combine the previous buffer with the new chunk.\r\n            bufferedChunks.push(chunk);\r\n            bufferByteLength += chunk.byteLength;\r\n            if (bufferByteLength >= maxBufferByteLength) {\r\n                flush(controller);\r\n            } else {\r\n                scheduleFlush(controller);\r\n            }\r\n        },\r\n        flush () {\r\n            return pending == null ? void 0 : pending.promise;\r\n        }\r\n    });\r\n}\r\nfunction createPrefetchCommentStream(isBuildTimePrerendering, buildId) {\r\n    // Insert an extra comment at the beginning of the HTML document. This must\r\n    // come after the DOCTYPE, which is inserted by React.\r\n    //\r\n    // The first chunk sent by React will contain the doctype. After that, we can\r\n    // pass through the rest of the chunks as-is.\r\n    let didTransformFirstChunk = false;\r\n    return new TransformStream({\r\n        transform (chunk, controller) {\r\n            if (isBuildTimePrerendering && !didTransformFirstChunk) {\r\n                didTransformFirstChunk = true;\r\n                const decoder = new TextDecoder('utf-8', {\r\n                    fatal: true\r\n                });\r\n                const chunkStr = decoder.decode(chunk, {\r\n                    stream: true\r\n                });\r\n                const updatedChunkStr = insertBuildIdComment(chunkStr, buildId);\r\n                controller.enqueue(encoder.encode(updatedChunkStr));\r\n                return;\r\n            }\r\n            controller.enqueue(chunk);\r\n        }\r\n    });\r\n}\r\nexport function renderToInitialFizzStream({ ReactDOMServer, element, streamOptions }) {\r\n    return getTracer().trace(AppRenderSpan.renderToReadableStream, async ()=>ReactDOMServer.renderToReadableStream(element, streamOptions));\r\n}\r\nfunction createMetadataTransformStream(insert) {\r\n    let chunkIndex = -1;\r\n    let isMarkRemoved = false;\r\n    return new TransformStream({\r\n        async transform (chunk, controller) {\r\n            let iconMarkIndex = -1;\r\n            let closedHeadIndex = -1;\r\n            chunkIndex++;\r\n            if (isMarkRemoved) {\r\n                controller.enqueue(chunk);\r\n                return;\r\n            }\r\n            let iconMarkLength = 0;\r\n            // Only search for the closed head tag once\r\n            if (iconMarkIndex === -1) {\r\n                iconMarkIndex = indexOfUint8Array(chunk, ENCODED_TAGS.META.ICON_MARK);\r\n                if (iconMarkIndex === -1) {\r\n                    controller.enqueue(chunk);\r\n                    return;\r\n                } else {\r\n                    // When we found the `<meta name=\"nxt-icon\"` tag prefix, we will remove it from the chunk.\r\n                    // Its close tag could either be `/>` or `>`, checking the next char to ensure we cover both cases.\r\n                    iconMarkLength = ENCODED_TAGS.META.ICON_MARK.length;\r\n                    // Check if next char is /, this is for xml mode.\r\n                    if (chunk[iconMarkIndex + iconMarkLength] === 47) {\r\n                        iconMarkLength += 2;\r\n                    } else {\r\n                        // The last char is `>`\r\n                        iconMarkLength++;\r\n                    }\r\n                }\r\n            }\r\n            // Check if icon mark is inside <head> tag in the first chunk.\r\n            if (chunkIndex === 0) {\r\n                closedHeadIndex = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD);\r\n                if (iconMarkIndex !== -1) {\r\n                    // The mark icon is located in the 1st chunk before the head tag.\r\n                    // We do not need to insert the script tag in this case because it's in the head.\r\n                    // Just remove the icon mark from the chunk.\r\n                    if (iconMarkIndex < closedHeadIndex) {\r\n                        const replaced = new Uint8Array(chunk.length - iconMarkLength);\r\n                        // Remove the icon mark from the chunk.\r\n                        replaced.set(chunk.subarray(0, iconMarkIndex));\r\n                        replaced.set(chunk.subarray(iconMarkIndex + iconMarkLength), iconMarkIndex);\r\n                        chunk = replaced;\r\n                    } else {\r\n                        // The icon mark is after the head tag, replace and insert the script tag at that position.\r\n                        const insertion = await insert();\r\n                        const encodedInsertion = encoder.encode(insertion);\r\n                        const insertionLength = encodedInsertion.length;\r\n                        const replaced = new Uint8Array(chunk.length - iconMarkLength + insertionLength);\r\n                        replaced.set(chunk.subarray(0, iconMarkIndex));\r\n                        replaced.set(encodedInsertion, iconMarkIndex);\r\n                        replaced.set(chunk.subarray(iconMarkIndex + iconMarkLength), iconMarkIndex + insertionLength);\r\n                        chunk = replaced;\r\n                    }\r\n                    isMarkRemoved = true;\r\n                }\r\n            // If there's no icon mark located, it will be handled later when if present in the following chunks.\r\n            } else {\r\n                // When it's appeared in the following chunks, we'll need to\r\n                // remove the mark and then insert the script tag at that position.\r\n                const insertion = await insert();\r\n                const encodedInsertion = encoder.encode(insertion);\r\n                const insertionLength = encodedInsertion.length;\r\n                // Replace the icon mark with the hoist script or empty string.\r\n                const replaced = new Uint8Array(chunk.length - iconMarkLength + insertionLength);\r\n                // Set the first part of the chunk, before the icon mark.\r\n                replaced.set(chunk.subarray(0, iconMarkIndex));\r\n                // Set the insertion after the icon mark.\r\n                replaced.set(encodedInsertion, iconMarkIndex);\r\n                // Set the rest of the chunk after the icon mark.\r\n                replaced.set(chunk.subarray(iconMarkIndex + iconMarkLength), iconMarkIndex + insertionLength);\r\n                chunk = replaced;\r\n                isMarkRemoved = true;\r\n            }\r\n            controller.enqueue(chunk);\r\n        }\r\n    });\r\n}\r\nfunction createHeadInsertionTransformStream(insert) {\r\n    let inserted = false;\r\n    // We need to track if this transform saw any bytes because if it didn't\r\n    // we won't want to insert any server HTML at all\r\n    let hasBytes = false;\r\n    return new TransformStream({\r\n        async transform (chunk, controller) {\r\n            hasBytes = true;\r\n            const insertion = await insert();\r\n            if (inserted) {\r\n                if (insertion) {\r\n                    const encodedInsertion = encoder.encode(insertion);\r\n                    controller.enqueue(encodedInsertion);\r\n                }\r\n                controller.enqueue(chunk);\r\n            } else {\r\n                // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.\r\n                const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD);\r\n                // In fully static rendering or non PPR rendering cases:\r\n                // `/head>` will always be found in the chunk in first chunk rendering.\r\n                if (index !== -1) {\r\n                    if (insertion) {\r\n                        const encodedInsertion = encoder.encode(insertion);\r\n                        // Get the total count of the bytes in the chunk and the insertion\r\n                        // e.g.\r\n                        // chunk = <head><meta charset=\"utf-8\"></head>\r\n                        // insertion = <script>...</script>\r\n                        // output = <head><meta charset=\"utf-8\"> [ <script>...</script> ] </head>\r\n                        const insertedHeadContent = new Uint8Array(chunk.length + encodedInsertion.length);\r\n                        // Append the first part of the chunk, before the head tag\r\n                        insertedHeadContent.set(chunk.slice(0, index));\r\n                        // Append the server inserted content\r\n                        insertedHeadContent.set(encodedInsertion, index);\r\n                        // Append the rest of the chunk\r\n                        insertedHeadContent.set(chunk.slice(index), index + encodedInsertion.length);\r\n                        controller.enqueue(insertedHeadContent);\r\n                    } else {\r\n                        controller.enqueue(chunk);\r\n                    }\r\n                    inserted = true;\r\n                } else {\r\n                    // This will happens in PPR rendering during next start, when the page is partially rendered.\r\n                    // When the page resumes, the head tag will be found in the middle of the chunk.\r\n                    // Where we just need to append the insertion and chunk to the current stream.\r\n                    // e.g.\r\n                    // PPR-static: <head>...</head><body> [ resume content ] </body>\r\n                    // PPR-resume: [ insertion ] [ rest content ]\r\n                    if (insertion) {\r\n                        controller.enqueue(encoder.encode(insertion));\r\n                    }\r\n                    controller.enqueue(chunk);\r\n                    inserted = true;\r\n                }\r\n            }\r\n        },\r\n        async flush (controller) {\r\n            // Check before closing if there's anything remaining to insert.\r\n            if (hasBytes) {\r\n                const insertion = await insert();\r\n                if (insertion) {\r\n                    controller.enqueue(encoder.encode(insertion));\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction createClientResumeScriptInsertionTransformStream() {\r\n    const segmentPath = '/_full';\r\n    const cacheBustingHeader = computeCacheBustingSearchParam('1', '/_full', undefined, undefined //       headers[NEXT_URL]\r\n    );\r\n    const searchStr = `${NEXT_RSC_UNION_QUERY}=${cacheBustingHeader}`;\r\n    const NEXT_CLIENT_RESUME_SCRIPT = `<script>__NEXT_CLIENT_RESUME=fetch(location.pathname+'?${searchStr}',{credentials:'same-origin',headers:{'${RSC_HEADER}': '1','${NEXT_ROUTER_PREFETCH_HEADER}': '1','${NEXT_ROUTER_SEGMENT_PREFETCH_HEADER}': '${segmentPath}'}})</script>`;\r\n    let didAlreadyInsert = false;\r\n    return new TransformStream({\r\n        transform (chunk, controller) {\r\n            if (didAlreadyInsert) {\r\n                // Already inserted the script into the head. Pass through.\r\n                controller.enqueue(chunk);\r\n                return;\r\n            }\r\n            // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.\r\n            const headClosingTagIndex = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD);\r\n            if (headClosingTagIndex === -1) {\r\n                // In fully static rendering or non PPR rendering cases:\r\n                // `/head>` will always be found in the chunk in first chunk rendering.\r\n                controller.enqueue(chunk);\r\n                return;\r\n            }\r\n            const encodedInsertion = encoder.encode(NEXT_CLIENT_RESUME_SCRIPT);\r\n            // Get the total count of the bytes in the chunk and the insertion\r\n            // e.g.\r\n            // chunk = <head><meta charset=\"utf-8\"></head>\r\n            // insertion = <script>...</script>\r\n            // output = <head><meta charset=\"utf-8\"> [ <script>...</script> ] </head>\r\n            const insertedHeadContent = new Uint8Array(chunk.length + encodedInsertion.length);\r\n            // Append the first part of the chunk, before the head tag\r\n            insertedHeadContent.set(chunk.slice(0, headClosingTagIndex));\r\n            // Append the server inserted content\r\n            insertedHeadContent.set(encodedInsertion, headClosingTagIndex);\r\n            // Append the rest of the chunk\r\n            insertedHeadContent.set(chunk.slice(headClosingTagIndex), headClosingTagIndex + encodedInsertion.length);\r\n            controller.enqueue(insertedHeadContent);\r\n            didAlreadyInsert = true;\r\n        }\r\n    });\r\n}\r\n// Suffix after main body content - scripts before </body>,\r\n// but wait for the major chunks to be enqueued.\r\nfunction createDeferredSuffixStream(suffix) {\r\n    let flushed = false;\r\n    let pending;\r\n    const flush = (controller)=>{\r\n        const detached = new DetachedPromise();\r\n        pending = detached;\r\n        scheduleImmediate(()=>{\r\n            try {\r\n                controller.enqueue(encoder.encode(suffix));\r\n            } catch  {\r\n            // If an error occurs while enqueuing it can't be due to this\r\n            // transformers fault. It's likely due to the controller being\r\n            // errored due to the stream being cancelled.\r\n            } finally{\r\n                pending = undefined;\r\n                detached.resolve();\r\n            }\r\n        });\r\n    };\r\n    return new TransformStream({\r\n        transform (chunk, controller) {\r\n            controller.enqueue(chunk);\r\n            // If we've already flushed, we're done.\r\n            if (flushed) return;\r\n            // Schedule the flush to happen.\r\n            flushed = true;\r\n            flush(controller);\r\n        },\r\n        flush (controller) {\r\n            if (pending) return pending.promise;\r\n            if (flushed) return;\r\n            // Flush now.\r\n            controller.enqueue(encoder.encode(suffix));\r\n        }\r\n    });\r\n}\r\nfunction createFlightDataInjectionTransformStream(stream, delayDataUntilFirstHtmlChunk) {\r\n    let htmlStreamFinished = false;\r\n    let pull = null;\r\n    let donePulling = false;\r\n    function startOrContinuePulling(controller) {\r\n        if (!pull) {\r\n            pull = startPulling(controller);\r\n        }\r\n        return pull;\r\n    }\r\n    async function startPulling(controller) {\r\n        const reader = stream.getReader();\r\n        if (delayDataUntilFirstHtmlChunk) {\r\n            // NOTE: streaming flush\r\n            // We are buffering here for the inlined data stream because the\r\n            // \"shell\" stream might be chunkenized again by the underlying stream\r\n            // implementation, e.g. with a specific high-water mark. To ensure it's\r\n            // the safe timing to pipe the data stream, this extra tick is\r\n            // necessary.\r\n            // We don't start reading until we've left the current Task to ensure\r\n            // that it's inserted after flushing the shell. Note that this implementation\r\n            // might get stale if impl details of Fizz change in the future.\r\n            await atLeastOneTask();\r\n        }\r\n        try {\r\n            while(true){\r\n                const { done, value } = await reader.read();\r\n                if (done) {\r\n                    donePulling = true;\r\n                    return;\r\n                }\r\n                // We want to prioritize HTML over RSC data.\r\n                // The SSR render is based on the same RSC stream, so when we get a new RSC chunk,\r\n                // we're likely to produce an HTML chunk as well, so give it a chance to flush first.\r\n                if (!delayDataUntilFirstHtmlChunk && !htmlStreamFinished) {\r\n                    await atLeastOneTask();\r\n                }\r\n                controller.enqueue(value);\r\n            }\r\n        } catch (err) {\r\n            controller.error(err);\r\n        }\r\n    }\r\n    return new TransformStream({\r\n        start (controller) {\r\n            if (!delayDataUntilFirstHtmlChunk) {\r\n                startOrContinuePulling(controller);\r\n            }\r\n        },\r\n        transform (chunk, controller) {\r\n            controller.enqueue(chunk);\r\n            // Start the streaming if it hasn't already been started yet.\r\n            if (delayDataUntilFirstHtmlChunk) {\r\n                startOrContinuePulling(controller);\r\n            }\r\n        },\r\n        flush (controller) {\r\n            htmlStreamFinished = true;\r\n            if (donePulling) {\r\n                return;\r\n            }\r\n            return startOrContinuePulling(controller);\r\n        }\r\n    });\r\n}\r\nconst CLOSE_TAG = '</body></html>';\r\n/**\r\n * This transform stream moves the suffix to the end of the stream, so results\r\n * like `</body></html><script>...</script>` will be transformed to\r\n * `<script>...</script></body></html>`.\r\n */ function createMoveSuffixStream() {\r\n    let foundSuffix = false;\r\n    return new TransformStream({\r\n        transform (chunk, controller) {\r\n            if (foundSuffix) {\r\n                return controller.enqueue(chunk);\r\n            }\r\n            const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML);\r\n            if (index > -1) {\r\n                foundSuffix = true;\r\n                // If the whole chunk is the suffix, then don't write anything, it will\r\n                // be written in the flush.\r\n                if (chunk.length === ENCODED_TAGS.CLOSED.BODY_AND_HTML.length) {\r\n                    return;\r\n                }\r\n                // Write out the part before the suffix.\r\n                const before = chunk.slice(0, index);\r\n                controller.enqueue(before);\r\n                // In the case where the suffix is in the middle of the chunk, we need\r\n                // to split the chunk into two parts.\r\n                if (chunk.length > ENCODED_TAGS.CLOSED.BODY_AND_HTML.length + index) {\r\n                    // Write out the part after the suffix.\r\n                    const after = chunk.slice(index + ENCODED_TAGS.CLOSED.BODY_AND_HTML.length);\r\n                    controller.enqueue(after);\r\n                }\r\n            } else {\r\n                controller.enqueue(chunk);\r\n            }\r\n        },\r\n        flush (controller) {\r\n            // Even if we didn't find the suffix, the HTML is not valid if we don't\r\n            // add it, so insert it at the end.\r\n            controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML);\r\n        }\r\n    });\r\n}\r\nfunction createStripDocumentClosingTagsTransform() {\r\n    return new TransformStream({\r\n        transform (chunk, controller) {\r\n            // We rely on the assumption that chunks will never break across a code unit.\r\n            // This is reasonable because we currently concat all of React's output from a single\r\n            // flush into one chunk before streaming it forward which means the chunk will represent\r\n            // a single coherent utf-8 string. This is not safe to use if we change our streaming to no\r\n            // longer do this large buffered chunk\r\n            if (isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML) || isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY) || isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.HTML)) {\r\n                // the entire chunk is the closing tags; return without enqueueing anything.\r\n                return;\r\n            }\r\n            // We assume these tags will go at together at the end of the document and that\r\n            // they won't appear anywhere else in the document. This is not really a safe assumption\r\n            // but until we revamp our streaming infra this is a performant way to string the tags\r\n            chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY);\r\n            chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.HTML);\r\n            controller.enqueue(chunk);\r\n        }\r\n    });\r\n}\r\n/*\r\n * Checks if the root layout is missing the html or body tags\r\n * and if so, it will inject a script tag to throw an error in the browser, showing the user\r\n * the error message in the error overlay.\r\n */ export function createRootLayoutValidatorStream() {\r\n    let foundHtml = false;\r\n    let foundBody = false;\r\n    return new TransformStream({\r\n        async transform (chunk, controller) {\r\n            // Peek into the streamed chunk to see if the tags are present.\r\n            if (!foundHtml && indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.HTML) > -1) {\r\n                foundHtml = true;\r\n            }\r\n            if (!foundBody && indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.BODY) > -1) {\r\n                foundBody = true;\r\n            }\r\n            controller.enqueue(chunk);\r\n        },\r\n        flush (controller) {\r\n            const missingTags = [];\r\n            if (!foundHtml) missingTags.push('html');\r\n            if (!foundBody) missingTags.push('body');\r\n            if (!missingTags.length) return;\r\n            controller.enqueue(encoder.encode(`<html id=\"__next_error__\">\r\n            <template\r\n              data-next-error-message=\"Missing ${missingTags.map((c)=>`<${c}>`).join(missingTags.length > 1 ? ' and ' : '')} tags in the root layout.\\nRead more at https://nextjs.org/docs/messages/missing-root-layout-tags\"\r\n              data-next-error-digest=\"${MISSING_ROOT_TAGS_ERROR}\"\r\n              data-next-error-stack=\"\"\r\n            ></template>\r\n          `));\r\n        }\r\n    });\r\n}\r\nfunction chainTransformers(readable, transformers) {\r\n    let stream = readable;\r\n    for (const transformer of transformers){\r\n        if (!transformer) continue;\r\n        stream = stream.pipeThrough(transformer);\r\n    }\r\n    return stream;\r\n}\r\nexport async function continueFizzStream(renderStream, { suffix, inlinedDataStream, isStaticGeneration, isBuildTimePrerendering, buildId, getServerInsertedHTML, getServerInsertedMetadata, validateRootLayout }) {\r\n    // Suffix itself might contain close tags at the end, so we need to split it.\r\n    const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null;\r\n    // If we're generating static HTML we need to wait for it to resolve before continuing.\r\n    if (isStaticGeneration) {\r\n        await renderStream.allReady;\r\n    }\r\n    return chainTransformers(renderStream, [\r\n        // Buffer everything to avoid flushing too frequently\r\n        createBufferedTransformStream(),\r\n        // Add build id comment to start of the HTML document (in export mode)\r\n        createPrefetchCommentStream(isBuildTimePrerendering, buildId),\r\n        // Transform metadata\r\n        createMetadataTransformStream(getServerInsertedMetadata),\r\n        // Insert suffix content\r\n        suffixUnclosed != null && suffixUnclosed.length > 0 ? createDeferredSuffixStream(suffixUnclosed) : null,\r\n        // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\r\n        inlinedDataStream ? createFlightDataInjectionTransformStream(inlinedDataStream, true) : null,\r\n        // Validate the root layout for missing html or body tags\r\n        validateRootLayout ? createRootLayoutValidatorStream() : null,\r\n        // Close tags should always be deferred to the end\r\n        createMoveSuffixStream(),\r\n        // Special head insertions\r\n        // TODO-APP: Insert server side html to end of head in app layout rendering, to avoid\r\n        // hydration errors. Remove this once it's ready to be handled by react itself.\r\n        createHeadInsertionTransformStream(getServerInsertedHTML)\r\n    ]);\r\n}\r\nexport async function continueDynamicPrerender(prerenderStream, { getServerInsertedHTML, getServerInsertedMetadata }) {\r\n    return prerenderStream// Buffer everything to avoid flushing too frequently\r\n    .pipeThrough(createBufferedTransformStream()).pipeThrough(createStripDocumentClosingTagsTransform())// Insert generated tags to head\r\n    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))// Transform metadata\r\n    .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata));\r\n}\r\nexport async function continueStaticPrerender(prerenderStream, { inlinedDataStream, getServerInsertedHTML, getServerInsertedMetadata, isBuildTimePrerendering, buildId }) {\r\n    return prerenderStream// Buffer everything to avoid flushing too frequently\r\n    .pipeThrough(createBufferedTransformStream())// Add build id comment to start of the HTML document (in export mode)\r\n    .pipeThrough(createPrefetchCommentStream(isBuildTimePrerendering, buildId))// Insert generated tags to head\r\n    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))// Transform metadata\r\n    .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))// Insert the inlined data (Flight data, form state, etc.) stream into the HTML\r\n    .pipeThrough(createFlightDataInjectionTransformStream(inlinedDataStream, true))// Close tags should always be deferred to the end\r\n    .pipeThrough(createMoveSuffixStream());\r\n}\r\nexport async function continueStaticFallbackPrerender(prerenderStream, { inlinedDataStream, getServerInsertedHTML, getServerInsertedMetadata, isBuildTimePrerendering, buildId }) {\r\n    // Same as `continueStaticPrerender`, but also inserts an additional script\r\n    // to instruct the client to start fetching the hydration data as early\r\n    // as possible.\r\n    return prerenderStream// Buffer everything to avoid flushing too frequently\r\n    .pipeThrough(createBufferedTransformStream())// Add build id comment to start of the HTML document (in export mode)\r\n    .pipeThrough(createPrefetchCommentStream(isBuildTimePrerendering, buildId))// Insert generated tags to head\r\n    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))// Insert the client resume script into the head\r\n    .pipeThrough(createClientResumeScriptInsertionTransformStream())// Transform metadata\r\n    .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))// Insert the inlined data (Flight data, form state, etc.) stream into the HTML\r\n    .pipeThrough(createFlightDataInjectionTransformStream(inlinedDataStream, true))// Close tags should always be deferred to the end\r\n    .pipeThrough(createMoveSuffixStream());\r\n}\r\nexport async function continueDynamicHTMLResume(renderStream, { delayDataUntilFirstHtmlChunk, inlinedDataStream, getServerInsertedHTML, getServerInsertedMetadata }) {\r\n    return renderStream// Buffer everything to avoid flushing too frequently\r\n    .pipeThrough(createBufferedTransformStream())// Insert generated tags to head\r\n    .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))// Transform metadata\r\n    .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))// Insert the inlined data (Flight data, form state, etc.) stream into the HTML\r\n    .pipeThrough(createFlightDataInjectionTransformStream(inlinedDataStream, delayDataUntilFirstHtmlChunk))// Close tags should always be deferred to the end\r\n    .pipeThrough(createMoveSuffixStream());\r\n}\r\nexport function createDocumentClosingStream() {\r\n    return streamFromString(CLOSE_TAG);\r\n}\r\n\r\n//# sourceMappingURL=node-web-streams-helper.js.map","/**\r\n * This file provides some helpers that should be used in conjunction with\r\n * explicit environment checks. When combined with the environment checks, it\r\n * will ensure that the correct typings are used as well as enable code\r\n * elimination.\r\n */ /**\r\n * Type guard to determine if a request is a WebNextRequest. This does not\r\n * actually check the type of the request, but rather the runtime environment.\r\n * It's expected that when the runtime environment is the edge runtime, that any\r\n * base request is a WebNextRequest.\r\n */ export const isWebNextRequest = (req)=>process.env.NEXT_RUNTIME === 'edge';\r\n/**\r\n * Type guard to determine if a response is a WebNextResponse. This does not\r\n * actually check the type of the response, but rather the runtime environment.\r\n * It's expected that when the runtime environment is the edge runtime, that any\r\n * base response is a WebNextResponse.\r\n */ export const isWebNextResponse = (res)=>process.env.NEXT_RUNTIME === 'edge';\r\n/**\r\n * Type guard to determine if a request is a NodeNextRequest. This does not\r\n * actually check the type of the request, but rather the runtime environment.\r\n * It's expected that when the runtime environment is the node runtime, that any\r\n * base request is a NodeNextRequest.\r\n */ export const isNodeNextRequest = (req)=>process.env.NEXT_RUNTIME !== 'edge';\r\n/**\r\n * Type guard to determine if a response is a NodeNextResponse. This does not\r\n * actually check the type of the response, but rather the runtime environment.\r\n * It's expected that when the runtime environment is the node runtime, that any\r\n * base response is a NodeNextResponse.\r\n */ export const isNodeNextResponse = (res)=>process.env.NEXT_RUNTIME !== 'edge';\r\n\r\n//# sourceMappingURL=helpers.js.map","// Format function modified from nodejs\r\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\nimport * as querystring from './querystring';\r\nconst slashedProtocols = /https?|ftp|gopher|file/;\r\nexport function formatUrl(urlObj) {\r\n    let { auth, hostname } = urlObj;\r\n    let protocol = urlObj.protocol || '';\r\n    let pathname = urlObj.pathname || '';\r\n    let hash = urlObj.hash || '';\r\n    let query = urlObj.query || '';\r\n    let host = false;\r\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';\r\n    if (urlObj.host) {\r\n        host = auth + urlObj.host;\r\n    } else if (hostname) {\r\n        host = auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname);\r\n        if (urlObj.port) {\r\n            host += ':' + urlObj.port;\r\n        }\r\n    }\r\n    if (query && typeof query === 'object') {\r\n        query = String(querystring.urlQueryToSearchParams(query));\r\n    }\r\n    let search = urlObj.search || query && `?${query}` || '';\r\n    if (protocol && !protocol.endsWith(':')) protocol += ':';\r\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\r\n        host = '//' + (host || '');\r\n        if (pathname && pathname[0] !== '/') pathname = '/' + pathname;\r\n    } else if (!host) {\r\n        host = '';\r\n    }\r\n    if (hash && hash[0] !== '#') hash = '#' + hash;\r\n    if (search && search[0] !== '?') search = '?' + search;\r\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\r\n    search = search.replace('#', '%23');\r\n    return `${protocol}${host}${pathname}${search}${hash}`;\r\n}\r\nexport const urlObjectKeys = [\r\n    'auth',\r\n    'hash',\r\n    'host',\r\n    'hostname',\r\n    'href',\r\n    'path',\r\n    'pathname',\r\n    'port',\r\n    'protocol',\r\n    'query',\r\n    'search',\r\n    'slashes'\r\n];\r\nexport function formatWithValidation(url) {\r\n    if (process.env.NODE_ENV === 'development') {\r\n        if (url !== null && typeof url === 'object') {\r\n            Object.keys(url).forEach((key)=>{\r\n                if (!urlObjectKeys.includes(key)) {\r\n                    console.warn(`Unknown key passed via urlObject into url.format: ${key}`);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    return formatUrl(url);\r\n}\r\n\r\n//# sourceMappingURL=format-url.js.map"],"names":["process","env","NEXT_RUNTIME","module","exports","require","NODE_ENV","TURBOPACK","RouteKind","hoist","name","then","mod","undefined"],"mappings":"gCAWMG,EAAOC,OAAO,CAAGC,EAAQ,CAAA,CAAA,IAAA,0BCXxB,MAAWG,GAGf,CAHeA,MAwBjB,AArBE,EAHeA,AAGf,CAHeA,EAGf,CAAA,OAHeA,CAOf,EAAA,AAPeA,OAOf,EAAA,CAAA,YAKA,EAAA,OAAA,CAAA,CAAA,WAKA,EAAA,OAAA,EAAA,CAAA,YAKA,EAAA,KAAA,CAAA,CAAA,OAtBeA,qECOX,SAASC,EAAMN,CAAW,CAAEO,CAAY,SAEzCA,AAAJ,KAAYP,EACHA,CAAM,CAACO,EAAK,CAKjB,CANgB,QAMNP,GAAiC,YAAvB,AAAmC,OAA5BA,EAAOQ,IAAI,CACjCR,EAAOQ,IAAI,CAAEC,AAAD,GAAcH,EAAMG,EAAKF,IAKxB,YAAlB,OAAOP,GAAkC,WAAW,CAApBO,EAC3BP,QAKX,kCC1BA,IAAI,EAAY,OAAO,cAAc,CACjC,EAAmB,OAAO,wBAAwB,CAClD,EAAoB,OAAO,mBAAmB,CAC9C,EAAe,OAAO,SAAS,CAAC,cAAc,CAgB9C,EAAc,CAAC,EAfK,EAgBF,CACpB,eAAgB,IAAM,EACtB,gBAAiB,IAAM,EACvB,YAAa,IAAM,EACnB,eAAgB,IAAM,EACtB,gBAAiB,IAAM,CACzB,EArBE,IAAK,IAAI,KAAQ,EACf,EAcK,EAda,EAAM,CAAE,GAAhB,CAAqB,CAAG,CAAC,EAAK,CAAE,YAAY,CAAK,GAwB/D,SAAS,EAAgB,CAAC,EACxB,IAAI,EACJ,IAAM,EAAQ,CACZ,SAAU,GAAK,EAAE,IAAI,EAAI,CAAC,KAAK,EAAE,EAAE,IAAI,CAAA,CAAE,CACzC,YAAa,IAAM,CAAD,CAAG,OAAO,MAAI,EAAE,OAAO,AAAK,CAAC,EAAK,CAAC,QAAQ,EAAE,CAAsB,UAArB,OAAO,EAAE,OAAO,CAAgB,IAAI,KAAK,EAAE,OAAO,EAAI,EAAE,OAAA,AAAO,EAAE,WAAW,GAAA,CAAI,CAChJ,WAAY,GAAyB,UAApB,OAAO,EAAE,MAAM,EAAiB,CAAC,QAAQ,EAAE,EAAE,MAAM,CAAA,CAAE,CACtE,WAAY,GAAK,EAAE,MAAM,EAAI,CAAC,OAAO,EAAE,EAAE,MAAM,CAAA,CAAE,CACjD,WAAY,GAAK,EAAE,MAAM,EAAI,SAC7B,aAAc,GAAK,EAAE,QAAQ,EAAI,WACjC,aAAc,GAAK,EAAE,QAAQ,EAAI,CAAC,SAAS,EAAE,EAAE,QAAQ,CAAA,CAAE,CACzD,gBAAiB,GAAK,EAAE,WAAW,EAAI,cACvC,aAAc,GAAK,EAAE,QAAQ,EAAI,CAAC,SAAS,EAAE,EAAE,QAAQ,CAAA,CAAE,CAC1D,CAAC,MAAM,CAAC,SACH,EAAc,CAAA,EAAG,EAAE,IAAI,CAAC,CAAC,EAAE,mBAAmB,AAAkB,OAAjB,EAAK,EAAE,KAAA,AAAK,EAAY,EAAK,IAAA,CAAK,CACvF,OAAO,AAAiB,MAAX,MAAM,CAAS,EAAc,CAAA,EAAG,EAAY,EAAE,EAAE,EAAM,IAAI,CAAC,MAAA,CAAO,AACjF,CACA,SAAS,EAAY,CAAM,EACzB,IAAM,EAAsB,IAAhB,AAAoB,IAChC,IAAK,IAAM,CADc,IACN,EAAO,KAAK,CAAC,OAAQ,CACtC,GAAI,CAAC,EACH,SACF,IAAM,EAAU,EAAK,OAAO,CAAC,KAC7B,GAAgB,CAAC,IAAb,EAAgB,CAClB,EAAI,GAAG,CAAC,EAAM,QACd,QACF,CACA,GAAM,CAAC,EAAK,EAAM,CAAG,CAAC,EAAK,KAAK,CAAC,EAAG,GAAU,EAAK,KAAK,CAAC,EAAU,GAAG,CACtE,GAAI,CACF,EAAI,GAAG,CAAC,EAAK,mBAA4B,MAAT,EAAgB,EAAQ,QAC1D,CAAE,KAAM,CACR,CACF,CACA,OAAO,CACT,CACA,SAAS,EAAe,CAAS,EAC/B,GAAI,CAAC,EACH,OAAO,AAET,EAHgB,CAGV,CAAC,CAFO,AAEN,EAAM,EAAM,CAAE,GAAG,EAAW,CAAG,EAAY,GAC7C,QACJ,CAAM,SACN,CAAO,UACP,CAAQ,QACR,CAAM,MACN,CAAI,UACJ,CAAQ,QACR,CAAM,aACN,CAAW,UACX,CAAQ,CACT,CAAG,OAAO,WAAW,CACpB,EAAW,GAAG,CAAC,CAAC,CAAC,EAAK,EAAO,GAAK,CAChC,EAAI,WAAW,GAAG,OAAO,CAAC,KAAM,IAChC,EACD,EAeI,QAAQ,AAiBM,EAfN,CAAC,CAfD,EA8BY,IA7BzB,EACA,MAAO,mBAAmB,UAC1B,EACA,GAAG,GAAW,CAAE,QAAS,IAAI,KAAK,EAAS,CAAC,CAC5C,GAAG,GAAY,CAAE,UAAU,CAAK,CAAC,CACjC,GAAqB,UAAlB,OAAO,GAAuB,CAAE,OAAQ,OAAO,EAAQ,CAAC,MAC3D,EACA,GAAG,GAAY,CAAE,QAAA,CAmBZ,CAnBsB,CAmBZ,QAAQ,CADzB,AAC0B,EADjB,CADY,EAjBsB,GAkB3B,CADW,UACA,IACS,EAAS,KAAK,CAnBG,CAAC,CACpD,GAAG,GAAU,CAAE,QAAQ,CAAK,CAAC,CAC7B,GAAG,GAAY,CAAE,QAAA,CAsBZ,CAtBsB,CAsBb,QAAQ,CAAC,AADzB,EAAS,GArBkC,GAqB3B,WAAW,IACQ,EAAS,KAAK,CAtBI,CAAC,CACpD,GAAG,GAAe,CAAE,YAAa,EAAK,CAAC,AACzC,EAIA,IAAM,EAAO,CAAC,EACd,IAAK,IAAM,KAAO,EAAG,AACf,CAAC,CAAC,EAAI,EACR,AADU,EACN,CAAC,EAAI,CAAG,CAAC,CAAC,EAAA,AAAI,EAGtB,OAAO,CATQ,CACjB,CAxEA,EAAO,OAAO,CAXc,CARV,CAAC,AAmBF,EAnBM,EAAM,EAAQ,KACnC,GAAI,GAAwB,UAAhB,OAAO,GAAqC,YAAhB,AAA4B,OAArB,EAC7C,IAAK,IAAI,KAAO,EAAkB,GAC5B,AAAC,EAAa,CAAlB,GAAsB,CAAC,EAAI,IAAQ,IAAQ,GACzC,EAAU,EAAI,EAAK,CAAE,IAAK,IAAM,CAAI,CAAC,EAAI,CAAE,WAAY,CAAC,CAAC,EAAO,EAAiB,EAAM,EAAA,CAAI,EAAK,EAAK,UAAU,AAAC,GAEtH,OAAO,EACT,EACwC,EAAU,CAAC,EAAG,aAAc,CAAE,OAAO,CAAK,GAWpD,CAXwD,EA6FtF,IAAI,EAAY,CAAC,SAAU,MAAO,OAAO,CAKrC,EAAW,CAAC,MAAO,SAAU,OAAO,CA0DpC,EAAiB,MACnB,YAAY,CAAc,CAAE,CAE1B,IAAI,CAAC,OAAO,CAAmB,EAAhB,EAAoB,IACnC,IAAI,CAAC,EADuB,MACf,CAAG,EAChB,MAAM,EAAS,EAAe,GAAG,CAAC,UAClC,GAAI,EAEF,IAAK,EAFK,GAEC,CAAC,EAAM,EAAM,GADT,CACa,CADD,GAEzB,GADkC,CAC9B,CAAC,OAAO,CAAC,GAAG,CAAC,EAAM,MAAE,QAAM,CAAM,EAG3C,CACA,CAAC,OAAO,QAAQ,CAAC,EAAG,CAClB,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO,QAAQ,CAAC,EACtC,CAIA,IAAI,MAAO,CACT,OAAO,IAAI,CAAC,OAAO,CAAC,IACtB,AAD0B,CAE1B,IAAI,GAAG,CAAI,CAAE,CACX,IAAM,EAA0B,UAAnB,OAAO,CAAI,CAAC,EAAE,CAAgB,CAAI,CAAC,EAAE,CAAG,CAAI,CAAC,EAAE,CAAC,IAAI,CACjE,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAC1B,CACA,OAAO,GAAG,CAAI,CAAE,CACd,IAAI,EACJ,IAAM,EAAM,MAAM,IAAI,CAAC,IAAI,CAAC,OAAO,EACnC,GAAI,CAAC,EAAK,MAAM,CACd,CADgB,MACT,EAAI,GAAG,CAAC,CAAC,CAAC,EAAG,EAAM,GAAK,GAEjC,IAAM,EAAO,AAAmB,iBAAZ,CAAI,CAAC,EAAE,CAAgB,CAAI,CAAC,EAAE,CAAG,AAAkB,OAAjB,EAAK,CAAI,CAAC,EAAA,AAAE,EAAY,KAAK,EAAI,EAAG,IAAI,CAC9F,OAAO,EAAI,MAAM,CAAC,CAAC,CAAC,EAAE,GAAK,IAAM,GAAM,GAAG,CAAC,CAAC,CAAC,EAAG,EAAM,GAAK,EAC7D,CACA,IAAI,CAAI,CAAE,CACR,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAC1B,CACA,IAAI,GAAG,CAAI,CAAE,CACX,GAAM,CAAC,EAAM,EAAM,CAAG,AAAgB,MAAX,MAAM,CAAS,CAAC,CAAI,CAAC,EAAE,CAAC,IAAI,CAAE,CAAI,CAAC,EAAE,CAAC,KAAK,CAAC,CAAG,EACpE,EAAM,IAAI,CAAC,OAAO,CAMxB,OALA,EAAI,GAAG,CAAC,EAAM,MAAE,QAAM,CAAM,GAC5B,IAAI,CAAC,QAAQ,CAAC,GAAG,CACf,SACA,MAAM,IAAI,CAAC,GAAK,GAAG,CAAC,CAAC,CAAC,EAAG,EAAO,GAAK,EAAgB,IAAS,IAAI,CAAC,OAE9D,IAAI,AACb,CAIA,OAAO,CAAK,CAAE,CACZ,IAAM,EAAM,IAAI,CAAC,OAAO,CAClB,EAAS,AAAC,MAAM,OAAO,CAAC,GAA6B,EAAM,GAAG,CAAC,AAAC,GAAS,EAAI,MAAM,CAAC,IAAnD,EAAI,MAAM,CAAC,GAKlD,OAJA,IAAI,CAAC,QAAQ,CAAC,GAAG,CACf,SACA,MAAM,IAAI,CAAC,GAAK,GAAG,CAAC,CAAC,CAAC,EAAG,EAAM,GAAK,EAAgB,IAAQ,IAAI,CAAC,OAE5D,CACT,CAIA,OAAQ,CAEN,OADA,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,KACjC,IAAI,AACb,CAIA,CAAC,OAAO,GAAG,CAAC,+BAA+B,EAAG,CAC5C,MAAO,CAAC,eAAe,EAAE,KAAK,SAAS,CAAC,OAAO,WAAW,CAAC,IAAI,CAAC,OAAO,GAAA,CAAI,AAC7E,CACA,UAAW,CACT,MAAO,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,GAAG,CAAC,AAAC,GAAM,CAAA,EAAG,EAAE,IAAI,CAAC,CAAC,EAAE,mBAAmB,EAAE,KAAK,EAAA,CAAG,EAAE,IAAI,CAAC,KAChG,CACF,EAGI,EAAkB,MACpB,YAAY,CAAe,CAAE,KAGvB,EAAI,EAAI,EADZ,IAAI,CAAC,OAAO,CAAmB,EAAhB,EAAoB,IAEnC,IAAI,CAAC,EAFuB,MAEf,CAAG,EAChB,MAAM,EAA8J,AAAlJ,OAAC,EAAK,AAA0F,OAAzF,EAAK,AAAuC,OAAtC,EAAK,EAAgB,YAAY,AAAZ,EAAwB,KAAK,EAAI,EAAG,IAAI,CAAC,EAAA,CAAgB,CAAY,EAAK,EAAgB,GAAG,CAAC,aAAA,CAAa,CAAY,EAAK,EAAE,CAElL,IAAK,MAAM,KADW,MAAM,KACD,EADQ,CAAC,GAAa,EA3IrD,AA2IiE,SA3IxD,AAAmB,CAAa,EACvC,GAAI,CAAC,EACH,MAAO,EAAE,CACX,IAEI,EACA,EACA,EACA,EACA,EANA,EAAiB,EAAE,CACnB,EAAM,EAMV,SAAS,IACP,KAAO,EAAM,EAAc,MAAM,EAAI,KAAK,IAAI,CAAC,EAAc,MAAM,CAAC,KAClE,CADyE,EAClE,EAET,OAAO,EAAM,EAAc,MAC7B,AADmC,CAMnC,KAAO,EAAM,EAAc,MAAM,EAAE,CAGjC,IAFA,EAAQ,EACR,GAAwB,EACjB,KAEL,GAAI,AAAO,OADX,EADuB,AAClB,EAAc,MAAM,CAAC,EAAA,EACV,CAKd,IAJA,EAAY,EACZ,GAAO,EACP,IACA,EAAY,EACL,EAAM,EAAc,MAAM,EAZ9B,AAAO,EAY2B,KAbzC,EAAK,EAAc,MAAM,CAAC,CAaiC,CAbjC,GACE,MAAP,GAAqB,MAAP,GAa7B,GAAO,EAEL,EAAM,EAAc,MAAM,EAAkC,KAAK,CAAnC,EAAc,MAAM,CAAC,IACrD,GAAwB,EACxB,EAAM,EACN,EAAe,IAAI,CAAC,EAAc,SAAS,CAAC,EAAO,IACnD,EAAQ,GAER,EAAM,EAAY,CAEtB,MACE,CADK,EACE,GAGP,CAAC,GAAyB,GAAO,EAAc,MAAA,AAAM,EAAE,CACzD,EAAe,IAAI,CAAC,EAAc,SAAS,CAAC,EAAO,EAAc,MAAM,EAE3E,CACA,OAAO,CACT,EAyFoF,GACtC,CACxC,MAAM,EAAS,EAAe,GAC1B,GACF,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAO,IAAI,CAAE,EAClC,CACF,CAIA,IAAI,GAAG,CAAI,CAAE,CACX,IAAM,EAAyB,UAAnB,OAAO,CAAI,CAAC,EAAE,CAAgB,CAAI,CAAC,EAAE,CAAG,CAAI,CAAC,EAAE,CAAC,IAAI,CAChE,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAC1B,CAIA,OAAO,GAAG,CAAI,CAAE,CACd,IAAI,EACJ,IAAM,EAAM,MAAM,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,IAC1C,GAAI,CAAC,EAAK,MAAM,CACd,CADgB,MACT,EAET,IAAM,EAAyB,UAAnB,OAAO,CAAI,CAAC,EAAE,CAAgB,CAAI,CAAC,EAAE,CAAG,AAAkB,OAAjB,EAAK,CAAI,CAAC,EAAE,AAAF,EAAc,KAAK,EAAI,EAAG,IAAI,CAC7F,OAAO,EAAI,MAAM,CAAC,AAAC,GAAM,EAAE,IAAI,GAAK,EACtC,CACA,IAAI,CAAI,CAAE,CACR,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAC1B,CAIA,IAAI,GAAG,CAAI,CAAE,CACX,GAAM,CAAC,EAAM,EAAO,EAAO,CAAmB,IAAhB,EAAK,MAAM,CAAS,CAAC,CAAI,CAAC,EAAE,CAAC,IAAI,CAAE,CAAI,CAAC,EAAE,CAAC,KAAK,CAAE,CAAI,CAAC,EAAE,CAAC,CAAG,EACrF,EAAM,IAAI,CAAC,OAAO,CAGxB,OAFA,EAAI,GAAG,CAAC,EAAM,AAyBlB,SAAS,AAAgB,EAAS,CAAE,KAAM,GAAI,MAAO,EAAG,CAAC,EAUvD,MAT8B,UAA1B,AAAoC,OAA7B,EAAO,OAAO,GACvB,EAAO,OAAO,CAAG,IAAI,KAAK,EAAO,OAAO,GAEtC,EAAO,MAAM,EAAE,CACjB,EAAO,OAAO,CAAG,IAAI,KAAK,KAAK,GAAG,GAAK,AAAgB,MAAT,MAAM,CAAG,GAErC,OAAhB,EAAO,IAAI,EAAa,AAAgB,WAAT,IAAI,AAAU,GAAG,CAClD,EAAO,IAAI,CAAG,GAAA,EAET,CACT,EApCkC,MAAE,QAAM,EAAO,GAAG,CAAM,AAAC,IAkB3D,AAjBI,SAiBK,AAAQ,CAAG,CAAE,CAAO,EAE3B,IAAK,GAAM,EAAG,EAAM,GADpB,EAAQ,MAAM,CAAC,cACS,GAAK,CAC3B,IAAM,EAAa,EAAgB,GACnC,EAAQ,MAAM,CAAC,aAAc,EAC/B,CACF,EAvBY,EAAK,IAAI,CAAC,QAAQ,EACnB,IAAI,AACb,CAIA,OAAO,GAAG,CAAI,CAAE,CACd,GAAM,CAAC,EAAM,EAAQ,CAAsB,UAAnB,OAAO,CAAI,CAAC,EAAE,CAAgB,CAAC,CAAI,CAAC,EAAE,CAAC,CAAG,CAAC,CAAI,CAAC,EAAE,CAAC,IAAI,CAAE,CAAI,CAAC,EAAE,CAAC,CACzF,OAAO,IAAI,CAAC,GAAG,CAAC,CAAE,GAAG,CAAO,MAAE,EAAM,MAAO,GAAI,QAAyB,CAAhB,GAAoB,KAAK,EAAG,EACtF,CADuE,AAEvE,CAAC,OAAO,GAAG,CAAC,+BAA+B,EAAG,CAC5C,MAAO,CAAC,gBAAgB,EAAE,KAAK,SAAS,CAAC,OAAO,WAAW,CAAC,IAAI,CAAC,OAAO,GAAA,CAAI,AAC9E,CACA,UAAW,CACT,MAAO,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,GAAG,CAAC,GAAiB,IAAI,CAAC,KAC9D,CACF,mBCvTA,CAAC,KAAK,aAAa,IAAI,EAAE,CAAC,IAAI,IAO9B,IAAI,EAAE,iCAA2f,SAAS,EAAc,CAAC,EAAE,IAAI,EAAE,GAAG,KAAK,KAAK,CAAC,GAAG,MAAkB,UAAX,OAAO,EAAa,EAAE,GAAG,CAA3iB,EAAE,OAAO,CAAO,EAAN,OAAe,AAAM,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC,oBAAoB,CAAK,EAAE,CAAC,CAAC,gBAAgB,CAAC,GAAG,CAAC,GAAG,CAAC,EAAG,CAAD,MAAQ,EAAM,IAAI,EAAE,CAAC,CAAC,gBAAgB,CAAC,GAAG,GAAG,EAAE,IAAI,CAAC,GAAI,CAAD,MAAQ,EAAM,GAAG,GAAO,MAAJ,EAAQ,CAAC,IAAI,EAAE,CAAC,CAAC,IAAO,CAAC,GAAG,CAAC,EAAG,CAAD,MAAQ,EAAyC,IAAI,IAAnC,GAAE,EAAS,EAAE,AAA+T,SAAS,AAAe,CAAC,EAA2B,IAAI,IAAzB,EAAE,EAAM,EAAE,EAAE,CAAK,EAAE,EAAU,EAAE,EAAE,EAAE,EAAE,MAAM,CAAC,EAAE,EAAE,IAAI,AAAC,OAAO,EAAE,UAAU,CAAC,IAAI,KAAK,GAAM,IAAI,GAAE,CAAC,EAAE,EAAE,GAAE,EAAE,KAAM,MAAK,GAAG,EAAE,IAAI,CAAC,EAAE,SAAS,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,KAAM,SAAQ,EAAE,EAAE,CAAO,CAA2B,OAAzB,EAAE,IAAI,CAAC,EAAE,SAAS,CAAC,EAAE,IAAW,CAAC,EAAjiB,GAAW,EAAE,EAAE,EAAE,EAAE,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,GAAG,IAAI,GAAG,IAAI,KAAK,GAAG,KAAK,IAAI,EAAE,CAAC,GAAE,EAAM,KAAK,CAAC,CAAC,GAAG,EAAG,CAAD,MAAQ,CAAM,CAAC,GAAG,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,gBAAgB,CAAiD,GAA1C,CAA6C,AAA5C,GAA8C,AAA3C,CAAC,CAAC,EAAc,IAAI,EAAc,EAAA,CAAE,CAAQ,OAAO,CAAM,CAAC,OAAO,CAAI,CAAqU,CAAC,EAAM,EAAE,CAAC,EAAE,SAAS,EAAoB,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,QAAO,IAAJ,EAAe,KAAD,EAAQ,EAAE,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAM,EAAE,GAAK,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,OAAO,CAAC,GAAqB,GAAE,CAAK,QAAQ,CAAI,GAAE,OAAO,CAAC,CAAC,EAAE,CAAC,OAAO,EAAE,OAAO,CAA6C,EAAoB,EAAE,CAAC,+CAA6C,EAAO,OAAO,CAAvC,EAAoB,AAAoB,KAAC,CAAC,iBAApD,oKuBJvmC,EAgOM,EjBnOV,MJqBgD,EAKJ,EAQI,IAsCR,EAQG,IAWL,EAjEoB,EALQ,AAmDhB,EAgCN,EAtEsB,AAyDpB,CAXU,CchFD,EVAvD,EAAA,EAAA,CAAA,CAAA,EJwG0D,KAlGtD,GACA,AcPqE,CdM7B,EAc1C,GAAkB,CAAC,GAbF,IAAD,AADG,CAAqC,QACvB,CAAG,CADN,GAAG,uBAE/B,EAAe,GAAM,CAAG,QAAV,SACd,EAAe,IAAO,CAAG,OAAX,WACd,EAAe,YAAD,CAAiB,CAAG,2BAClC,EAAe,MAAS,CAAG,KAAb,eACd,EAAe,YAAD,kBAAkC,CAAG,4CACnD,EAAe,YAAD,IAAoB,CAAG,8BACrC,EAAe,YAAe,AAAhB,CAAmB,0BACjC,EAAe,WAAc,CAAG,AAAlB,yBACd,EAAe,YAAD,SAAyB,CAAG,mCAC1C,EAAe,YAAD,KAAqB,CAAG,+BACtC,EAAe,SAAY,CAAG,EAAhB,qBACP,GAEP,GACA,GAGF,GAAsB,CAAC,GAHF,QAAD,AADG,WAAW,GAAG,IACa,CAAG,4CACnD,EAAmB,cAAiB,CAAG,CAArB,+BACX,GAEP,GACA,GAMF,GAAkB,CAAC,GANF,IADE,AACH,WADc,EACO,CADJ,AACO,+BACtC,EAAe,YAAD,iBAAiC,CAAG,2CAClD,EAAe,SAAY,CAAG,EAAhB,qBACd,EAAe,YAAD,WAA2B,CAAG,qCAC5C,EAAe,YAAD,AAAgB,CAAG,4BAC1B,GAEP,GACA,GAgCF,GAAsB,CAAC,GAhCF,QADE,AACH,GAAe,CAAG,OADJ,GAAG,mBAEnC,EAAmB,UAAa,CAAG,KAAjB,uBAClB,EAAmB,gBAAD,GAAuB,CAAG,qCAC5C,EAAmB,gBAAD,MAA0B,CAAG,wCAC/C,EAAmB,gBAAD,KAAyB,CAAG,uCAC9C,EAAmB,gBAAD,IAAwB,CAAG,sCAC7C,EAAmB,gBAAD,MAA0B,CAAG,wCAC/C,EAAmB,gBAAD,IAAwB,CAAG,sCAC7C,EAAmB,gBAAD,GAAuB,CAAG,2CAC5C,EAAmB,gBAAD,AAAoB,CAAG,kCACzC,EAAmB,YAAe,CAAG,GAAnB,2BAClB,EAAmB,MAAS,CAAG,SAAb,eAClB,EAAmB,MAAS,CAAG,SAAb,eAClB,EAAmB,UAAa,CAAG,KAAjB,uBAClB,EAAmB,cAAiB,CAAG,CAArB,+BAClB,EAAmB,WAAc,CAAG,IAAlB,yBAClB,EAAmB,gBAAD,CAAqB,CAAG,mCAC1C,EAAmB,gBAAD,EAAsB,CAAG,oCAC3C,EAAmB,eAAkB,CAAnB,AAAsB,iCACxC,EAAmB,gBAAD,UAA8B,CAAG,4CACnD,EAAmB,gBAAD,CAAqB,CAAG,mCAC1C,EAAmB,YAAe,CAAG,GAAnB,2BAClB,EAAmB,WAAc,CAAG,IAAlB,yBAClB,EAAmB,gBAAD,CAAqB,CAAG,mCAC1C,EAAmB,SAAY,CAAG,MAAhB,qBAClB,EAAmB,aAAgB,CAAG,EAApB,6BAElB,EAAmB,KAAQ,CAAG,QAC9B,EAAmB,AADD,UACc,CAAG,KAAjB,QAClB,EAAmB,WAAc,CAAG,IAAlB,UAClB,EAAmB,aAAgB,CAAG,EAApB,cACX,GAEP,GACA,CADyC,EAG3C,GAAmB,CAAC,GAFF,KAAD,AADG,CAAsC,KAC1B,CAAG,IADJ,GAAG,mBAEzB,GAEP,GACA,GAMF,GAAc,CAAC,GAPA,AACH,AAAC,WADa,GAAG,IACK,CAAG,4BACnC,EAAW,QAAD,MAAkB,CAAG,wBAC/B,EAAW,QAAD,MAAkB,CAAG,wBAC/B,EAAW,QAAD,MAAkB,CAAG,wBAC/B,EAAW,QAAD,QAAoB,CAAG,0BAC1B,GAEP,GACA,GAKF,GAAiB,CAAC,GALF,GADE,AACH,WADc,AACI,CAAG,EADJ,yBAE9B,EAAc,WAAD,WAA0B,CAAG,mCAC1C,EAAc,WAAD,EAAiB,CAAG,0BACjC,EAAc,KAAQ,CAAG,KAAZ,aACN,GAEP,GACA,CADoC,EAGtC,GAAc,CAAC,GAFH,AAAC,AADE,CAAiC,UAAtB,CACE,CAAG,CADF,qBAEpB,GAEP,GACA,GAEF,GAAY,CAAC,CAHA,AACH,EAAC,SADa,CACA,CAAG,CADA,iBAElB,GAEP,GACA,CADmD,EAGrD,GAA6B,CAAC,GAFF,UAAa,CAAG,IADd,AACH,CADmD,UAArC,GAAG,iBAEnC,GAEP,GACA,CAD6C,EAI/C,GAAuB,CAAC,GAHF,SAAD,AADG,CAA0C,MACzB,CAAG,GADT,GAAG,6BAEpC,EAAoB,gBAAmB,CAApB,AAAuB,mCACnC,GAEP,GACA,GAEF,GAAkB,CAAC,GAFF,IADE,AACH,GAAW,CAAG,OADA,GAAG,WAExB,GAGJ,IAAM,EAA2B,IAAI,IAAI,CAC5C,qBACA,2BACA,4BACA,wBACA,kBACA,0BACA,wBACA,kBACA,mCACA,mCACA,mCACA,qCACA,oCACA,uCACA,+BACA,wCACH,EAGY,EAAmB,IAAI,IAAI,CACpC,oCACA,qCACA,wCACH,EqBnIK,EAA+B,QAAQ,GAAG,CAAC,4BAA4B,CAYzE,GAAI,CACA,EAAA,EAAA,CAAA,CAAA,MACJ,CAAE,MAAO,EAAK,CACV,EAAA,EAAA,CAAA,CAAA,MACJ,CAEJ,GAAM,SAAE,CAAO,aAAE,CAAW,OAAE,CAAK,gBAAE,CAAc,UAAE,CAAQ,cAAE,CAAY,CAAE,CAAG,CACzE,OAAM,UAAqB,MAC9B,YAAY,CAAM,CAAE,CAAM,CAAC,CACvB,KAAK,GAAI,IAAI,CAAC,MAAM,CAAG,EAAQ,IAAI,CAAC,MAAM,CAAG,CACjD,CACJ,CAKA,IAAM,EAAqB,CAAC,EAAM,KAC1B,AAJiB,UAAjB,OAIe,AAJR,GAAgC,AAAV,MAAgB,IAC1C,GADiD,UAChC,GAGK,EAAM,MAAM,CACrC,CADuC,CAClC,YAAY,CAAC,eAAe,IAE7B,IACA,EAAK,CADE,cACa,CAAC,GACrB,EAAK,YAAY,CAAC,aAAc,EAAM,IAAI,GAE9C,EAAK,SAAS,CAAC,CACX,KAAM,EAAe,KAAK,CAC1B,QAAS,AAAS,QAAO,KAAK,EAAI,EAAM,OAAO,AACnD,IAEJ,EAAK,GAAG,EACZ,EACuF,EAA0B,IAAI,IAC/G,EAAgB,EAAI,gBAAgB,CAAC,mBACvC,EAAa,EAEX,EAAwB,CAC1B,IAAK,CAAO,CAAE,CAAG,CAAE,CAAK,EACpB,EAAQ,IAAI,CAAC,KACT,EACA,OACJ,EACJ,CACJ,EA0KM,KACa,IA1KnB,AA0KuB,GADL,CAAC,EAzKb,EAKA,mBAAoB,CAClB,OAAO,EAAM,SAAS,CAAC,UAAW,QACtC,CACA,YAAa,CACT,OAAO,CACX,CACA,yBAA0B,CACtB,IAAM,EAAgB,EAAQ,MAAM,GAC9B,EAAU,EAAE,CAElB,OADA,EAAY,MAAM,CAAC,EAAe,EAAS,GACpC,CACX,CACA,oBAAqB,CACjB,OAAO,EAAM,OAAO,CAAY,MAAX,EAAkB,KAAK,EAAI,EAAQ,MAAM,GAClE,CACA,sBAAsB,CAAO,CAAE,CAAE,CAAE,CAAM,CAAE,CACvC,IAAM,EAAgB,EAAQ,MAAM,GACpC,GAAI,EAAM,cAAc,CAAC,GAErB,OAAO,IAEX,EAJyC,EAInC,EAAgB,EAAY,OAAO,CAAC,EAAe,EAAS,GAClE,OAAO,EAAQ,IAAI,CAAC,EAAe,EACvC,CACA,MAAM,GAAG,CAAI,CAAE,CACX,GAAM,CAAC,EAAM,EAAa,EAAU,CAAG,EAEjC,CAAE,IAAE,SAAE,CAAO,CAAE,CAAG,AAAuB,mBAAhB,EAA6B,CACxD,GAAI,EACJ,QAAS,CAAC,CACd,EAAI,CACA,GAAI,EACJ,QAAS,CACL,GAAG,CAAW,AAClB,CACJ,EACM,EAAW,EAAQ,QAAQ,EAAI,EACrC,GAAI,CAAC,EAAyB,GAAG,CAAC,IAA2C,MAAlC,QAAQ,GAAG,CAAC,iBAAiB,EAAY,EAAQ,QAAQ,CAChG,CADkG,MAC3F,IAGX,IAAI,EAAc,IAAI,CAAC,cAAc,CAAC,CAAY,MAAX,EAAkB,KAAK,EAAI,EAAQ,UAAA,AAAU,GAAK,IAAI,CAAC,kBAAkB,GAC5G,CAAC,IACD,EAAc,CAAY,MAAX,AADD,EACmB,KAAK,EAAI,EAAQ,MAAM,EAAA,CAAE,EAAK,CAAA,EAMnE,IAAM,EAAqB,EAAY,QAAQ,CAAC,GAC1C,EAA2C,UAA9B,OAAO,GAAmC,CAAC,EAAwB,GAAG,CAAC,GACpF,EAjEQ,IAuEd,GANe,IACf,EAAQ,UAAU,CAAG,CACjB,iBAAkB,EAClB,iBAAkB,EAClB,GAAG,EAAQ,UACf,AADyB,EAElB,EAAQ,IAAI,CAAC,EAAY,QAAQ,CAAC,EAAe,GAAS,IAAI,IAAI,CAAC,iBAAiB,GAAG,eAAe,CAAC,EAAU,EAAS,AAAC,QACtH,EACA,GAAgC,GAAQ,EAAiB,GAAG,CAAC,KAC7D,EADoE,AACxD,gBAAiB,YAAc,YAAa,YAAc,WAAW,WAAW,CAAC,GAAG,QAAK,CAAA,EAEzG,IAAI,GAAY,EACV,EAAY,MACV,IACJ,GAAY,EACZ,EAFe,AAES,MAAM,CAAC,GAC3B,GACA,QADW,IACC,OAAO,CAAC,CAAA,EAAG,EAA6B,MAAM,EAAE,CAAC,EAAK,KAAK,CAAC,KAAK,GAAG,IAAM,EAAA,CAAE,CAAE,OAAO,CAAC,SAAU,AAAC,GAAQ,IAAM,EAAM,WAAW,IAAA,CAAK,CAAE,CAC/I,MAAO,EACP,IAAK,YAAY,GAAG,EACxB,GAER,EAIA,GAHI,GACA,EAAwB,GAAG,CAAC,EAAQ,CADxB,GAC4B,IAAI,OAAO,OAAO,CAAC,EAAQ,UAAU,EAAI,CAAC,KAElF,EAAG,MAAM,CAAG,EACZ,CADe,EACX,CACA,OAAO,EAAG,EAAM,AAAC,GAAM,EAAmB,EAAM,GACpD,CAAE,MAAO,EAAK,CAEV,MADA,EAAmB,EAAM,GACnB,CACV,QAAS,CACL,GACJ,CAEJ,GAAI,CACA,IAAM,EAAS,EAAG,GAClB,GuBjJT,AAAY,CvBiJC,SuBjJ0B,UAAnB,OAAO,GAAwB,UAAU,EAAmC,YAAxB,OAAO,AvBiJvD,EuBjJ+D,IAAI,CvBmJ9E,EAFoB,KAEb,EAAO,IAAI,CAAC,AAAC,IAChB,EAAK,GAAG,GAGD,IACR,KAAK,CAAC,AAAC,IAEN,MADA,EAAmB,EAAM,GACnB,CACV,GAAG,OAAO,CAAC,GAKf,OAHI,EAAK,GAAG,GACR,IAEG,CACX,CAAE,MAAO,EAAK,CAGV,MAFA,EAAmB,EAAM,GACzB,IACM,CACV,CACJ,GACR,CACA,KAAK,GAAG,CAAI,CAAE,CACV,IAAM,EAAS,IAAI,CACb,CAAC,EAAM,EAAS,EAAG,CAAmB,IAAhB,EAAK,MAAM,CAAS,EAAO,CACnD,CAAI,CAAC,EAAE,CACP,CAAC,EACD,CAAI,CAAC,EAAE,CACV,QACD,AAAI,AAAC,EAAyB,GAAG,CAAC,IAA2C,KAAK,CAAvC,QAAQ,GAAG,CAAC,iBAAiB,CAGjE,WACH,IAAI,EAAa,EACS,YAAtB,OAAO,GAA2C,YAAd,AAA0B,OAAnB,GAC3C,GAAa,EAAW,KAAK,CAAC,IAAI,CAAE,UAAA,EAExC,IAAM,EAAY,UAAU,MAAM,CAAG,EAC/B,EAAK,SAAS,CAAC,EAAU,CAC/B,GAAkB,YAAd,OAAO,EAUP,OAAO,EAAO,KAAK,CAAC,EAAM,EAAY,IAAI,EAAG,KAAK,CAAC,IAAI,CAAE,WAV/B,EAC1B,IAAM,EAAe,EAAO,UAAU,GAAG,IAAI,CAAC,EAAQ,MAAM,GAAI,GAChE,OAAO,EAAO,KAAK,CAAC,EAAM,EAAY,CAAC,EAAO,KAC1C,SAAS,CAAC,EAAU,CAAG,SAAS,CAAG,EAE/B,OADQ,MAAR,CAAe,EAAS,EAAK,CAAT,EACb,EAAa,KAAK,CAAC,IAAI,CAAE,UACpC,EACO,EAAG,KAAK,CAAC,IAAI,CAAE,YAE9B,CAGJ,EArBW,CAsBf,CACA,EALe,QAKL,GAAG,CAAI,CAAE,CACf,GAAM,CAAC,EAAM,EAAQ,CAAG,EAClB,EAAc,IAAI,CAAC,cAAc,CAAC,CAAY,MAAX,EAAkB,KAAK,EAAI,EAAQ,UAAA,AAAU,GAAK,IAAI,CAAC,kBAAkB,IAClH,OAAO,IAAI,CAAC,iBAAiB,GAAG,SAAS,CAAC,EAAM,EAAS,EAC7D,CACA,eAAe,CAAU,CAAE,CAEvB,OADoB,AACb,EAD0B,EAAM,OAAO,CAAC,EAAQ,MAAM,GAAI,QAAc,CAEnF,CACA,uBAAwB,CACpB,IAAM,EAAS,EAAQ,MAAM,GAAG,QAAQ,CAAC,GACzC,OAAO,EAAwB,GAAG,CAAC,EACvC,CACA,qBAAqB,CAAG,CAAE,CAAK,CAAE,CAC7B,IAAM,EAAS,EAAQ,MAAM,GAAG,QAAQ,CAAC,GACnC,EAAa,EAAwB,GAAG,CAAC,GAC3C,GAAc,CAAC,EAAW,GAAG,CAAC,IAC9B,EADoC,AACzB,GAAG,CAAC,EAAK,EAE5B,CACJ,EAGW,IAAI,GZnNf,SAAS,EAAuB,CAAK,QACjC,AAAqB,UAAjB,AAA2B,OAApB,EACA,GAEU,UAAjB,EAA6B,KAAtB,GAAuB,MAAM,EAAA,GAA2B,WAAjB,AAA4B,OAArB,EAG9C,GAFA,OAAO,EAItB,C6CJA,IAAM,EAAmB,yBAClB,SAAS,EAAU,CAAM,EAC5B,GAAI,MAAE,CAAI,UAAE,CAAQ,CAAE,CAAG,EACrB,EAAW,EAAO,QAAQ,EAAI,GAC9B,EAAW,EAAO,QAAQ,EAAI,GAC9B,EAAO,EAAO,IAAI,EAAI,GACtB,EAAQ,EAAO,KAAK,EAAI,GACxB,GAAO,EACX,EAAO,EAAO,mBAAmB,GAAM,OAAO,CAAC,OAAQ,KAAO,IAAM,GAChE,EAAO,IAAI,CACX,CADa,CACN,EAAO,EAAO,IAAI,CAClB,IACP,EAAO,GAAQ,CADE,AACD,EAAS,CAAX,MAAkB,CAAC,KAAO,CAAC,CAAC,EAAE,EAAS,CAAC,CAAC,CAAG,CAAA,CAAQ,CAC9D,EAAO,IAAI,EAAE,CACb,GAAQ,IAAM,EAAO,IAAI,AAAJ,GAGzB,GAA0B,UAAjB,AAA2B,OAApB,IAChB,EAAQ,O7CbT,A6CagB,S7CbgB,AAAvB,CAA4B,EACxC,IAAM,EAAe,IAAI,gBACzB,IAAK,GAAM,CAAC,EAAK,EAAM,GAAI,OAAO,OAAO,CAAC,GACtC,GAAI,CADyC,KACnC,OAAO,CAAC,GACd,IAAK,CADiB,GACX,KAAQ,EACf,EAAa,EADQ,IACF,CAAC,EAAK,EAAuB,SAGpD,EAAa,GAAG,CAAC,EAAK,EAAuB,IAGrD,OAAO,CACX,E6CC0D,GAAA,EAEtD,IAAI,EAAS,EAAO,MAAM,EAAI,GAAS,CAAC,CAAC,EAAE,EAAA,CAAO,EAAI,GAYtD,OAXI,GAAY,CAAC,EAAS,QAAQ,CAAC,MAAM,IAAY,GAAA,EACjD,EAAO,OAAO,EAAI,CAAC,CAAC,GAAY,EAAiB,IAAI,CAAC,EAAA,CAAS,GAAc,IAAT,GAAgB,AACpF,EAAO,MAAQ,CAAD,EAAS,EAAA,CAAE,CACrB,GAAY,AAAgB,OAAR,CAAC,EAAE,GAAU,EAAW,IAAM,CAAA,GAC/C,AAAC,IACR,EADc,AACP,EAAA,EAEP,GAAoB,MAAZ,CAAI,CAAC,EAAE,EAAU,GAAO,IAAM,CAAA,EACtC,GAAwB,MAAd,CAAM,CAAC,EAAE,GAAU,EAAS,IAAM,CAAA,EAChD,EAAW,EAAS,OAAO,CAAC,QAAS,oBACrC,EAAS,EAAO,OAAO,CAAC,IAAK,OACtB,CAAA,EAAG,EAAA,EAAW,EAAA,EAAO,EAAA,EAAW,EAAA,EAAS,EAAA,CAAM,AAC1D,CnCtDO,IAAM,EAAoB,OAAO,GAAG,CAAC,2BACrC,SAAS,EAAe,CAAG,CAAE,CAAG,EACnC,IAAM,EAAO,CAAG,CAAC,EAAkB,EAAI,CAAC,EACxC,MAAsB,UAAf,OAAO,EAAmB,CAAI,CAAC,EAAI,CAAG,CACjD,CAkBW,SAAS,EAAe,CAAO,CAAE,CAAG,CAAE,CAAK,EAClD,IAAM,EAAO,EAAe,GAE5B,OADA,AACO,CADH,CAAC,EAAI,CAAG,EAZZ,AAasB,CAbnB,CAAC,EAAkB,CAaS,EAbN,CAc7B,CR3BO,SAAS,EAAoB,CAAM,SAClC,AAAJ,EAAW,oBAAoB,CACpB,CADsB,WAG7B,EAAO,kBAAkB,CAClB,CADoB,aAInC,CwBJW,CxBMX,QwBNoB,EAAU,CAAI,EAC9B,IAAM,EAAY,EAAK,OAAO,CAAC,IxBKF,CwBJvB,EAAa,EAAK,OAAO,CAAC,KAC1B,EAAW,EAAa,CAAC,IAAM,CAAD,CAAa,GAAK,EAAa,CAAA,CAAS,QAC5E,AAAI,GAAY,EAAY,CAAC,EAClB,CADqB,AAExB,SAAU,EAAK,SAAS,CAAC,EAAG,EAAW,EAAa,GACpD,MAAO,EAAW,EAAK,SAAS,CAAC,EAAY,EAAY,CAAC,EAAI,OAAY,GAAa,GACvF,KAAM,EAAY,CAAC,EAAI,EAAK,KAAK,CAAC,GAAa,EACnD,EAEG,CACH,SAAU,EACV,MAAO,GACP,KAAM,EACV,CACJ,CabW,CbeX,QafoB,GAAc,CAAI,CAAE,CAAM,EAC1C,GAAI,AAAgB,UAAU,OAAnB,EbcuB,Aab9B,OAAO,EAEX,GAAM,UAAE,CAAQ,CAAE,CAAG,EAAU,GAC/B,OAAO,IAAa,GAAU,EAAS,UAAU,CAAC,EAAS,IAC/D,CRRW,CQUX,KRViB,GACb,aAAa,CACT,IAAI,EACA,EAEJ,IAAI,CAAC,OAAO,CQKuB,ARLpB,IAAI,QAAQ,CAAC,EAAK,KAC7B,EAAU,EACV,EAAS,CACb,GAGA,IAAI,CAAC,OAAO,CAAG,EACf,IAAI,CAAC,MAAM,CAAG,CAClB,CACJ,ClCnBO,CkCqBP,GlCrBW,IACP,CADgD,EAQlD,CAAC,GAPiB,OADS,CACV,AAAY,CAAG,AADiC,SAA3B,EAEpC,CAFuC,CAEvB,QkCmBwB,ClCnBZ,CAAG,GAAhB,SACf,EAAgB,KAAQ,CAAG,OAAZ,CACf,EAAgB,KAAQ,CAAG,OAAZ,CACf,EAAgB,QAAW,CAAG,IAAf,OACf,EAAgB,KAAQ,CAAG,OAAZ,CACR,G8CGX,SAAS,KAIT,C7CVc,IAAI,WAAW,CACjB,GACA,IACA,IACA,IACA,IACH,EAEK,IAAI,WAAW,CACjB,GACA,GACA,IACA,IACA,IACH,EAIK,IAAI,WAAW,CACjB,GACA,GACA,IACA,IACA,GACA,IACA,GACH,EAEK,IAAI,WAAW,CACjB,GACA,GACA,GACA,IACA,IACA,IACA,GACH,EAEK,IAAI,WAAW,CACjB,GACA,GACA,IACA,IACA,IACA,IACA,GACH,EAEc,IAAI,WAAW,CAC1B,GACA,GACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,GACH,EAEC,IAIa,WAAW,CACtB,GACA,IACA,IACA,IACA,GACA,GACA,IACA,GACA,IACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,GACA,IACA,GACA,IACA,IACA,IACA,IACA,GACH,E6CjFT,IAAM,GAAU,IAAI,YAqCb,SAAS,GAAiB,CAAG,EAChC,OAAO,IAAI,eAAe,CACtB,MAAO,CAAU,EACb,EAAW,OAAO,CAAC,GAAQ,MAAM,CAAC,IAClC,EAAW,KAAK,EACpB,CACJ,EACJ,CACO,SAAS,GAAiB,CAAK,EAClC,OAAO,IAAI,eAAe,CACtB,MAAO,CAAU,EACb,EAAW,OAAO,CAAC,GACnB,EAAW,KAAK,EACpB,CACJ,EACJ,CAaO,eAAe,GAAe,CAAM,CAAE,CAAM,EAC/C,IAAM,EAAU,IAAI,YAAY,QAAS,CACrC,MAAO,EACX,GACI,EAAS,GACb,UAAW,IAAM,KAAS,EAAO,CAC7B,GAAc,MAAV,EAAiB,KAAK,EAAI,EAAO,OAAO,CACxC,CAD0C,MACnC,EAEX,GAAU,EAAQ,MAAM,CAAC,EAAO,CAC5B,QAAQ,CACZ,EACJ,CAEA,OADA,AACO,EADG,EAAQ,MAAM,EAE5B,CrCjGO,IAAM,GAA2B,2BAC3B,GAA2B,kCA+E9B,GAAuB,CAG3B,OAAQ,SAIR,sBAAuB,MAGvB,oBAAqB,MAGrB,cAAe,iBAGf,QAAS,WAGT,QAAS,WAGT,WAAY,aAGZ,WAAY,aAGZ,UAAW,aAGX,gBAAiB,oBAGjB,gBAAiB,oBAGjB,aAAc,iBAGd,aAAc,gBACpB,E8BpHW,SAAS,GAAoB,CAAK,EACzC,OAAO,EAAM,OAAO,CAAC,MAAO,KAAO,GACvC,CRJW,CQMX,QRNoB,GAAc,CAAI,CAAE,CAAM,EAC1C,GAAI,CAAC,EAAK,UAAU,CAAC,MAAQ,CAAC,EAC1B,MADkC,CAC3B,AQIkC,ERF7C,GAAM,UAAE,CAAQ,OAAE,CAAK,CAAE,MAAI,CAAE,CAAG,EAAU,GAC5C,MAAO,CAAA,EAAG,EAAA,EAAS,EAAA,EAAW,EAAA,EAAQ,EAAA,CAAM,AAChD,CKLW,CLOX,QKPoB,GAAc,CAAI,CAAE,CAAM,EAC1C,GAAI,CAAC,EAAK,UAAU,CAAC,MAAQ,CAAC,EAC1B,CLKmC,KKND,CAC3B,EAEX,GAAM,UAAE,CAAQ,OAAE,CAAK,MAAE,CAAI,CAAE,CAAG,EAAU,GAC5C,MAAO,CAAA,EAAG,EAAA,EAAW,EAAA,EAAS,EAAA,EAAQ,EAAA,CAAM,AAChD,E3BgHuB,A2B9GvB,C3B+GI,GAAG,EAAoB,CACvB,MAAO,CACH,aAAc,CACV,GAAqB,Y2BlHU,S3BkHW,CAC1C,GAAqB,aAAa,CACrC,CACD,WAAY,CACR,GAAqB,qBAAqB,CAC1C,GAAqB,aAAa,CAClC,GAAqB,UAAU,CAC/B,GAAqB,UAAU,CAClC,CACD,cAAe,CAEX,GAAqB,OAAO,CAC5B,GAAqB,OAAO,CAC/B,CACD,WAAY,CACR,GAAqB,mBAAmB,CACxC,GAAqB,eAAe,CACvC,CACD,QAAS,CACL,GAAqB,qBAAqB,CAC1C,GAAqB,aAAa,CAClC,GAAqB,mBAAmB,CACxC,GAAqB,eAAe,CACpC,GAAqB,MAAM,CAC3B,GAAqB,UAAU,CAC/B,GAAqB,UAAU,CAClC,CACD,SAAU,CAEN,GAAqB,qBAAqB,CAC1C,GAAqB,mBAAmB,CACxC,GAAqB,eAAe,CACpC,GAAqB,aAAa,CACrC,AACL,EACJ,Eb9JI,IAAM,GAAQ,IAAI,QASX,SAAS,GAAoB,CAAQ,CAAE,CAAO,MAWjD,EATJ,GAAI,CAAC,EAAS,MAAO,UACjB,CACJ,EAEA,IAAI,EAAoB,GAAM,GAAG,CAAC,GAC7B,IACD,EAAoB,EAAQ,GAAG,CAAC,AAAC,GAAS,EAAO,EAD7B,SACwC,IAC5D,GAAM,GAAG,CAAC,EAAS,IAKvB,IAAM,EAAW,EAAS,KAAK,CAAC,IAAK,GAGrC,GAAI,CAAC,CAAQ,CAAC,EAAE,CAAE,MAAO,UACrB,CACJ,EAEA,IAAM,EAAU,CAAQ,CAAC,EAAE,CAAC,WAAW,GAGjC,EAAQ,EAAkB,OAAO,CAAC,UACxC,AAAI,EAAQ,EAAU,CAAP,SACX,CACJ,GAEA,EAAiB,CAAO,CAAC,EAAM,CAGxB,CACH,SAFJ,EAAW,EAAS,KAAK,CAAC,EAAe,MAAM,CAAG,IAAM,mBAGpD,CACJ,EACJ,C2B7CA,C3B+CA,G2B/CM,GAA2B,2C3B+CgB,gD2B9CjD,SAAS,GAAS,CAAG,CAAE,CAAI,EACvB,OAAO,IAAI,IAAI,OAAO,GAAK,OAAO,CAAC,GAA0B,aAAc,GAAQ,OAAO,GAAM,OAAO,CAAC,GAA0B,aACtI,CACA,IAAM,GAAW,OAAO,kBACjB,OAAM,GACT,YAAY,CAAK,CAAE,CAAU,CAAE,CAAI,CAAC,CAChC,IAAI,EACA,EACsB,UAAtB,OAAO,GAA2B,aAAc,GAAc,AAAsB,UAAU,OAAzB,GACrE,EAAO,EACP,EAAU,GAAQ,CAAC,GAEnB,EAAU,GAAQ,GAAc,CAAC,EAErC,IAAI,CAAC,GAAS,CAAG,CACb,IAAK,GAAS,EAAO,GAAQ,EAAQ,IAAI,EACzC,QAAS,EACT,SAAU,EACd,EACA,IAAI,CAAC,OAAO,EAChB,CACA,SAAU,CACN,IAAI,EAAwC,EAAmC,EAA6B,EAAyC,EACrJ,IAAM,EAAO,AJzBd,SAAS,AAAoB,CAAQ,CAAE,CAAO,EACjD,GAAM,UAAE,CAAQ,MAAE,CAAI,eAAE,CAAa,CAAE,CAAG,EAAQ,UAAU,EAAI,CAAC,EAC3D,EAAO,UACT,EACA,cAA4B,MAAb,EAAmB,EAAS,QAAQ,CAAC,KAAO,CAC/D,EACI,GAAY,GAAc,EAAK,QAAQ,CAAE,KACzC,EAAK,IAD+C,IACvC,CyBFV,AzBEa,SyBFJ,AAAiB,CAAI,CAAE,CAAM,EAa7C,GAAI,CAAC,GAAc,EAAM,GACrB,MAD8B,CACvB,EAGX,IAAM,EAAgB,EAAK,KAAK,CAAC,EAAO,MAAM,SAE9C,AAAI,EAAc,UAAU,CAAC,KAClB,CADwB,CAK5B,CAAC,CAAC,EAAE,EAAA,CAAe,AAC9B,EAEA,AzBzByC,EAAK,QAAQ,CAAE,GAChD,EAAK,QAAQ,CAAG,GAEpB,IAAI,EAAuB,EAAK,QAAQ,CACxC,CyBqB0C,EzBrBtC,EAAK,QAAQ,CAAC,UAAU,CAAC,iBAAmB,EAAK,QAAQ,CAAC,QAAQ,CAAC,SAAU,CAC7E,IAAM,EAAQ,EAAK,QAAQ,CAAC,OAAO,CAAC,mBAAoB,IAAI,OAAO,CAAC,UAAW,IAAI,KAAK,CAAC,KAEzF,EAAK,OAAO,CADI,CAAK,CAAC,AACP,EADS,CAExB,EAAoC,UAAb,CAAK,CAAC,EAAE,CAAe,CAAC,CAAC,EAAE,EAAM,KAAK,CAAC,GAAG,IAAI,CAAC,KAAA,CAAM,CAAG,KAGrD,IAAtB,EAAQ,AAAoB,SAAX,GACjB,EAAK,QAAQ,CAAG,CAAA,CAExB,CAGA,GAAI,EAAM,CACN,IAAI,EAAS,EAAQ,YAAY,CAAG,EAAQ,YAAY,CAAC,OAAO,CAAC,EAAK,QAAQ,EAAI,GAAoB,EAAK,QAAQ,CAAE,EAAK,OAAO,EACjI,EAAK,MAAM,CAAG,EAAO,cAAc,CACnC,EAAK,QAAQ,CAAG,EAAO,QAAQ,EAAI,EAAK,QAAQ,CAC5C,CAAC,EAAO,cAAc,EAAI,EAAK,OAAO,EAElC,AAFoC,CACxC,EAAS,EAAQ,YAAY,CAAG,EAAQ,YAAY,CAAC,OAAO,CAAC,GAAwB,GAAoB,EAAsB,EAAK,OAAO,GAChI,cAAc,EAAE,CACvB,EAAK,MAAM,CAAG,EAAO,cAAA,AAAc,CAG/C,CACA,OAAO,CACX,EAEA,AIbyC,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,QAAQ,CAAE,CAC1D,WAAY,IAAI,CAAC,GAAS,CAAC,OJYW,AIZJ,CAAC,UAAU,CAC7C,UAAW,GACX,aAAc,IAAI,CAAC,GAAS,CAAC,OAAO,CAAC,YAAY,AACrD,GACM,EY5BH,AZ4Bc,SY5BL,AAAY,CAAM,CAAE,CAAO,EAG3C,IAAI,EACJ,GAAI,GAAS,MAAQ,CAAC,MAAM,OAAO,CAAC,EAAQ,IAAI,EAC5C,CAD+C,CACpC,EAAQ,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,IAAK,EAAE,CAAC,EAAE,MAChD,IAAI,EAAO,QAAQ,CAEnB,CAFqB,MACxB,EAAW,EAAO,QAAQ,CAE9B,OAAO,EAAS,WAAW,EAC/B,EZkBqC,AYhBrC,IZgByC,CAAC,GAAS,CAAC,GAAG,CAAE,IAAI,CAAC,GAAS,CAAC,OAAO,CAAC,OAAO,EAC/E,CYjBgC,GZiB5B,CAAC,GAAS,CAAC,YAAY,CAAG,IAAI,CAAC,GAAS,CAAC,OAAO,CAAC,YAAY,CAAG,IAAI,CAAC,GAAS,CAAC,OAAO,CAAC,YAAY,CAAC,kBAAkB,CAAC,GnBlC5H,AmBkCwI,SnBlC/H,AAAmB,CAAW,CAAE,CAAQ,CAAE,CAAc,EACpE,GAAK,AmBiCyJ,CnBjC1J,EAIJ,IAAK,IAAM,EAJO,GACd,IACA,EAAiB,EAAe,QADhB,GAC2B,EAAA,EAE5B,GAGf,GAAI,IADmB,EAFI,AAEC,MAAM,CACjB,CADmB,MAAM,IAAK,EAAE,CAAC,EAAE,CAAC,eAClB,IAAmB,EAAK,aAAa,CAAC,WAAW,IAAM,EAAK,OAAO,EAAE,KAAK,AAAC,GAAS,EAAO,WAAW,KAAO,GAC5I,OAAO,CAEf,CACJ,EAEA,AmBoB6O,GnB1BpE,ImB0BN,AAAiF,EAA7C,GAAkD,CAA9C,CAAC,GAAS,CAAC,OAAO,CAAC,UAAA,AAAU,GAAqB,AAAqF,OAApF,EnBpB9M,AmBoBuP,EAAkC,IAAA,AAAI,EAAY,KAAK,EAAI,EAAuC,OAAO,CAAE,GAC1Y,IAAM,EAAgB,AAAC,CAA+D,OAA9D,EAA8B,IAAI,CAAC,GAAS,CAAC,YAAA,AAAY,EAAY,KAAK,EAAI,EAA4B,aAAA,AAAa,IAAkF,CAA7E,CAAC,KAAC,AAAkF,EAA7C,GAAkD,CAA9C,CAAC,GAAS,CAAC,OAAO,CAAC,UAAA,AAAU,GAAqB,AAAuF,OAAtF,EAA0C,EAAmC,IAAA,AAAI,EAAY,KAAK,EAAI,EAAwC,aAAa,EAC7Y,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,QAAQ,CAAG,EAAK,QAAQ,CAC3C,IAAI,CAAC,GAAS,CAAC,aAAa,CAAG,EAC/B,IAAI,CAAC,GAAS,CAAC,QAAQ,CAAG,EAAK,QAAQ,EAAI,GAC3C,IAAI,CAAC,GAAS,CAAC,OAAO,CAAG,EAAK,OAAO,CACrC,IAAI,CAAC,GAAS,CAAC,MAAM,CAAG,EAAK,MAAM,EAAI,EACvC,IAAI,CAAC,GAAS,CAAC,aAAa,CAAG,EAAK,aACxC,AADqD,CAErD,gBAAiB,KCvCkB,IAAI,IDwCnC,OCvCA,ADuCO,ECvCI,AgBCR,SAAmB,AAAV,CAAc,CAAE,CAAM,CAAE,CAAa,CAAE,CAAY,EAGnE,GAAI,CAAC,GAAU,IAAW,EAAe,OAAO,EAChD,IAAM,EAAQ,EAAK,WAAW,SAG9B,AAAI,CAAC,IACG,GAAc,EAAO,KADV,IACmB,AAC9B,GAAc,EAAO,CAAC,CAAC,EAAE,EAAO,WAAW,GAAA,CAAI,GADV,AACa,EAGnD,GAAc,EAH4C,AAGtC,CAAC,CAAC,EAAE,EAAA,CAAQ,CAC3C,EAEA,AhBhB6B,GDuCS,CAC1B,SAAU,IAAI,CAAC,GAAS,CAAC,QAAQ,CACjC,OiBzB0B,CjByBjB,IAAI,CAAC,GAAS,CAAC,OAAO,CAC/B,cAAe,AAAC,IAAI,CAAC,GAAS,CAAC,OAAO,CAAC,WAAW,MAAkC,EAA/B,IAAI,CAAC,GAAS,CAAC,aAAa,CACjF,OAAQ,IAAI,CAAC,GAAS,CAAC,MAAM,CAC7B,SAAU,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,QAAQ,CACrC,cAAe,IAAI,CAAC,GAAS,CAAC,aAAa,AAC/C,GC9C0B,QAAQ,CAAE,EAAK,MAAM,CAAE,EAAK,OAAO,CAAG,OAAY,EAAK,aAAa,CAAE,EAAK,YAAY,GACjH,EAAK,OAAO,EAAI,CAAC,EAAK,aAAA,AAAa,EAAE,EACrC,EAAW,GAAoB,EAAA,EAE/B,EAAK,OAAO,EAAE,CACd,EAAW,GAAc,GAAc,EAAU,CAAC,YAAY,EAAE,EAAK,OAAO,CAAA,CAAE,EAAqB,MAAlB,EAAK,QAAQ,CAAW,aAAe,QAAA,EAE5H,EAAW,GAAc,EAAU,EAAK,QAAQ,EACzC,CAAC,EAAK,OAAO,EAAI,EAAK,aAAa,CAAG,AAAC,EAAS,QAAQ,CAAC,KAAsC,EAA/B,GAAc,EAAU,KAAkB,GAAoB,EDuCrI,CACA,cAAe,CACX,OAAO,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,MAAM,AACpC,CACA,IAAI,SAAU,CACV,OAAO,IAAI,CAAC,GAAS,CAAC,OAAO,AACjC,CACA,IAAI,QAAQ,CAAO,CAAE,CACjB,IAAI,CAAC,GAAS,CAAC,OAAO,CAAG,CAC7B,CACA,IAAI,QAAS,CACT,OAAO,IAAI,CAAC,GAAS,CAAC,MAAM,EAAI,EACpC,CACA,IAAI,OAAO,CAAM,CAAE,CACf,IAAI,EAAwC,EAC5C,GAAI,CAAC,IAAI,CAAC,GAAS,CAAC,MAAM,EAAI,CAAC,CAAC,AAA2E,OAA1E,AAAiF,EAA7C,GAAkD,CAA9C,CAAC,GAAS,CAAC,OAAO,CAAC,UAAA,AAAU,GAAqB,AAAqF,OAApF,EAAyC,EAAkC,IAAI,AAAJ,EAAgB,KAAK,EAAI,EAAuC,OAAO,CAAC,QAAQ,CAAC,IACpR,GAD2R,GAAG,AACxR,OAAO,cAAc,CAAC,AAAI,UAAU,CAAC,8CAA8C,EAAE,EAAO,CAAC,CAAC,EAAG,oBAAqB,CACxH,MAAO,OACP,WAAY,GACZ,cAAc,CAClB,GAEJ,IAAI,CAAC,GAAS,CAAC,MAAM,CAAG,CAC5B,CACA,IAAI,eAAgB,CAChB,OAAO,IAAI,CAAC,GAAS,CAAC,aAAa,AACvC,CACA,IAAI,cAAe,CACf,OAAO,IAAI,CAAC,GAAS,CAAC,YAAY,AACtC,CACA,IAAI,cAAe,CACf,OAAO,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,YAAY,AAC1C,CACA,IAAI,MAAO,CACP,OAAO,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,IAAI,AAClC,CACA,IAAI,KAAK,CAAK,CAAE,CACZ,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,IAAI,CAAG,CAC9B,CACA,IAAI,UAAW,CACX,OAAO,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,QAAQ,AACtC,CACA,IAAI,SAAS,CAAK,CAAE,CAChB,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,QAAQ,CAAG,CAClC,CACA,IAAI,MAAO,CACP,OAAO,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,IAC9B,AADkC,CAElC,IAAI,KAAK,CAAK,CAAE,CACZ,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,IAAI,CAAG,CAC9B,CACA,IAAI,UAAW,CACX,OAAO,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,QAAQ,AACtC,CACA,IAAI,SAAS,CAAK,CAAE,CAChB,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,QAAQ,CAAG,CAClC,CACA,IAAI,MAAO,CACP,IAAM,EAAW,IAAI,CAAC,cAAc,GAC9B,EAAS,IAAI,CAAC,YAAY,GAChC,MAAO,CAAA,EAAG,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,IAAI,CAAC,IAAI,CAAA,EAAG,EAAA,EAAW,EAAA,EAAS,IAAI,CAAC,IAAI,CAAA,CAAE,AAC3E,CACA,IAAI,KAAK,CAAG,CAAE,CACV,IAAI,CAAC,GAAS,CAAC,GAAG,CAAG,GAAS,GAC9B,IAAI,CAAC,OAAO,EAChB,CACA,IAAI,QAAS,CACT,OAAO,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,MAC9B,AADoC,CAEpC,IAAI,UAAW,CACX,OAAO,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,QAAQ,AACtC,CACA,IAAI,SAAS,CAAK,CAAE,CAChB,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,QAAQ,CAAG,CAClC,CACA,IAAI,MAAO,CACP,OAAO,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,IAAI,AAClC,CACA,IAAI,KAAK,CAAK,CAAE,CACZ,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,IAAI,CAAG,CAC9B,CACA,IAAI,QAAS,CACT,OAAO,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,MAAM,AACpC,CACA,IAAI,OAAO,CAAK,CAAE,CACd,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,MAAM,CAAG,CAChC,CACA,IAAI,UAAW,CACX,OAAO,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,QAC9B,AADsC,CAEtC,IAAI,SAAS,CAAK,CAAE,CAChB,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,QAAQ,CAAG,CAClC,CACA,IAAI,UAAW,CACX,OAAO,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,QAAQ,AACtC,CACA,IAAI,SAAS,CAAK,CAAE,CAChB,IAAI,CAAC,GAAS,CAAC,GAAG,CAAC,QAAQ,CAAG,CAClC,CACA,IAAI,UAAW,CACX,OAAO,IAAI,CAAC,GAAS,CAAC,QAAQ,AAClC,CACA,IAAI,SAAS,CAAK,CAAE,CAChB,IAAI,CAAC,GAAS,CAAC,QAAQ,CAAG,EAAM,UAAU,CAAC,KAAO,EAAQ,CAAC,CAAC,EAAE,EAAA,CAAO,AACzE,CACA,UAAW,CACP,OAAO,IAAI,CAAC,IAAI,AACpB,CACA,QAAS,CACL,OAAO,IAAI,CAAC,IAChB,AADoB,CAEpB,CAAC,OAAO,GAAG,CAAC,+BAA+B,EAAG,CAC1C,MAAO,CACH,KAAM,IAAI,CAAC,IAAI,CACf,OAAQ,IAAI,CAAC,MAAM,CACnB,SAAU,IAAI,CAAC,QAAQ,CACvB,SAAU,IAAI,CAAC,QAAQ,CACvB,SAAU,IAAI,CAAC,QAAQ,CACvB,KAAM,IAAI,CAAC,IAAI,CACf,SAAU,IAAI,CAAC,QAAQ,CACvB,KAAM,IAAI,CAAC,IAAI,CACf,SAAU,IAAI,CAAC,QAAQ,CACvB,OAAQ,IAAI,CAAC,MAAM,CACnB,aAAc,IAAI,CAAC,YAAY,CAC/B,KAAM,IAAI,CAAC,IAAI,AACnB,CACJ,CACA,OAAQ,CACJ,OAAO,IAAI,GAAQ,OAAO,IAAI,EAAG,IAAI,CAAC,GAAS,CAAC,OAAO,CAC3D,CACJ,C1BtLA,C0BwLA,C1BxLA,CAAA,CAAA,O4BIyB,C5BFzB,M4BEgC,mBFoLI,CE/KC,QAyBhC,C5BhC8B,M4BgCvB,GAAG,CAAC,+BC9BT,AD8BwC,GAAG,CC9BrC,GAAsB,iBAC5B,OAAM,WAAwB,MACjC,YAAY,GAAG,CAAI,CAAC,CAChB,KAAK,IAAI,GAAO,IAAI,CAAC,IAAI,CAAG,EAChC,CACJ,CjCRA,IAAI,GAA2B,EAC3B,GAA2B,EAC3B,GAA2B,EwCExB,SAAS,GAAa,CAAC,EAC1B,MAAO,CAAC,AAAK,QAAO,KAAK,EAAI,EAAE,IAAA,AAAI,IAAM,cAAgB,CAAM,MAAL,EAAY,KAAK,EAAI,EAAE,IAAA,AAAI,IAAM,EAC/F,CAqFO,eAAe,GAAmB,CAAQ,CAAE,CAAG,CAAE,CAAe,EACnE,GAAI,CAEA,MAAM,SAAE,CAAO,WAAE,CAAS,CAAE,CAAG,EAC/B,GAAI,GAAW,EAAW,OAG1B,IAAM,GPlFJ,EAAa,IAAI,IOkFA,YP9EvB,EAAS,IAAI,CAAC,QAAS,KACf,AO6EqC,EP7E5B,gBAAgB,EAAE,AAC/B,EAAW,KAAK,CAAC,IAAI,GACzB,GACO,GO2EG,EAAS,AA5FvB,SAAS,AAAyB,CAAG,CAAE,CAAe,EAClD,IAAI,GAAU,EAGV,EAAU,IAAI,GAClB,SAAS,IACL,EAAQ,OAAO,EACnB,CACA,EAAI,EAAE,CAAC,QAAS,GAGhB,EAAI,IAAI,CAAC,QAAS,KACd,EAAI,GAAG,CAAC,QAAS,GACjB,EAAQ,OAAO,EACnB,GAGA,IAAM,EAAW,IAAI,GAKrB,OAJA,EAAI,IAAI,CAAC,SAAU,KACf,EAAS,OAAO,EACpB,GAEO,IAAI,eAAe,CACtB,MAAO,MAAO,IAIV,GAAI,CAAC,EAAS,CAEV,GADA,GAAU,EACN,gBAAiB,YAAc,QAAQ,GAAG,CAAC,4BAA4B,CAAE,CACzE,IAAM,EAAU,AxCL7B,SAAS,AAAgC,EAAU,CAAC,CAAC,EACxD,IAAM,EAAuC,IAA7B,QAAiC,EAAY,0BACzD,4BACA,4BACA,EACJ,EAMA,OALI,EAAQ,KAAK,EAAE,CACf,GAA2B,EAC3B,GAA2B,EAC3B,GAA2B,GAExB,CACX,EAEA,EwCRwB,GACA,MADS,MACG,OAAO,CAAC,CAAA,EAAG,QAAQ,GAAG,CAAC,oBxCOC,QwCP2B,CAAC,8BAA8B,CAAC,CAAE,CAC7F,MAAO,EAAQ,wBAAwB,CACvC,IAAK,EAAQ,wBAAwB,CAAG,EAAQ,wBAAwB,AAC5E,EAER,CACA,EAAI,YAAY,GAChB,IAAY,KAAK,CAAC,EAAmB,aAAa,CAAE,CAChD,SAAU,gBACd,EAAG,SAAI,EACX,CACA,GAAI,CACA,IAAM,EAAK,EAAI,KAAK,CAAC,GAGjB,UAAW,GAA4B,YAArB,AAAiC,OAA1B,EAAI,KAAK,EAClC,EAAI,KAAK,GAIR,IAAI,AACL,MAAM,EAAQ,OAAO,CAErB,EAAU,IAAI,GAEtB,CAAE,MAAO,EAAK,CAEV,MADA,EAAI,GAAG,GACD,OAAO,cAAc,CAAC,AAAI,MAAM,oCAAqC,CACvE,MAAO,CACX,GAAI,oBAAqB,CACrB,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,EACJ,CACJ,EACA,MAAO,AAAC,IACA,EAAI,gBAAgB,EACxB,AAD0B,EACtB,OAAO,CAAC,EAChB,EACA,MAAO,UAMH,GAHI,GACA,MAAM,GAEN,EAAI,GAHa,aAGG,CAExB,CAF0B,MAC1B,EAAI,GAAG,GACA,EAAS,OAAO,AAC3B,CACJ,EACJ,EASgD,EAAK,EAC7C,OAAM,EAAS,MAAM,CAAC,EAAQ,CAC1B,OAAQ,EAAW,MAAM,AAC7B,EACJ,CAAE,MAAO,EAAK,CAEV,GAAI,GAAa,GAAM,MACvB,OAAM,OAAO,cAAc,CAAC,AAAI,MAAM,0BAA2B,CAC7D,MAAO,CACX,GAAI,oBAAqB,CACrB,MAAO,OACP,YAAY,EACZ,aAAc,EAClB,EACJ,CACJ,C1BnHO,C0BqHP,K1BrHa,WAAuB,MAChC,YAAY,CAAO,CAAE,CAAO,CAAC,CACzB,E0BmHiC,G1BnH5B,CAAC,CAAC,WAAW,EAAE,EAAQ,QAAQ,CAAC,KAAO,EAAU,EAAU,IAAI,0BAA0B,CAAC,CAAE,GACjG,IAAI,CAAC,IAAI,CAAG,gBAChB,CACJ,CeFe,CfIf,KeJqB,GACjB,QAAO,CAAA,AAAE,CAGP,EAHU,EAGN,CAAC,KAAK,CAAG,IAAI,GAAa,KAAM,CAClC,CfDmC,QeCzB,CAAC,EACX,YAAa,IACjB,EAAG,AAOD,QAAO,WAAW,CAAK,CAAE,CAAW,CAAE,CACpC,OAAO,IAAI,GAAa,EAAO,CAC3B,SAAU,CAAC,cACX,CACJ,EACJ,CACA,YAAY,CAAQ,CAAE,CAAE,aAAW,WAAE,CAAS,UAAE,CAAQ,CAAE,CAAC,CACvD,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,WAAW,CAAG,EACnB,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,SAAS,CAAG,CACrB,CACA,eAAe,CAAQ,CAAE,CACrB,OAAO,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAE,EACjC,CAIE,IAAI,QAAS,CACX,OAAyB,OAAlB,IAAI,CAAC,QAAQ,AACxB,CAIE,IAAI,WAAY,CACd,MAAgC,UAAzB,OAAO,IAAI,CAAC,QAAQ,AAC/B,CACA,kBAAkB,GAAS,CAAK,CAAE,CAC9B,GAAsB,MAAM,CAAxB,IAAI,CAAC,QAAQ,CAGb,MAAO,GAEX,GAA6B,UAAzB,OAAO,IAAI,CAAC,QAAQ,CAAe,CACnC,GAAI,CAAC,EACD,MADS,AACH,OAAO,cAAc,CAAC,IAAI,GAAe,mEAAoE,oBAAqB,CACpI,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,GAEJ,OAAO,GAAe,IAAI,CAAC,QAAQ,CACvC,CACA,OAAO,IAAI,CAAC,QAAQ,AACxB,CAGE,IAAI,UAAW,QACb,AAAsB,MAAM,CAAxB,IAAI,CAAC,QAAQ,CAGN,IAAI,eAAe,CACtB,MAAO,CAAU,EACb,EAAW,KAAK,EACpB,CACJ,GAEyB,UAAzB,AAAmC,OAA5B,IAAI,CAAC,QAAQ,CACb,GAAiB,IAAI,CAAC,QAAQ,EAErC,OAAO,QAAQ,CAAC,IAAI,CAAC,QAAQ,EACtB,CADyB,EACR,IAAI,CAAC,QAAQ,EAGrC,MAAM,OAAO,CAAC,IAAI,CAAC,QAAQ,EACpB,AwB/DZ,CxB8DmC,QwB9D1B,AAAa,GAAG,CAAO,EAGnC,GAAuB,AAAnB,GAAsB,GAAd,MAAM,CACd,OAAO,IAAI,eAAe,CACtB,MAAO,CAAU,EACb,EAAW,KAAK,EACpB,CACJ,GAGJ,GAAuB,GAAG,CAAtB,EAAQ,MAAM,CACd,OAAO,CAAO,CAAC,EAAE,CAErB,GAAM,UAAE,CAAQ,UAAE,CAAQ,CAAE,CAAG,IAAI,gBAG/B,EAAU,CAAO,CAAC,EAAE,CAAC,MAAM,CAAC,EAAU,CACtC,cAAc,CAClB,GACI,EAAI,EACR,KAAM,EAAI,EAAQ,MAAM,CAAG,EAAG,IAAI,CAC9B,IAAM,EAAa,CAAO,CAAC,EAAE,CAC7B,EAAU,EAAQ,IAAI,CAAC,IAAI,EAAW,MAAM,CAAC,EAAU,CAC/C,cAAc,CAClB,GACR,CAGA,IAAM,EAAa,CAAO,CAAC,EAAE,CAK7B,MADA,CAHA,EAAU,EAAQ,IAAI,CAAC,IAAI,EAAW,MAAM,CAAC,GAAA,EAGrC,KAAK,CAAC,IACP,CACX,KxB4BmC,IAAI,CAAC,QAAQ,EAEjC,IAAI,CAAC,QAAQ,AACxB,CAME,QAAS,QACe,AAAtB,MAA4B,CAAxB,IAAI,CAAC,QAAQ,CAGN,EAAE,CAET,AAAyB,UAAU,OAA5B,IAAI,CAAC,QAAQ,CACb,CACH,GAAiB,IAAI,CAAC,QAAQ,EACjC,CACM,MAAM,OAAO,CAAC,IAAI,CAAC,QAAQ,EAC3B,CAD8B,GAC1B,CAAC,QAAQ,CACb,OAAO,QAAQ,CAAC,IAAI,CAAC,QAAQ,EAC7B,CADgC,AAEnC,GAAiB,IAAI,CAAC,QAAQ,EACjC,CAEM,CACH,IAAI,CAAC,QAAQ,CAChB,AAET,CAQE,QAAQ,CAAQ,CAAE,CAEhB,IAAI,CAAC,QAAQ,CAAG,IAAI,CAAC,MAAM,GAE3B,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,EAC1B,CAQE,KAAK,CAAQ,CAAE,CAEb,IAAI,CAAC,QAAQ,CAAG,IAAI,CAAC,MAAM,GAE3B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EACvB,CAOE,MAAM,OAAO,CAAQ,CAAE,CACrB,GAAI,CACA,MAAM,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAU,CAKjC,cAAc,CAClB,GAGI,IAAI,CAAC,SAAS,EAAE,MAAM,IAAI,CAAC,SAAS,CAExC,MAAM,EAAS,KAAK,EACxB,CAAE,MAAO,EAAK,CAIV,GAAI,GAAa,GAAM,YAEnB,MAAM,EAAS,KAAK,CAAC,EAMzB,OAAM,CACV,CACJ,CAME,MAAM,mBAAmB,CAAG,CAAE,CAC5B,MAAM,GAAmB,IAAI,CAAC,QAAQ,CAAE,EAAK,IAAI,CAAC,SAAS,CAC/D,CACJ,CK7JO,CL+JP,cK/JsB,GAAqB,CAAQ,EAC/C,IAAI,EAAiB,SAChB,AAAL,EACO,CACH,CAFA,EL6JiC,IK7JtB,AAEH,EAAS,MAAM,CACvB,QAAS,EAAS,OAAO,CACzB,aAAc,EAAS,YAAY,CACnC,MAAO,CAAC,AAAsC,OAArC,EAAkB,EAAS,KAAA,AAAK,EAAY,KAAK,EAAI,EAAgB,IAAA,AAAI,IAAM,GAAgB,KAAK,CAAG,CAC5G,KAAM,GAAgB,KAAK,CAC3B,KAAM,GAAa,UAAU,CAAC,EAAS,KAAK,CAAC,IAAI,CAAE,IACnD,SAAU,EAAS,KAAK,CAAC,QAAQ,CACjC,QAAS,EAAS,KAAK,CAAC,OAAO,CAC/B,OAAQ,EAAS,KAAK,CAAC,MAAM,AACjC,EAAI,CAAwC,AAAvC,OAAC,EAAmB,EAAS,KAAK,AAAL,EAAiB,KAAK,EAAI,EAAiB,IAAA,AAAI,IAAM,GAAgB,QAAQ,CAAG,CAC9G,KAAM,GAAgB,QAAQ,CAC9B,KAAM,GAAa,UAAU,CAAC,EAAS,KAAK,CAAC,IAAI,CAAE,IACnD,QAAS,EAAS,KAAK,CAAC,OAAO,CAC/B,QAAS,EAAS,KAAK,CAAC,OAAO,CAC/B,OAAQ,EAAS,KAAK,CAAC,MAAM,CAC7B,UAAW,EAAS,KAAK,CAAC,SAAS,CACnC,YAAa,EAAS,KAAK,CAAC,WAChC,AAD2C,EACvC,EAAS,KAAK,AACtB,EApBsB,IAqB1B,Cf/CO,SAAS,GAAsB,YAAE,CAAU,QAAE,CAAM,CAAE,EACxD,IAAM,EAAkC,UAAtB,OAAO,GAA2B,AAAW,YAAa,EAAa,EAAS,CAAC,yBAAyB,EAAE,EAAS,EAAA,CAAY,CAAG,UACtJ,AAAmB,GAAG,CAAlB,EACO,0DACsB,UAAtB,AAAgC,OAAzB,EACP,CAAC,SAAS,EAAE,EAAA,EAAa,EAAA,CAAW,CAExC,CAAC,SAAS,EAAE,QAAiB,GAAW,AACnD,CQmFkB,AADuB,CRhFzC,YQgFkB,OAAO,aACD,CACpB,OACA,CRnFqC,SQoFrC,mBACH,CAAC,KAAK,CAAC,AAAC,GAAwC,YAA/B,OAAO,WAAW,CAAC,EAAO,EZhGrC,IAAI,IACP,GAIF,CAAC,EAJmB,CAAC,CAMvB,CAN0C,QAAW,AADrB,CACwB,IAAI,CAAG,EAAtB,GADE,GAAG,GAE1C,CAAkB,CAAC,EAAmB,gBAAD,CAAqB,CAAG,AAKjB,IALqB,CAAG,oBACpE,CAAkB,CAAC,EAAmB,gBAAD,CAAqB,CAAG,IAAI,CAAG,oBAC7D,GVSX,GAAA,EAAA,CAAA,CAAA,OkBXA,GAAA,EAAA,CAAA,CAAA,OAqBO,eAAe,GAAiB,KAAE,CAAG,KAAE,CAAG,QAAE,CAAM,eAAE,CAAa,iBAAE,CAAe,cAAE,CAAY,CAAE,EACrG,GIiBO,CJjBH,CIiBO,QAAQ,EJjBL,AIiBS,EAAI,IJjBP,OIiBkB,CJhBlC,OAEA,GAAmB,EAAO,WAAW,GAAK,IAC1C,EAAI,SAAS,CAAC,UADsD,KACtC,WAI9B,GAAgB,CAAC,EAAI,SAAS,CAAC,kBAAkB,AACjD,EAAI,SAAS,CAAC,gBAAiB,GAAsB,IAEzD,IAAM,EAAU,EAAO,SAAS,CAAG,KAAO,EAAO,iBAAiB,GAClE,GAAI,GAAiB,AAAY,SAAM,CACnC,IAAM,EAAO,C2BTO,CAAC,EAAS,GAAO,CAAK,GAEvC,CADQ,EAAO,MAAQ,GAAA,EACd,CAtBO,AAAC,IACxB,IAAM,EAAM,EAAI,MAAM,CAClB,EAAI,EAAG,EAAK,EAAG,EAAK,KAAQ,EAAK,EAAG,EAAK,MAAQ,EAAK,EAAG,EAAK,MAAQ,EAAK,EAAG,EAAK,MACvF,KAAM,EAAI,GACN,CADU,EACJ,EAAI,UAAU,CAAC,KACrB,EAAU,IAAL,EACL,EAAU,IAAL,EACL,EAAU,IAAL,EACL,EAAU,IAAL,EACL,GAAM,GAAM,EACZ,GAAM,GAAM,EACZ,GAAM,IAAO,GACb,EAAU,MAAL,EACL,GAAM,IAAO,GACb,EAAU,MAAL,EACL,EAAK,GAAM,EAAD,EAAQ,EAAA,CAAE,CAAI,MACxB,EAAU,MAAL,EAET,MAAO,CAAM,GAAL,CAAK,CAAE,CAAI,gBAAuB,YAAL,EAAkB,AAAK,QAAQ,CAAC,EAAK,IAAM,CAAC,CACrF,EAG4B,GAAS,QAAQ,CAAC,IAAM,EAAQ,MAAM,CAAC,QAAQ,CAAC,IAAM,GAClF,E3BMkC,C2BJlC,E3BKQ,GAA+B,AAhC/B,CAgCI,EA1BJ,AA0B0B,EA1BtB,CANE,CAgCgC,OA1BzB,CAAC,QAAQ,EAEtB,CAAA,C2BmBwB,C3BnBxB,GAAA,OAAA,AAAK,EAAC,AAwBe,EAxBX,OAAO,CAAE,CACnB,MACJ,IAAI,CACA,EAAI,UAAU,CAAG,IACjB,EAAI,GAAG,GACA,GAoBH,MAER,CAOA,CANI,CAAC,EAAI,SAAS,CAAC,iBAAmB,EAAO,WAAW,EAAE,AACtD,EAAI,SAAS,CAAC,eAAgB,EAAO,WAAW,EAEhD,GACA,EAAI,IADK,KACI,CAAC,iBAAkB,OAAO,UAAU,CAAC,IAEnC,QAAQ,CAAvB,EAAI,MAAM,EACV,EAAI,GAAG,CAAC,MAGI,MAAM,CAAlB,EACA,EAAI,GAAG,CAAC,GAIZ,MAAM,EAAO,kBAAkB,CAAC,EACpC,ClBzCA,CkB2CA,GlB3CA,GAAA,EAAA,CAAA,CAAA,O8BbO,IAAM,GAAyB,gBZwDE,sSNvDlC,CkBCN,ElBDmC,6BACU,GAAuB,GkBA/B,GlBAqC,qBZgBhD,CAAC,CAAE,QAAS,CAAe,QAAE,CAAM,UAAE,CAAQ,aAAE,CAAW,CAAE,iBAAe,gBAAE,CAAc,gBAAE,CAAc,oBAAE,CAAkB,CAAE,GAChJ,eAAuB,AAAR,CAAW,CAAE,CAAG,CAAE,CAAG,MACnC,EAA0C,EA+EtC,EYzFM,EANF,EZiBR,EAAY,GYXO,EANF,AZiBA,EAAE,AACnB,EAAe,EAAK,+BAAgC,QAAQ,MAAM,CAAC,MAAM,IAE7E,IAAI,EAAU,EAKV,EAAU,EAAQ,OAAO,CAAC,WAAY,KAAO,IAMjD,IAAM,EAAgB,MAAM,EAAY,OAAO,CAAC,EAAK,EAAK,CACtD,UACA,mBAHE,CAAA,CAIN,GACA,GAAI,CAAC,EAAe,CAChB,EAAI,UAAU,CAAG,IACjB,EAAI,GAAG,CAAC,eACS,MAAjB,CAAwB,CAApB,IAAyB,KAAhB,EAAoB,EAAI,SAAS,CAAC,IAAI,CAAC,EAAK,QAAQ,OAAO,IACxE,MACJ,CACA,IAAM,GAAgB,CAAoC,EAAe,EAAK,GAAhD,YACxB,EAAY,WAEa,MAAvB,EAA8B,KAAK,EAAI,EAAoB,SAAA,AAAS,EAAE,AACtE,MAAM,EAAoB,SAAS,CAAC,EAAK,EAAK,GAAW,GAEzD,EAAI,GAAG,CAAC,+BAEhB,EACM,SAAE,CAAO,OAAE,CAAK,QAAE,CAAM,WAAE,CAAS,CAAE,eAAa,kBAAE,CAAgB,eAAE,CAAa,uBAAE,CAAqB,kBAAE,CAAgB,qBAAE,CAAmB,uBAAE,CAAqB,mBAAE,CAAiB,aAAE,CAAW,sBAAE,CAAoB,yBAAE,CAAuB,QAAE,CAAM,SAAE,CAAO,eAAE,CAAa,qBAAE,CAAmB,YAAE,CAAU,kBAAE,CAAgB,yBAAE,CAAuB,CAAE,CAAG,EACxW,EAA+C,MAAvB,CAA8B,EAAS,AAA8D,GAAlE,IAAK,AAAoE,EAAtC,EAAoB,CAAuB,KAAvB,AAAM,GAA8G,AAAzF,OAAC,EAA2C,EAA4B,YAAA,AAAY,EAAY,KAAK,EAAI,EAAyC,qBAAqB,CACpT,GAAiB,CAAQ,EACzB,EAAiB,EAAQ,EACzB,GAAiB,CAAQ,EACzB,IAAqB,CAAQ,CAAC,EAAS,OAAO,EAAI,CAAA,CAAQ,CAAE,eAAe,CAC7E,GAAW,KACX,IAAgB,EAChB,GAAoB,EAAc,iBAAiB,GAAK,CAAD,EAAmB,CAAA,CAAc,CACtF,GAAY,AAAY,WACxB,GAAwB,SAAZ,EACZ,GAA0B,YAAZ,EASpB,GARK,EAAY,KAAK,EAAK,EAAD,EAAgB,IACtC,GAAW,CAAA,EAAG,EAAS,CAAC,CAAC,EAD6B,AAC3B,EAAA,CAAQ,CAAG,GAAA,EAAK,CAAa,MAAZ,GAAwC,MAArB,CAAqB,CAAG,EAAK,EAAS,GAAK,EAAA,CAAkB,EACxH,IAAa,IAAa,EAAA,GAAa,CACvC,GAAW,CAAA,EAAG,EAAS,CAAC,CAAC,EAAE,EAAA,CAAQ,CAAG,GAAA,EAAK,EAAA,CAAA,AAAS,EAGxD,GAAwB,WAAb,GAAwB,IAAM,IAEzC,GAAkB,CAAC,EAAa,CAChC,IAAM,EAAkB,GAAoB,EAAS,GAAc,EAAkB,CAAC,CAAC,EAAE,EAAA,CAAQ,EAAI,GAC/F,GAAgB,CAAQ,EAAkB,MAAM,CAAC,EAAgB,EAAK,EAAkB,cAAc,CAAC,QAAQ,CAAC,GAChH,EAAgB,EAAkB,aAAa,CAAC,EAAQ,CAC9D,GAAI,EAAe,CACf,IAA+B,IAA3B,EAAc,QAAQ,EAAc,CAAC,EAAe,CACpD,GAAI,EAAW,YAAY,CAAC,WAAW,CACnC,CADqC,MAC9B,MAAM,GAEjB,OAAM,IAAI,GAAA,eACd,AAD6B,CAES,UAAlC,EAA8C,KAAvC,EAAc,QAAQ,EAAkB,GAAkB,KACjE,IAAgB,CAAA,CAExB,CACJ,EAII,AARwE,KAAoB,AY1E7F,IZkFwB,EAAI,KYlFjB,CZkFO,CAAiB,CAAC,WYlFX,EZkFwB,EAAI,GYxFrD,GAA2B,IAAI,CAAC,IAGhC,GAAuB,IAAI,CAGiB,AAHhB,EAGgB,GZkFgB,CAAA,GAAe,CAC1E,IAAgB,CAAA,EAEpB,IAAM,GAAS,IACT,GAAa,GAAO,kBAAkB,GAC5C,GAAI,CAEA,IAAM,EAAS,EAAI,MAAM,EAAI,MACvB,EAAc,EAAU,CAC1B,SAAU,EAAW,aAAa,CAAG,CAAA,EAAG,EAAA,EAA0B,CAAC,EAAwB,QAAQ,CAAC,MAAS,CAA8C,CAA/C,KAAE,GAAsB,EAAU,QAAA,AAAQ,EAAY,KAAK,EAAI,EAAoB,QAAQ,CAAC,IAAA,CAAI,CAAI,IAAM,GAAA,CAAI,CAAG,GAAoB,GAA2B,KAE5Q,MAAO,EAAiB,CAAC,EAAI,CACjC,GACM,EAAiB,MAAO,QAgQd,EA2BJ,MAlDJ,EAxOE,EAAoB,MAAO,oBAAE,CAAkB,CAAE,IACnD,IAAI,EACJ,IAAM,EAAW,UACb,GAAI,KACI,EuBhHM,EvBiHV,MuBjHkB,CvBiHX,MAAM,EAAY,MAAM,CAAC,EAAK,EAAK,CACtC,MAAO,GAAkB,CAAC,EAAwB,CAC9C,GAAG,CAAM,AACb,EAAI,CACA,GAAG,CAAK,CACR,GAAG,CACP,AADa,SAEb,EACA,KAAM,EACN,cAAe,aACX,EACA,WAAY,GACZ,8BAA+B,EAAe,EAAK,gCACvD,EACA,cAAe,SACX,EACA,cAAc,EAA+B,MAAvB,EAA8B,KAAK,EAAI,EAAoB,cAAA,AAAc,QAAK,EACpG,YAAY,CAAA,CAAA,CAChB,EACA,WAAY,QACR,cACA,EACA,KAAM,EACN,WAAY,GAAU,CAAC,EACvB,UmBzIzB,CnByIoC,CmBzIhC,OAAO,EnByIwC,EmBzIpC,AnB0IU,aAAc,iBACd,iBACA,qBACA,EACA,wBAAyB,CAAC,EAC1B,cAAe,EAAkB,EAAwB,mBACzD,wBACA,EACA,YAAa,EAAW,WAAW,CACnC,aAAc,EAAkB,OAAO,CACvC,OAAQ,EAAW,MAAM,CACzB,iBAAkB,EAAW,MAAM,CACnC,aAAa,CAAQ,EAAW,YAAY,CAAC,WAAW,CACxD,mBAAmB,CAAQ,EAAW,YAAY,CAAC,iBAAiB,CACpE,cAAe,AAAwC,OAAvC,EAAmB,EAAW,IAAA,AAAI,EAAY,KAAK,EAAI,EAAiB,OAAO,CAC/F,YAAa,EAAW,WAAW,CACnC,mBAvHtB,CAAA,EAwHsB,SAAU,EAAW,QAAQ,CAC7B,wBAAyB,EAAW,YAAY,CAAC,uBAAuB,CACxE,mBAAoB,EAAW,YAAY,CAAC,kBAAkB,uBAC9D,EACA,aAAc,CACV,oBAAqB,EAAW,YAAY,CAAC,mBAAmB,EAAI,EAAE,AAC1E,SACA,EACA,wBACA,EACA,aAAqC,MAAvB,EAA8B,KAAK,EAAI,EAAoB,YAAY,CACrF,kBAAmB,KAAsB,GAAkB,CAAA,CAAc,WAAjC,EACxC,EAIA,eAAgB,GAAkB,GAAqB,EAAU,CAG7D,SAAU,MAAsC,EuB7K/E,GAAc,GAAY,IAAK,EvB6K8B,cuBzK9D,AAAa,AAJmC,UAIzB,EAD3B,EAAW,EAAS,OAAO,CAAC,0BAA2B,IAAI,OAAO,CAAC,UAAW,GAAA,EAEnE,IAEJ,GvBsKiG,EACpE,MAAO,CACX,GAAK,uBACL,EACA,WAAY,EAAe,EAAK,mBAChC,IAAK,EAAe,EAAK,eACzB,IAAK,EAAY,KAAK,CAEtB,QAAS,GAAA,OAAI,CAAC,IAAI,CAAC,AAA4B,QAAQ,GAAG,GAAI,EAAY,SAA9B,SAAgD,CAAE,EAAY,OAAO,CACrH,CACJ,GAAG,IAAI,CAAC,AAAC,IACL,GAAM,CAAE,UAAQ,CAAE,CAAG,EACjB,EAAe,EAAS,YAAY,OACxC,AAAI,eAAgB,GAAY,EAAS,UAAU,CACxC,CAD0C,AAE7C,MAAO,kBACP,CACJ,EAGA,EAAS,UAAU,CACZ,CADc,AAEjB,MAAO,CACH,KAAM,GAAgB,QAAQ,CAC9B,MAAO,EAAS,QAAQ,EAAI,EAAS,UAAU,AACnD,eACA,CACJ,EAEG,CACH,MAAO,CACH,KAAM,GAAgB,KAAK,CAC3B,KAAM,EACN,SAAU,EAAa,QAAQ,CAAC,QAAQ,CACxC,QAAS,EAAa,QAAQ,CAAC,OAAO,CACtC,OAAQ,EAAa,QAAQ,CAAC,UAAU,AAC5C,eACA,CACJ,CACJ,GAAG,OAAO,CAAC,KACP,GAAI,CAAC,EAAM,OACX,EAAK,aAAa,CAAC,CACf,mBAAoB,EAAI,UAAU,CAClC,YAAY,CAChB,GACA,IAAM,EAAqB,GAAO,qBAAqB,GAEvD,GAAI,CAAC,EACD,OAEJ,GAAI,EAAmB,GAAG,CAAC,EAHF,kBAGwB,EAAe,aAAa,CAAE,YAC3E,QAAQ,IAAI,CAAC,CAAC,2BAA2B,EAAE,EAAmB,GAAG,CAAC,kBAAkB,qEAAqE,CAAC,EAG9J,IAAM,EAAQ,EAAmB,GAAG,CAAC,cACrC,GAAI,EAAO,CACP,IAAM,EAAO,CAAA,EAAG,EAAO,CAAC,EAAE,EAAA,CAAO,CACjC,EAAK,aAAa,CAAC,CACf,aAAc,EACd,aAAc,EACd,iBAAkB,CACtB,GACA,EAAK,UAAU,CAAC,EACpB,MACI,CADG,CACE,UAAU,CAAC,CAAA,EAAG,EAAO,CAAC,EAAE,EAAA,CAAS,CAE9C,EACJ,CAAE,MAAO,EAAK,CAcV,MAX0B,AAAtB,QAA6B,KAAK,EAAI,EAAmB,OAAA,AAAO,EAAE,CAClE,MAAM,EAAY,cAAc,CAAC,EAAK,EAAK,CACvC,WAAY,eACZ,UAAW,EACX,UAAW,SACX,iBAAkB,EAAoB,CAClC,mBAAoB,uBACpB,CACJ,EACJ,EAAG,GAED,CACV,CACJ,EAMA,GAHI,IACA,IAAgB,CAAA,EAEhB,GAAe,CACf,IAAM,CAJc,CAIK,MAAM,EAAY,gBAAgB,CAAC,GAAK,GAAG,CAAC,EAAY,KAAK,CAAG,KAAO,EAAS,CAAC,CAAC,EAAE,EAAA,EAAS,EAAA,CAAS,CAAG,EAAS,MAAO,CAAE,mBAAoB,EAA6B,IAAI,CAAE,GACvM,AAAK,EAAY,EAAb,GAAkB,CAGf,CAHiB,GACb,GAAqB,GAGjC,CACC,UAAW,EAAA,SAAS,CAAC,KAAK,CAC1B,YAAY,EACZ,mBAAmB,EACnB,sBAAsB,EACtB,iBAAkB,MAAM,EAAY,mBAAmB,CAAC,EAAK,EAAY,EAAmB,GAC5F,UAAW,EAAI,SACnB,AAD4B,GAE5B,GAAI,EAKA,OAFA,OAAO,EAHW,AAGM,YAAY,CACpC,EAAiB,MAAM,CAAG,GACnB,CAEf,OACA,AAAI,CAAC,GAAiB,GAAwB,GAA2B,CAAC,GACtE,EAAI,UAAU,CAAG,IADyE,AAG1F,EAAI,SAAS,CAAC,iBAAkB,eAChC,EAAI,GAAG,CAAC,gCACD,MAEP,IAAiB,CAAuB,MAAtB,CAA6B,EAAS,AAA0D,GAA9D,IAAK,EAA4B,EAAmB,KAAA,AAAK,EAAY,KAAK,EAAI,EAA0B,IAAI,IAAM,GAAgB,KAAK,CACpL,CADsL,AAEzL,MAAO,CACH,KAAM,GAAgB,KAAK,CAC3B,KAAM,IAAI,GAAa,OAAO,IAAI,CAAC,EAAmB,KAAK,CAAC,IAAI,EAAG,CAC/D,YAAa,GACb,SAAU,CACN,WAAY,EAAmB,KAAK,CAAC,MAAM,CAC3C,QAAS,EAAmB,KAAK,CAAC,OACtC,AAD6C,CAEjD,GACA,SAAU,CAAC,EACX,OAAQ,EAAmB,KAAK,CAAC,MAAM,CACvC,QAAS,EAAmB,KAAK,CAAC,OAAO,AAC7C,EACA,aAAc,CACV,WAAY,EACZ,YAAQ,CACZ,CACJ,EAEG,GACX,EACM,EAAS,MAAM,EAAY,cAAc,CAAC,UAC5C,OACA,aACA,EACA,UAAW,EAAA,SAAS,CAAC,KAAK,sBAC1B,0BACA,EACA,UAAW,EAAI,SAAS,CACxB,kBAAmB,oBACnB,gBACA,CACJ,GAQA,IAJI,AAIA,KAJ6B,MAAV,EAAiB,IAAnB,CAAC,AAAuB,EAAI,EAAO,MAAA,AAAM,GAAG,CAC7D,IAAgB,CAAA,EAGf,GAOL,GAJI,EAHS,CAGS,CAAC,GACnB,EAAI,SAAS,CADqB,AACpB,iBAAkB,EAAuB,cAAgB,EAAO,MAAM,CAAG,OAAS,EAAO,OAAO,CAAG,QAAU,OAG3H,CAAC,GAAkB,GACf,AAAC,EAAI,SAAS,CADgB,AACf,kBAAkB,CACjC,EAAe,CACX,WAAY,EACZ,YAAQ,EACZ,OAED,GAAI,GAAW,CAClB,IAAM,EAAqB,EAAe,EAAK,sBAC/C,EAAe,CACX,WAAY,KAA8B,IAAvB,EAAqC,EAAI,EAC5D,YAAQ,CACZ,CACJ,MAAO,GAAI,GACP,EAAe,CACX,KAFc,MAEF,EACZ,YAAQ,CACZ,OACG,GAAI,EAAO,YAAY,CAG1B,CAH4B,EAGkB,UAA1C,OAAO,EAAO,YAAY,CAAC,UAAU,CAAe,CAEpD,GAAI,EAAO,YAAY,CAAC,UAAU,CAAG,EACjC,CADoC,KAC9B,OAAO,cAAc,CAAC,AAAI,MAAM,CAAC,2CAA2C,EAAE,EAAO,YAAY,CAAC,UAAU,CAAC,IAAI,CAAC,EAAG,oBAAqB,CAC5I,MAAO,MACP,YAAY,EACZ,cAAc,CAClB,GAEJ,EAAe,CACX,WAAY,EAAO,YAAY,CAAC,UAAU,CAC1C,OAAQ,CAAC,AAAgD,OAA/C,EAAuB,EAAO,YAAA,AAAY,EAAY,KAAK,EAAI,EAAqB,MAAA,AAAM,GAAK,EAAW,UAAU,AAClI,CACJ,MAEI,CAFG,CAEY,CACX,WWlWE,CXkWU,OACZ,YAAQ,CACZ,EASR,GAJI,GAAgB,CAAC,EAAI,SAAS,CAAC,kBAAkB,AACjD,EAAI,SAAS,CAAC,gBAAiB,GAAsB,IAGrD,CAAC,EAAO,KAAK,EAAE,KAQf,CAFA,EAAe,EAAK,qBAAsB,AAAiD,OAAhD,EAAwB,EAAO,YAAY,AAAZ,EAAwB,KAAK,EAAI,EAAsB,UAAU,EAC3I,EAAI,UAAU,CAAG,IACb,SACA,EAAI,GAAG,CAAC,IADW,iBAIhB,MAAM,IAEjB,GAAI,EAAO,KAAK,CAAC,IAAI,GAAK,GAAgB,QAAQ,CAC9C,CADgD,GAC5C,GA2BA,OADA,MAAM,CArBiB,AAAC,IACpB,MAAM,EAAW,CACb,YAAa,EAAS,SAAS,CAAC,YAAY,CAC5C,WAAY,EAAS,SAAS,CAAC,mBAAmB,CAClD,SAAU,EAAS,SAAS,CAAC,sBAAsB,AACvD,EACM,EAA+B,AgBzZtD,EAAM,ShByZ8B,CgBzZpB,EAAK,EAAD,CAAO,SAAS,CAAG,GAAmB,iBAAiB,CAAG,GAAmB,iBAAA,AAAiB,EhB0Z3F,UAAE,CAAQ,CAAE,CAAG,EACjB,IAAkC,IAAtB,EAAS,QAAQ,EAAc,EAAS,WAAW,CAAC,UAAU,CAAC,MAAM,CACjF,EAAS,WAAW,CAAG,CAAA,EAAG,EAAA,EAAW,EAAS,WAAW,CAAA,CAAA,AAAE,EAE3D,EAAS,WAAW,CAAC,UAAU,CAAC,MAAM,CsB3X5D,EtB4XsE,AsB5X3D,EtB4XoE,WAAW,CsB5X3E,KAAK,CAAC,KtB4XC,EAAS,WAAW,CsB3X7B,AACZ,CADoB,CAAC,AtB2XuB,EsB3XrB,CAG7B,MAFgB,CAET,CAAC,MAAO,KAAK,OAAO,CAAC,SAAU,KAAQ,EAAD,AAAS,CAAC,EAAE,CAAG,CAAC,CAAC,EAAE,EAAS,KAAK,CAAC,GAAG,IAFN,AAEU,CAAC,KAAA,CAAM,CAAG,EAAA,CAAE,EtB0X3E,EAAI,UAAU,CAAG,EACjB,EAAI,SAAS,CAAC,WAAY,EAAS,WAAW,EAC1C,IAAe,GAAmB,iBAAiB,EAAE,AACrD,EAAI,SAAS,CAAC,UAAW,CAAC,MAAM,EAAE,EAAS,WAAW,CAAA,CAAE,EAE5D,EAAI,GAAG,CAAC,EAAS,WAAW,EAChC,EACqB,EAAO,KAAK,CAAC,KAAK,EAChC,SA3BY,CACnB,EAAI,SAAS,CAAC,eAAgB,IAC9B,EAAI,GAAG,CAAC,KAAK,SAAS,CAAC,EAAO,KAAK,CAAC,KAAK,GACzC,MACJ,CA0BJ,GAAI,EAAO,CA1BA,IA0BK,CAAC,IAAI,GAAK,GAAgB,KAAK,CAC3C,CAD6C,KACvC,OAAO,cAAc,CAAC,AAAI,MAAM,CAAC,0DAA0D,CAAC,EAAG,oBAAqB,CACtH,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,GAYJ,GATI,EAAY,KAAK,EAAE,AACnB,EAAI,SAAS,CAAC,gBAAiB,6BAG/B,GACA,EAAI,QADS,CACA,CAAC,gBAAiB,2DAI/B,EAAe,EAAK,sBAAwB,IAAe,GAAoC,KAAK,CAAxB,EAAI,UAAU,CAC1F,OAAO,IAEX,OAAM,GAAiB,KACnB,MACA,EAGA,QAAQ,IAAsB,IAAgB,GAGzC,EAAO,KAAK,CAH4B,AAG3B,EAHW,EAGP,CAHoC,IAAI,GAAa,OAAO,IAAI,CAAC,KAAK,SAAS,CAAC,EAAO,KAAK,CAAC,QAAQ,GAAI,CAC3H,YAAa,GACb,SAAU,EAAO,KAAK,CAAC,IAAI,CAAC,QAAQ,AACxC,GACA,cAAe,EAAW,aAAa,CACvC,gBAAiB,EAAW,eAAe,CAC3C,aAAc,EAAY,KAAK,MAAG,EAAY,CAClD,GACJ,EAGI,GACA,MAAM,GADM,CAGZ,MAAM,GAAO,qBAAqB,CAAC,EAAI,OAAO,CAAE,IAAI,GAAO,KAAK,CAAC,EAAe,aAAa,CAAE,CACvF,SAAU,CAAA,EAAG,EAAO,CAAC,EAAE,EAAA,CAAS,CAChC,KAAM,EAAS,MAAM,CACrB,WAAY,CACR,cAAe,EACf,cAAe,EAAI,GACvB,AAD0B,CAE9B,EAAG,GAEf,CAAE,MAAO,EAAK,CAaV,MAZI,AAAE,CAAD,YAAgB,GAAA,eAAe,EAChC,CADmC,KAC7B,EAAY,cAAc,CAAC,EAAK,EAAK,CACvC,WAAY,eACZ,UAAW,EACX,UAAW,SACX,iBAAkB,EAAoB,CAClC,mBAAoB,uBACpB,CACJ,EACJ,EAAG,GAGD,CACV,CACJ","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60]}