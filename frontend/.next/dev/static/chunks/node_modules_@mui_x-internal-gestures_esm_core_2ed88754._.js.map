{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/ActiveGesturesRegistry.js"],"sourcesContent":["/**\r\n * ActiveGesturesRegistry - Centralized registry for tracking which gestures are active on elements\r\n *\r\n * This singleton class keeps track of all gesture instances that are currently in their active state,\r\n * allowing both the system and applications to query which gestures are active on specific elements.\r\n */\r\n\r\n/**\r\n * Type for entries in the active gestures registry\r\n */\r\n\r\n/**\r\n * Registry that maintains a record of all currently active gestures across elements\r\n */\r\nexport class ActiveGesturesRegistry {\r\n  /** Map of elements to their active gestures */\r\n  activeGestures = (() => new Map())();\r\n\r\n  /**\r\n   * Register a gesture as active on an element\r\n   *\r\n   * @param element - The DOM element on which the gesture is active\r\n   * @param gesture - The gesture instance that is active\r\n   */\r\n  registerActiveGesture(element, gesture) {\r\n    if (!this.activeGestures.has(element)) {\r\n      this.activeGestures.set(element, new Set());\r\n    }\r\n    const elementGestures = this.activeGestures.get(element);\r\n    const entry = {\r\n      gesture,\r\n      element\r\n    };\r\n    elementGestures.add(entry);\r\n  }\r\n\r\n  /**\r\n   * Remove a gesture from the active registry\r\n   *\r\n   * @param element - The DOM element on which the gesture was active\r\n   * @param gesture - The gesture instance to deactivate\r\n   */\r\n  unregisterActiveGesture(element, gesture) {\r\n    const elementGestures = this.activeGestures.get(element);\r\n    if (!elementGestures) {\r\n      return;\r\n    }\r\n\r\n    // Find and remove the specific gesture entry\r\n    elementGestures.forEach(entry => {\r\n      if (entry.gesture === gesture) {\r\n        elementGestures.delete(entry);\r\n      }\r\n    });\r\n\r\n    // Remove the element from the map if it no longer has any active gestures\r\n    if (elementGestures.size === 0) {\r\n      this.activeGestures.delete(element);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all active gestures for a specific element\r\n   *\r\n   * @param element - The DOM element to query\r\n   * @returns Array of active gesture names\r\n   */\r\n  getActiveGestures(element) {\r\n    const elementGestures = this.activeGestures.get(element);\r\n    if (!elementGestures) {\r\n      return {};\r\n    }\r\n    return Array.from(elementGestures).reduce((acc, entry) => {\r\n      acc[entry.gesture.name] = true;\r\n      return acc;\r\n    }, {});\r\n  }\r\n\r\n  /**\r\n   * Check if a specific gesture is active on an element\r\n   *\r\n   * @param element - The DOM element to check\r\n   * @param gesture - The gesture instance to check\r\n   * @returns True if the gesture is active on the element, false otherwise\r\n   */\r\n  isGestureActive(element, gesture) {\r\n    const elementGestures = this.activeGestures.get(element);\r\n    if (!elementGestures) {\r\n      return false;\r\n    }\r\n    return Array.from(elementGestures).some(entry => entry.gesture === gesture);\r\n  }\r\n\r\n  /**\r\n   * Clear all active gestures from the registry\r\n   */\r\n  destroy() {\r\n    this.activeGestures.clear();\r\n  }\r\n\r\n  /**\r\n   * Clear all active gestures for a specific element\r\n   *\r\n   * @param element - The DOM element to clear\r\n   */\r\n  unregisterElement(element) {\r\n    this.activeGestures.delete(element);\r\n  }\r\n}"],"names":[],"mappings":"AAAA;;;;;CAKC,GAED;;CAEC,GAED;;CAEC;;;;AACM,MAAM;IACX,6CAA6C,GAC7C,iBAAiB,CAAC,IAAM,IAAI,KAAK,IAAI;IAErC;;;;;GAKC,GACD,sBAAsB,OAAO,EAAE,OAAO,EAAE;QACtC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,UAAU;YACrC,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,SAAS,IAAI;QACvC;QACA,MAAM,kBAAkB,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC;QAChD,MAAM,QAAQ;YACZ;YACA;QACF;QACA,gBAAgB,GAAG,CAAC;IACtB;IAEA;;;;;GAKC,GACD,wBAAwB,OAAO,EAAE,OAAO,EAAE;QACxC,MAAM,kBAAkB,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC;QAChD,IAAI,CAAC,iBAAiB;YACpB;QACF;QAEA,6CAA6C;QAC7C,gBAAgB,OAAO,CAAC,CAAA;YACtB,IAAI,MAAM,OAAO,KAAK,SAAS;gBAC7B,gBAAgB,MAAM,CAAC;YACzB;QACF;QAEA,0EAA0E;QAC1E,IAAI,gBAAgB,IAAI,KAAK,GAAG;YAC9B,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC;QAC7B;IACF;IAEA;;;;;GAKC,GACD,kBAAkB,OAAO,EAAE;QACzB,MAAM,kBAAkB,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC;QAChD,IAAI,CAAC,iBAAiB;YACpB,OAAO,CAAC;QACV;QACA,OAAO,MAAM,IAAI,CAAC,iBAAiB,MAAM,CAAC,CAAC,KAAK;YAC9C,GAAG,CAAC,MAAM,OAAO,CAAC,IAAI,CAAC,GAAG;YAC1B,OAAO;QACT,GAAG,CAAC;IACN;IAEA;;;;;;GAMC,GACD,gBAAgB,OAAO,EAAE,OAAO,EAAE;QAChC,MAAM,kBAAkB,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC;QAChD,IAAI,CAAC,iBAAiB;YACpB,OAAO;QACT;QACA,OAAO,MAAM,IAAI,CAAC,iBAAiB,IAAI,CAAC,CAAA,QAAS,MAAM,OAAO,KAAK;IACrE;IAEA;;GAEC,GACD,UAAU;QACR,IAAI,CAAC,cAAc,CAAC,KAAK;IAC3B;IAEA;;;;GAIC,GACD,kBAAkB,OAAO,EAAE;QACzB,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC;IAC7B;AACF","ignoreList":[0]}},
    {"offset": {"line": 101, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/KeyboardManager.js"],"sourcesContent":["/**\r\n * KeyboardManager - Manager for keyboard events in the gesture recognition system\r\n *\r\n * This class tracks keyboard state:\r\n * 1. Capturing and tracking all pressed keys\r\n * 2. Providing methods to check if specific keys are pressed\r\n */\r\n\r\n/**\r\n * Type definition for keyboard keys\r\n */\r\n\r\n/**\r\n * Class responsible for tracking keyboard state\r\n */\r\nexport class KeyboardManager {\r\n  pressedKeys = (() => new Set())();\r\n\r\n  /**\r\n   * Create a new KeyboardManager instance\r\n   */\r\n  constructor() {\r\n    this.initialize();\r\n  }\r\n\r\n  /**\r\n   * Initialize the keyboard event listeners\r\n   */\r\n  initialize() {\r\n    if (typeof window === 'undefined') {\r\n      return;\r\n    }\r\n\r\n    // Add keyboard event listeners\r\n    window.addEventListener('keydown', this.handleKeyDown);\r\n    window.addEventListener('keyup', this.handleKeyUp);\r\n    // Reset keys when window loses focus\r\n    window.addEventListener('blur', this.clearKeys);\r\n  }\r\n\r\n  /**\r\n   * Handle keydown events\r\n   */\r\n  handleKeyDown = event => {\r\n    this.pressedKeys.add(event.key);\r\n  };\r\n\r\n  /**\r\n   * Handle keyup events\r\n   */\r\n  handleKeyUp = event => {\r\n    this.pressedKeys.delete(event.key);\r\n  };\r\n\r\n  /**\r\n   * Clear all pressed keys\r\n   */\r\n  clearKeys = () => {\r\n    this.pressedKeys.clear();\r\n  };\r\n\r\n  /**\r\n   * Check if a set of keys are all currently pressed\r\n   * @param keys The keys to check\r\n   * @returns True if all specified keys are pressed, false otherwise\r\n   */\r\n  areKeysPressed(keys) {\r\n    if (!keys || keys.length === 0) {\r\n      return true; // No keys required means the condition is satisfied\r\n    }\r\n    return keys.every(key => {\r\n      if (key === 'ControlOrMeta') {\r\n        // May be \"deprecated\" on types, but it is still the best option for cross-platform detection\r\n        // https://stackoverflow.com/a/71785253/24269134\r\n        return navigator.platform.includes('Mac') ? this.pressedKeys.has('Meta') : this.pressedKeys.has('Control');\r\n      }\r\n      return this.pressedKeys.has(key);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Cleanup method to remove event listeners\r\n   */\r\n  destroy() {\r\n    if (typeof window !== 'undefined') {\r\n      window.removeEventListener('keydown', this.handleKeyDown);\r\n      window.removeEventListener('keyup', this.handleKeyUp);\r\n      window.removeEventListener('blur', this.clearKeys);\r\n    }\r\n    this.clearKeys();\r\n  }\r\n}"],"names":[],"mappings":"AAAA;;;;;;CAMC,GAED;;CAEC,GAED;;CAEC;;;;AACM,MAAM;IACX,cAAc,CAAC,IAAM,IAAI,KAAK,IAAI;IAElC;;GAEC,GACD,aAAc;QACZ,IAAI,CAAC,UAAU;IACjB;IAEA;;GAEC,GACD,aAAa;QACX,IAAI,OAAO,WAAW,aAAa;YACjC;QACF;QAEA,+BAA+B;QAC/B,OAAO,gBAAgB,CAAC,WAAW,IAAI,CAAC,aAAa;QACrD,OAAO,gBAAgB,CAAC,SAAS,IAAI,CAAC,WAAW;QACjD,qCAAqC;QACrC,OAAO,gBAAgB,CAAC,QAAQ,IAAI,CAAC,SAAS;IAChD;IAEA;;GAEC,GACD,gBAAgB,CAAA;QACd,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,GAAG;IAChC,EAAE;IAEF;;GAEC,GACD,cAAc,CAAA;QACZ,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,MAAM,GAAG;IACnC,EAAE;IAEF;;GAEC,GACD,YAAY;QACV,IAAI,CAAC,WAAW,CAAC,KAAK;IACxB,EAAE;IAEF;;;;GAIC,GACD,eAAe,IAAI,EAAE;QACnB,IAAI,CAAC,QAAQ,KAAK,MAAM,KAAK,GAAG;YAC9B,OAAO,MAAM,oDAAoD;QACnE;QACA,OAAO,KAAK,KAAK,CAAC,CAAA;YAChB,IAAI,QAAQ,iBAAiB;gBAC3B,6FAA6F;gBAC7F,gDAAgD;gBAChD,OAAO,UAAU,QAAQ,CAAC,QAAQ,CAAC,SAAS,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,UAAU,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC;YAClG;YACA,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC;QAC9B;IACF;IAEA;;GAEC,GACD,UAAU;QACR,IAAI,OAAO,WAAW,aAAa;YACjC,OAAO,mBAAmB,CAAC,WAAW,IAAI,CAAC,aAAa;YACxD,OAAO,mBAAmB,CAAC,SAAS,IAAI,CAAC,WAAW;YACpD,OAAO,mBAAmB,CAAC,QAAQ,IAAI,CAAC,SAAS;QACnD;QACA,IAAI,CAAC,SAAS;IAChB;AACF","ignoreList":[0]}},
    {"offset": {"line": 181, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/PointerManager.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\r\n/**\r\n * PointerManager - Centralized manager for pointer events in the gesture recognition system\r\n *\r\n * This singleton class abstracts the complexity of working with pointer events by:\r\n * 1. Capturing and tracking all active pointers (touch, mouse, pen)\r\n * 2. Normalizing pointer data into a consistent format\r\n * 3. Managing pointer capture for proper tracking across elements\r\n * 4. Distributing events to registered gesture recognizers\r\n */\r\n\r\n/**\r\n * Normalized representation of a pointer, containing all relevant information\r\n * from the original PointerEvent plus additional tracking data.\r\n *\r\n * This data structure encapsulates everything gesture recognizers need to know\r\n * about a pointer's current state.\r\n */\r\n\r\n/**\r\n * Configuration options for initializing the PointerManager.\r\n */\r\n\r\n/**\r\n * Manager for handling pointer events across the application.\r\n *\r\n * PointerManager serves as the foundational layer for gesture recognition,\r\n * providing a centralized system for tracking active pointers and distributing\r\n * pointer events to gesture recognizers.\r\n *\r\n * It normalizes browser pointer events into a consistent format and simplifies\r\n * multi-touch handling by managing pointer capture and tracking multiple\r\n * simultaneous pointers.\r\n */\r\nexport class PointerManager {\r\n  /** Root element where pointer events are captured */\r\n\r\n  /** CSS touch-action property value applied to the root element */\r\n\r\n  /** Whether to use passive event listeners */\r\n\r\n  /** Whether to prevent interrupt events like blur or contextmenu */\r\n  preventEventInterruption = true;\r\n\r\n  /** Map of all currently active pointers by their pointerId */\r\n  pointers = (() => new Map())();\r\n\r\n  /** Set of registered gesture handlers that receive pointer events */\r\n  gestureHandlers = (() => new Set())();\r\n  constructor(options) {\r\n    this.root =\r\n    // User provided root element\r\n    options.root ??\r\n    // Fallback to document root or body, this fixes shadow DOM scenarios\r\n    document.getRootNode({\r\n      composed: true\r\n    }) ??\r\n    // Fallback to document body, for some testing environments\r\n    document.body;\r\n    this.touchAction = options.touchAction || 'auto';\r\n    this.passive = options.passive ?? false;\r\n    this.preventEventInterruption = options.preventEventInterruption ?? true;\r\n    this.setupEventListeners();\r\n  }\r\n\r\n  /**\r\n   * Register a handler function to receive pointer events.\r\n   *\r\n   * The handler will be called whenever pointer events occur within the root element.\r\n   * It receives the current map of all active pointers and the original event.\r\n   *\r\n   * @param {Function} handler - Function to receive pointer events and current pointer state\r\n   * @returns {Function} An unregister function that removes this handler when called\r\n   */\r\n  registerGestureHandler(handler) {\r\n    this.gestureHandlers.add(handler);\r\n\r\n    // Return unregister function\r\n    return () => {\r\n      this.gestureHandlers.delete(handler);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get a copy of the current active pointers map.\r\n   *\r\n   * Returns a new Map containing all currently active pointers.\r\n   * Modifying the returned map will not affect the internal pointers state.\r\n   *\r\n   * @returns A new Map containing all active pointers\r\n   */\r\n  getPointers() {\r\n    return new Map(this.pointers);\r\n  }\r\n\r\n  /**\r\n   * Set up event listeners for pointer events on the root element.\r\n   *\r\n   * This method attaches all necessary event listeners and configures\r\n   * the CSS touch-action property on the root element.\r\n   */\r\n  setupEventListeners() {\r\n    // Set touch-action CSS property\r\n    if (this.touchAction !== 'auto') {\r\n      this.root.style.touchAction = this.touchAction;\r\n    }\r\n\r\n    // Add event listeners\r\n    this.root.addEventListener('pointerdown', this.handlePointerEvent, {\r\n      passive: this.passive\r\n    });\r\n    this.root.addEventListener('pointermove', this.handlePointerEvent, {\r\n      passive: this.passive\r\n    });\r\n    this.root.addEventListener('pointerup', this.handlePointerEvent, {\r\n      passive: this.passive\r\n    });\r\n    this.root.addEventListener('pointercancel', this.handlePointerEvent, {\r\n      passive: this.passive\r\n    });\r\n    // @ts-expect-error, forceCancel is not a standard event, but used for custom handling\r\n    this.root.addEventListener('forceCancel', this.handlePointerEvent, {\r\n      passive: this.passive\r\n    });\r\n\r\n    // Add blur and contextmenu event listeners to interrupt all gestures\r\n    this.root.addEventListener('blur', this.handleInterruptEvents);\r\n    this.root.addEventListener('contextmenu', this.handleInterruptEvents);\r\n  }\r\n\r\n  /**\r\n   * Handle events that should interrupt all gestures.\r\n   * This clears all active pointers and notifies handlers with a pointercancel-like event.\r\n   *\r\n   * @param event - The event that triggered the interruption (blur or contextmenu)\r\n   */\r\n  handleInterruptEvents = event => {\r\n    if (this.preventEventInterruption && 'pointerType' in event && event.pointerType === 'touch') {\r\n      event.preventDefault();\r\n      return;\r\n    }\r\n\r\n    // Create a synthetic pointer cancel event\r\n    const cancelEvent = new PointerEvent('forceCancel', {\r\n      bubbles: false,\r\n      cancelable: false\r\n    });\r\n    const firstPointer = this.pointers.values().next().value;\r\n    if (this.pointers.size > 0 && firstPointer) {\r\n      // If there are active pointers, use the first one as a template for coordinates\r\n\r\n      // Update the synthetic event with the pointer's coordinates\r\n      Object.defineProperties(cancelEvent, {\r\n        clientX: {\r\n          value: firstPointer.clientX\r\n        },\r\n        clientY: {\r\n          value: firstPointer.clientY\r\n        },\r\n        pointerId: {\r\n          value: firstPointer.pointerId\r\n        },\r\n        pointerType: {\r\n          value: firstPointer.pointerType\r\n        }\r\n      });\r\n\r\n      // Force update of all pointers to have type 'forceCancel'\r\n      for (const [pointerId, pointer] of this.pointers.entries()) {\r\n        const updatedPointer = _extends({}, pointer, {\r\n          type: 'forceCancel'\r\n        });\r\n        this.pointers.set(pointerId, updatedPointer);\r\n      }\r\n    }\r\n\r\n    // Notify all handlers about the interruption\r\n    this.notifyHandlers(cancelEvent);\r\n\r\n    // Clear all pointers\r\n    this.pointers.clear();\r\n  };\r\n\r\n  /**\r\n   * Event handler for all pointer events.\r\n   *\r\n   * This method:\r\n   * 1. Updates the internal pointers map based on the event type\r\n   * 2. Manages pointer capture for tracking pointers outside the root element\r\n   * 3. Notifies all registered handlers with the current state\r\n   *\r\n   * @param event - The original pointer event from the browser\r\n   */\r\n  handlePointerEvent = event => {\r\n    const {\r\n      type,\r\n      pointerId\r\n    } = event;\r\n\r\n    // Create or update pointer data\r\n    if (type === 'pointerdown' || type === 'pointermove') {\r\n      this.pointers.set(pointerId, this.createPointerData(event));\r\n    }\r\n    // Remove pointer data on up or cancel\r\n    else if (type === 'pointerup' || type === 'pointercancel' || type === 'forceCancel') {\r\n      // Update one last time before removing\r\n      this.pointers.set(pointerId, this.createPointerData(event));\r\n\r\n      // Notify handlers with current state\r\n      this.notifyHandlers(event);\r\n\r\n      // Then remove the pointer\r\n      this.pointers.delete(pointerId);\r\n      return;\r\n    }\r\n    this.notifyHandlers(event);\r\n  };\r\n\r\n  /**\r\n   * Notify all registered gesture handlers about a pointer event.\r\n   *\r\n   * Each handler receives the current map of active pointers and the original event.\r\n   *\r\n   * @param event - The original pointer event that triggered this notification\r\n   */\r\n  notifyHandlers(event) {\r\n    this.gestureHandlers.forEach(handler => handler(this.pointers, event));\r\n  }\r\n\r\n  /**\r\n   * Create a normalized PointerData object from a browser PointerEvent.\r\n   *\r\n   * This method extracts all relevant information from the original event\r\n   * and formats it in a consistent way for gesture recognizers to use.\r\n   *\r\n   * @param event - The original browser pointer event\r\n   * @returns A new PointerData object representing this pointer\r\n   */\r\n  createPointerData(event) {\r\n    return {\r\n      pointerId: event.pointerId,\r\n      clientX: event.clientX,\r\n      clientY: event.clientY,\r\n      pageX: event.pageX,\r\n      pageY: event.pageY,\r\n      target: event.target,\r\n      timeStamp: event.timeStamp,\r\n      type: event.type,\r\n      isPrimary: event.isPrimary,\r\n      pressure: event.pressure,\r\n      width: event.width,\r\n      height: event.height,\r\n      pointerType: event.pointerType,\r\n      srcEvent: event\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clean up all event listeners and reset the PointerManager state.\r\n   *\r\n   * This method should be called when the PointerManager is no longer needed\r\n   * to prevent memory leaks. It removes all event listeners, clears the\r\n   * internal state, and resets the singleton instance.\r\n   */\r\n  destroy() {\r\n    this.root.removeEventListener('pointerdown', this.handlePointerEvent);\r\n    this.root.removeEventListener('pointermove', this.handlePointerEvent);\r\n    this.root.removeEventListener('pointerup', this.handlePointerEvent);\r\n    this.root.removeEventListener('pointercancel', this.handlePointerEvent);\r\n    // @ts-expect-error, forceCancel is not a standard event, but used for custom handling\r\n    this.root.removeEventListener('forceCancel', this.handlePointerEvent);\r\n    this.root.removeEventListener('blur', this.handleInterruptEvents);\r\n    this.root.removeEventListener('contextmenu', this.handleInterruptEvents);\r\n    this.pointers.clear();\r\n    this.gestureHandlers.clear();\r\n  }\r\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 388, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/GestureManager.js"],"sourcesContent":["import { ActiveGesturesRegistry } from \"./ActiveGesturesRegistry.js\";\r\nimport { KeyboardManager } from \"./KeyboardManager.js\";\r\nimport { PointerManager } from \"./PointerManager.js\";\r\n\r\n/**\r\n * Configuration options for initializing the GestureManager\r\n */\r\n\r\n/**\r\n * The primary class responsible for setting up and managing gestures across multiple elements.\r\n *\r\n * GestureManager maintains a collection of gesture templates that can be instantiated for\r\n * specific DOM elements. It handles lifecycle management, event dispatching, and cleanup.\r\n *\r\n * @example\r\n * ```typescript\r\n * // Basic setup with default gestures\r\n * const manager = new GestureManager({\r\n *   root: document.body,\r\n *   touchAction: 'none',\r\n *   gestures: [\r\n *     new PanGesture({ name: 'pan' }),\r\n *   ],\r\n * });\r\n *\r\n * // Register pan gestures on an element\r\n * const element = manager.registerElement('pan', document.querySelector('.draggable'));\r\n *\r\n * // Add event listeners with proper typing\r\n * element.addEventListener('panStart', (event) => {\r\n *   console.log('Pan started');\r\n * });\r\n *\r\n * element.addEventListener('pan', (event) => {\r\n *   console.log(`Pan delta: ${event.deltaX}, ${event.deltaY}`);\r\n * });\r\n *\r\n * // Custom gesture types\r\n * interface MyGestureEvents {\r\n *   custom: { x: number, y: number }\r\n * }\r\n * const customManager = new GestureManager<MyGestureEvents>({\r\n *   root: document.body\r\n *   gestures: [\r\n *     new CustomGesture({ name: 'custom' }),\r\n *   ],\r\n * });\r\n * ```\r\n */\r\nexport class GestureManager {\r\n  /** Repository of gesture templates that can be cloned for specific elements */\r\n  gestureTemplates = (() => new Map())();\r\n\r\n  /** Maps DOM elements to their active gesture instances */\r\n  elementGestureMap = (() => new Map())();\r\n  activeGesturesRegistry = (() => new ActiveGesturesRegistry())();\r\n  keyboardManager = (() => new KeyboardManager())();\r\n\r\n  /**\r\n   * Create a new GestureManager instance to coordinate gesture recognition\r\n   *\r\n   * @param options - Configuration options for the gesture manager\r\n   */\r\n  constructor(options) {\r\n    // Initialize the PointerManager\r\n    this.pointerManager = new PointerManager({\r\n      root: options.root,\r\n      touchAction: options.touchAction,\r\n      passive: options.passive\r\n    });\r\n\r\n    // Add initial gestures as templates if provided\r\n    if (options.gestures && options.gestures.length > 0) {\r\n      options.gestures.forEach(gesture => {\r\n        this.addGestureTemplate(gesture);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a gesture template to the manager's template registry.\r\n   * Templates serve as prototypes that can be cloned for individual elements.\r\n   *\r\n   * @param gesture - The gesture instance to use as a template\r\n   */\r\n  addGestureTemplate(gesture) {\r\n    if (this.gestureTemplates.has(gesture.name)) {\r\n      console.warn(`Gesture template with name \"${gesture.name}\" already exists. It will be overwritten.`);\r\n    }\r\n    this.gestureTemplates.set(gesture.name, gesture);\r\n  }\r\n\r\n  /**\r\n   * Updates the options for a specific gesture on a given element and emits a change event.\r\n   *\r\n   * @param gestureName - Name of the gesture whose options should be updated\r\n   * @param element - The DOM element where the gesture is attached\r\n   * @param options - New options to apply to the gesture\r\n   * @returns True if the options were successfully updated, false if the gesture wasn't found\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Update pan gesture sensitivity on the fly\r\n   * manager.setGestureOptions('pan', element, { threshold: 5 });\r\n   * ```\r\n   */\r\n  setGestureOptions(gestureName, element, options) {\r\n    const elementGestures = this.elementGestureMap.get(element);\r\n    if (!elementGestures || !elementGestures.has(gestureName)) {\r\n      console.error(`Gesture \"${gestureName}\" not found on the provided element.`);\r\n      return;\r\n    }\r\n    const event = new CustomEvent(`${gestureName}ChangeOptions`, {\r\n      detail: options,\r\n      bubbles: false,\r\n      cancelable: false,\r\n      composed: false\r\n    });\r\n    element.dispatchEvent(event);\r\n  }\r\n\r\n  /**\r\n   * Updates the state for a specific gesture on a given element and emits a change event.\r\n   *\r\n   * @param gestureName - Name of the gesture whose state should be updated\r\n   * @param element - The DOM element where the gesture is attached\r\n   * @param state - New state to apply to the gesture\r\n   * @returns True if the state was successfully updated, false if the gesture wasn't found\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Update total delta for a turnWheel gesture\r\n   * manager.setGestureState('turnWheel', element, { totalDeltaX: 10 });\r\n   * ```\r\n   */\r\n  setGestureState(gestureName, element, state) {\r\n    const elementGestures = this.elementGestureMap.get(element);\r\n    if (!elementGestures || !elementGestures.has(gestureName)) {\r\n      console.error(`Gesture \"${gestureName}\" not found on the provided element.`);\r\n      return;\r\n    }\r\n    const event = new CustomEvent(`${gestureName}ChangeState`, {\r\n      detail: state,\r\n      bubbles: false,\r\n      cancelable: false,\r\n      composed: false\r\n    });\r\n    element.dispatchEvent(event);\r\n  }\r\n\r\n  /**\r\n   * Register an element to recognize one or more gestures.\r\n   *\r\n   * This method clones the specified gesture template(s) and creates\r\n   * gesture recognizer instance(s) specifically for the provided element.\r\n   * The element is returned with enhanced TypeScript typing for gesture events.\r\n   *\r\n   * @param gestureNames - Name(s) of the gesture(s) to register (must match template names)\r\n   * @param element - The DOM element to attach the gesture(s) to\r\n   * @param options - Optional map of gesture-specific options to override when registering\r\n   * @returns The same element with properly typed event listeners\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Register multiple gestures\r\n   * const element = manager.registerElement(['pan', 'pinch'], myDiv);\r\n   *\r\n   * // Register a single gesture\r\n   * const draggable = manager.registerElement('pan', dragHandle);\r\n   *\r\n   * // Register with customized options for each gesture\r\n   * const customElement = manager.registerElement(\r\n   *   ['pan', 'pinch', 'rotate'],\r\n   *   myElement,\r\n   *   {\r\n   *     pan: { threshold: 20, direction: ['left', 'right'] },\r\n   *     pinch: { threshold: 0.1 }\r\n   *   }\r\n   * );\r\n   * ```\r\n   */\r\n  registerElement(gestureNames, element, options) {\r\n    // Handle array of gesture names\r\n    if (!Array.isArray(gestureNames)) {\r\n      gestureNames = [gestureNames];\r\n    }\r\n    gestureNames.forEach(name => {\r\n      const gestureOptions = options?.[name];\r\n      this.registerSingleGesture(name, element, gestureOptions);\r\n    });\r\n    return element;\r\n  }\r\n\r\n  /**\r\n   * Internal method to register a single gesture on an element.\r\n   *\r\n   * @param gestureName - Name of the gesture to register\r\n   * @param element - DOM element to attach the gesture to\r\n   * @param options - Optional options to override the gesture template configuration\r\n   * @returns True if the registration was successful, false otherwise\r\n   */\r\n  registerSingleGesture(gestureName, element, options) {\r\n    // Find the gesture template\r\n    const gestureTemplate = this.gestureTemplates.get(gestureName);\r\n    if (!gestureTemplate) {\r\n      console.error(`Gesture template \"${gestureName}\" not found.`);\r\n      return false;\r\n    }\r\n\r\n    // Create element's gesture map if it doesn't exist\r\n    if (!this.elementGestureMap.has(element)) {\r\n      this.elementGestureMap.set(element, new Map());\r\n    }\r\n\r\n    // Check if this element already has this gesture registered\r\n    const elementGestures = this.elementGestureMap.get(element);\r\n    if (elementGestures.has(gestureName)) {\r\n      console.warn(`Element already has gesture \"${gestureName}\" registered. It will be replaced.`);\r\n      // Unregister the existing gesture first\r\n      this.unregisterElement(gestureName, element);\r\n    }\r\n\r\n    // Clone the gesture template and create a new instance with optional overrides\r\n    // This allows each element to have its own state, event listeners, and configuration\r\n    const gestureInstance = gestureTemplate.clone(options);\r\n    gestureInstance.init(element, this.pointerManager, this.activeGesturesRegistry, this.keyboardManager);\r\n\r\n    // Store the gesture in the element's gesture map\r\n    elementGestures.set(gestureName, gestureInstance);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Unregister a specific gesture from an element.\r\n   * This removes the gesture recognizer and stops event emission for that gesture.\r\n   *\r\n   * @param gestureName - Name of the gesture to unregister\r\n   * @param element - The DOM element to remove the gesture from\r\n   * @returns True if the gesture was found and removed, false otherwise\r\n   */\r\n  unregisterElement(gestureName, element) {\r\n    const elementGestures = this.elementGestureMap.get(element);\r\n    if (!elementGestures || !elementGestures.has(gestureName)) {\r\n      return false;\r\n    }\r\n\r\n    // Destroy the gesture instance\r\n    const gesture = elementGestures.get(gestureName);\r\n    gesture.destroy();\r\n\r\n    // Remove from the map\r\n    elementGestures.delete(gestureName);\r\n    this.activeGesturesRegistry.unregisterElement(element);\r\n\r\n    // Remove the element from the map if it no longer has any gestures\r\n    if (elementGestures.size === 0) {\r\n      this.elementGestureMap.delete(element);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Unregister all gestures from an element.\r\n   * Completely removes the element from the gesture system.\r\n   *\r\n   * @param element - The DOM element to remove all gestures from\r\n   */\r\n  unregisterAllGestures(element) {\r\n    const elementGestures = this.elementGestureMap.get(element);\r\n    if (elementGestures) {\r\n      // Unregister all gestures for this element\r\n      for (const [, gesture] of elementGestures) {\r\n        gesture.destroy();\r\n        this.activeGesturesRegistry.unregisterElement(element);\r\n      }\r\n\r\n      // Clear the map\r\n      this.elementGestureMap.delete(element);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up all gestures and event listeners.\r\n   * Call this method when the GestureManager is no longer needed to prevent memory leaks.\r\n   */\r\n  destroy() {\r\n    // Unregister all element gestures\r\n    for (const [element] of this.elementGestureMap) {\r\n      this.unregisterAllGestures(element);\r\n    }\r\n\r\n    // Clear all templates\r\n    this.gestureTemplates.clear();\r\n    this.elementGestureMap.clear();\r\n    this.activeGesturesRegistry.destroy();\r\n    this.keyboardManager.destroy();\r\n    this.pointerManager.destroy();\r\n  }\r\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 623, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/utils/eventList.js"],"sourcesContent":["export const eventList = {\r\n  abort: true,\r\n  animationcancel: true,\r\n  animationend: true,\r\n  animationiteration: true,\r\n  animationstart: true,\r\n  auxclick: true,\r\n  beforeinput: true,\r\n  beforetoggle: true,\r\n  blur: true,\r\n  cancel: true,\r\n  canplay: true,\r\n  canplaythrough: true,\r\n  change: true,\r\n  click: true,\r\n  close: true,\r\n  compositionend: true,\r\n  compositionstart: true,\r\n  compositionupdate: true,\r\n  contextlost: true,\r\n  contextmenu: true,\r\n  contextrestored: true,\r\n  copy: true,\r\n  cuechange: true,\r\n  cut: true,\r\n  dblclick: true,\r\n  drag: true,\r\n  dragend: true,\r\n  dragenter: true,\r\n  dragleave: true,\r\n  dragover: true,\r\n  dragstart: true,\r\n  drop: true,\r\n  durationchange: true,\r\n  emptied: true,\r\n  ended: true,\r\n  error: true,\r\n  focus: true,\r\n  focusin: true,\r\n  focusout: true,\r\n  formdata: true,\r\n  gotpointercapture: true,\r\n  input: true,\r\n  invalid: true,\r\n  keydown: true,\r\n  keypress: true,\r\n  keyup: true,\r\n  load: true,\r\n  loadeddata: true,\r\n  loadedmetadata: true,\r\n  loadstart: true,\r\n  lostpointercapture: true,\r\n  mousedown: true,\r\n  mouseenter: true,\r\n  mouseleave: true,\r\n  mousemove: true,\r\n  mouseout: true,\r\n  mouseover: true,\r\n  mouseup: true,\r\n  paste: true,\r\n  pause: true,\r\n  play: true,\r\n  playing: true,\r\n  pointercancel: true,\r\n  pointerdown: true,\r\n  pointerenter: true,\r\n  pointerleave: true,\r\n  pointermove: true,\r\n  pointerout: true,\r\n  pointerover: true,\r\n  pointerup: true,\r\n  progress: true,\r\n  ratechange: true,\r\n  reset: true,\r\n  resize: true,\r\n  scroll: true,\r\n  scrollend: true,\r\n  securitypolicyviolation: true,\r\n  seeked: true,\r\n  seeking: true,\r\n  select: true,\r\n  selectionchange: true,\r\n  selectstart: true,\r\n  slotchange: true,\r\n  stalled: true,\r\n  submit: true,\r\n  suspend: true,\r\n  timeupdate: true,\r\n  toggle: true,\r\n  touchcancel: true,\r\n  touchend: true,\r\n  touchmove: true,\r\n  touchstart: true,\r\n  transitioncancel: true,\r\n  transitionend: true,\r\n  transitionrun: true,\r\n  transitionstart: true,\r\n  volumechange: true,\r\n  waiting: true,\r\n  webkitanimationend: true,\r\n  webkitanimationiteration: true,\r\n  webkitanimationstart: true,\r\n  webkittransitionend: true,\r\n  wheel: true,\r\n  beforematch: true,\r\n  pointerrawupdate: true\r\n};"],"names":[],"mappings":";;;;AAAO,MAAM,YAAY;IACvB,OAAO;IACP,iBAAiB;IACjB,cAAc;IACd,oBAAoB;IACpB,gBAAgB;IAChB,UAAU;IACV,aAAa;IACb,cAAc;IACd,MAAM;IACN,QAAQ;IACR,SAAS;IACT,gBAAgB;IAChB,QAAQ;IACR,OAAO;IACP,OAAO;IACP,gBAAgB;IAChB,kBAAkB;IAClB,mBAAmB;IACnB,aAAa;IACb,aAAa;IACb,iBAAiB;IACjB,MAAM;IACN,WAAW;IACX,KAAK;IACL,UAAU;IACV,MAAM;IACN,SAAS;IACT,WAAW;IACX,WAAW;IACX,UAAU;IACV,WAAW;IACX,MAAM;IACN,gBAAgB;IAChB,SAAS;IACT,OAAO;IACP,OAAO;IACP,OAAO;IACP,SAAS;IACT,UAAU;IACV,UAAU;IACV,mBAAmB;IACnB,OAAO;IACP,SAAS;IACT,SAAS;IACT,UAAU;IACV,OAAO;IACP,MAAM;IACN,YAAY;IACZ,gBAAgB;IAChB,WAAW;IACX,oBAAoB;IACpB,WAAW;IACX,YAAY;IACZ,YAAY;IACZ,WAAW;IACX,UAAU;IACV,WAAW;IACX,SAAS;IACT,OAAO;IACP,OAAO;IACP,MAAM;IACN,SAAS;IACT,eAAe;IACf,aAAa;IACb,cAAc;IACd,cAAc;IACd,aAAa;IACb,YAAY;IACZ,aAAa;IACb,WAAW;IACX,UAAU;IACV,YAAY;IACZ,OAAO;IACP,QAAQ;IACR,QAAQ;IACR,WAAW;IACX,yBAAyB;IACzB,QAAQ;IACR,SAAS;IACT,QAAQ;IACR,iBAAiB;IACjB,aAAa;IACb,YAAY;IACZ,SAAS;IACT,QAAQ;IACR,SAAS;IACT,YAAY;IACZ,QAAQ;IACR,aAAa;IACb,UAAU;IACV,WAAW;IACX,YAAY;IACZ,kBAAkB;IAClB,eAAe;IACf,eAAe;IACf,iBAAiB;IACjB,cAAc;IACd,SAAS;IACT,oBAAoB;IACpB,0BAA0B;IAC1B,sBAAsB;IACtB,qBAAqB;IACrB,OAAO;IACP,aAAa;IACb,kBAAkB;AACpB","ignoreList":[0]}},
    {"offset": {"line": 738, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/Gesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\r\n/**\r\n * Base Gesture module that provides common functionality for all gesture implementations\r\n */\r\n\r\nimport { eventList } from \"./utils/eventList.js\";\r\n\r\n/**\r\n * The possible phases of a gesture during its lifecycle.\r\n *\r\n * - 'start': The gesture has been recognized and is beginning\r\n * - 'ongoing': The gesture is in progress (e.g., a finger is moving)\r\n * - 'end': The gesture has completed successfully\r\n * - 'cancel': The gesture was interrupted or terminated abnormally\r\n */\r\n\r\n/**\r\n * Core data structure passed to gesture event handlers.\r\n * Contains all relevant information about a gesture event.\r\n */\r\n\r\n/**\r\n * Defines the types of pointers that can trigger a gesture.\r\n */\r\n\r\n/**\r\n * Base configuration options that can be overridden per pointer mode.\r\n */\r\n\r\n/**\r\n * Configuration options for creating a gesture instance.\r\n */\r\n\r\n// eslint-disable-next-line no-underscore-dangle, @typescript-eslint/naming-convention\r\n\r\n/**\r\n * Type for the state of a gesture recognizer.\r\n */\r\n\r\n/**\r\n * Base abstract class for all gestures. This class provides the fundamental structure\r\n * and functionality for handling gestures, including registering and unregistering\r\n * gesture handlers, creating emitters, and managing gesture state.\r\n *\r\n * Gesture is designed as an extensible base for implementing specific gesture recognizers.\r\n * Concrete gesture implementations should extend this class or one of its subclasses.\r\n *\r\n * To implement:\r\n * - Non-pointer gestures (like wheel events): extend this Gesture class directly\r\n * - Pointer-based gestures: extend the PointerGesture class instead\r\n *\r\n * @example\r\n * ```ts\r\n * import { Gesture } from './Gesture';\r\n *\r\n * class CustomGesture extends Gesture {\r\n *   constructor(options) {\r\n *     super(options);\r\n *   }\r\n *\r\n *   clone(overrides) {\r\n *     return new CustomGesture({\r\n *       name: this.name,\r\n *       // ... other options\r\n *       ...overrides,\r\n *     });\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport class Gesture {\r\n  /** Unique name identifying this gesture type */\r\n\r\n  /** Whether to prevent default browser action for gesture events */\r\n\r\n  /** Whether to stop propagation of gesture events */\r\n\r\n  /**\r\n   * List of gesture names that should prevent this gesture from activating when they are active.\r\n   */\r\n\r\n  /**\r\n   * Array of keyboard keys that must be pressed for the gesture to be recognized.\r\n   */\r\n\r\n  /**\r\n   * KeyboardManager instance for tracking key presses\r\n   */\r\n\r\n  /**\r\n   * List of pointer types that can trigger this gesture.\r\n   * If undefined, all pointer types are allowed.\r\n   */\r\n\r\n  /**\r\n   * Pointer mode-specific configuration overrides.\r\n   */\r\n\r\n  /**\r\n   * User-mutable data object for sharing state between gesture events\r\n   * This object is included in all events emitted by this gesture\r\n   */\r\n  customData = {};\r\n\r\n  /** Reference to the singleton PointerManager instance */\r\n\r\n  /** Reference to the singleton ActiveGesturesRegistry instance */\r\n\r\n  /** The DOM element this gesture is attached to */\r\n\r\n  /** Stores the active gesture state */\r\n\r\n  /** @internal For types. If false enables phases (xStart, x, xEnd) */\r\n\r\n  /** @internal For types. The event type this gesture is associated with */\r\n\r\n  /** @internal For types. The options type for this gesture */\r\n\r\n  /** @internal For types. The options that can be changed at runtime */\r\n\r\n  /** @internal For types. The state that can be changed at runtime */\r\n\r\n  /**\r\n   * Create a new gesture instance with the specified options\r\n   *\r\n   * @param options - Configuration options for this gesture\r\n   */\r\n  constructor(options) {\r\n    if (!options || !options.name) {\r\n      throw new Error('Gesture must be initialized with a valid name.');\r\n    }\r\n    if (options.name in eventList) {\r\n      throw new Error(`Gesture can't be created with a native event name. Tried to use \"${options.name}\". Please use a custom name instead.`);\r\n    }\r\n    this.name = options.name;\r\n    this.preventDefault = options.preventDefault ?? false;\r\n    this.stopPropagation = options.stopPropagation ?? false;\r\n    this.preventIf = options.preventIf ?? [];\r\n    this.requiredKeys = options.requiredKeys ?? [];\r\n    this.pointerMode = options.pointerMode ?? [];\r\n    this.pointerOptions = options.pointerOptions ?? {};\r\n  }\r\n\r\n  /**\r\n   * Initialize the gesture by acquiring the pointer manager and gestures registry\r\n   * Must be called before the gesture can be used\r\n   */\r\n  init(element, pointerManager, gestureRegistry, keyboardManager) {\r\n    this.element = element;\r\n    this.pointerManager = pointerManager;\r\n    this.gesturesRegistry = gestureRegistry;\r\n    this.keyboardManager = keyboardManager;\r\n    const changeOptionsEventName = `${this.name}ChangeOptions`;\r\n    this.element.addEventListener(changeOptionsEventName, this.handleOptionsChange);\r\n    const changeStateEventName = `${this.name}ChangeState`;\r\n    this.element.addEventListener(changeStateEventName, this.handleStateChange);\r\n  }\r\n\r\n  /**\r\n   * Handle option change events\r\n   * @param event Custom event with new options in the detail property\r\n   */\r\n  handleOptionsChange = event => {\r\n    if (event && event.detail) {\r\n      this.updateOptions(event.detail);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Update the gesture options with new values\r\n   * @param options Object containing properties to update\r\n   */\r\n  updateOptions(options) {\r\n    // Update common options\r\n    this.preventDefault = options.preventDefault ?? this.preventDefault;\r\n    this.stopPropagation = options.stopPropagation ?? this.stopPropagation;\r\n    this.preventIf = options.preventIf ?? this.preventIf;\r\n    this.requiredKeys = options.requiredKeys ?? this.requiredKeys;\r\n    this.pointerMode = options.pointerMode ?? this.pointerMode;\r\n    this.pointerOptions = options.pointerOptions ?? this.pointerOptions;\r\n  }\r\n\r\n  /**\r\n   * Get the default configuration for the pointer specific options.\r\n   * Change this function in child classes to provide different defaults.\r\n   */\r\n  getBaseConfig() {\r\n    return {\r\n      requiredKeys: this.requiredKeys\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get the effective configuration for a specific pointer mode.\r\n   * This merges the base configuration with pointer mode-specific overrides.\r\n   *\r\n   * @param pointerType - The pointer type to get configuration for\r\n   * @returns The effective configuration object\r\n   */\r\n  getEffectiveConfig(pointerType, baseConfig) {\r\n    if (pointerType !== 'mouse' && pointerType !== 'touch' && pointerType !== 'pen') {\r\n      // Unknown pointer type, return base config\r\n      return baseConfig;\r\n    }\r\n\r\n    // Apply pointer mode-specific overrides\r\n    const pointerModeOverrides = this.pointerOptions[pointerType];\r\n    if (pointerModeOverrides) {\r\n      return _extends({}, baseConfig, pointerModeOverrides);\r\n    }\r\n    return baseConfig;\r\n  }\r\n\r\n  /**\r\n   * Handle state change events\r\n   * @param event Custom event with new state values in the detail property\r\n   */\r\n  handleStateChange = event => {\r\n    if (event && event.detail) {\r\n      this.updateState(event.detail);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Update the gesture state with new values\r\n   * @param stateChanges Object containing state properties to update\r\n   */\r\n  updateState(stateChanges) {\r\n    // This is a base implementation - concrete gesture classes should override\r\n    // to handle specific state updates based on their state structure\r\n    Object.assign(this.state, stateChanges);\r\n  }\r\n\r\n  /**\r\n   * Create a deep clone of this gesture for a new element\r\n   *\r\n   * @param overrides - Optional configuration options that override the defaults\r\n   * @returns A new instance of this gesture with the same configuration and any overrides applied\r\n   */\r\n\r\n  /**\r\n   * Check if the event's target is or is contained within any of our registered elements\r\n   *\r\n   * @param event - The browser event to check\r\n   * @returns The matching element or null if no match is found\r\n   */\r\n  getTargetElement(event) {\r\n    if (this.isActive || this.element === event.target || 'contains' in this.element && this.element.contains(event.target) || 'getRootNode' in this.element && this.element.getRootNode() instanceof ShadowRoot && event.composedPath().includes(this.element)) {\r\n      return this.element;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Whether the gesture is currently active */\r\n  set isActive(isActive) {\r\n    if (isActive) {\r\n      this.gesturesRegistry.registerActiveGesture(this.element, this);\r\n    } else {\r\n      this.gesturesRegistry.unregisterActiveGesture(this.element, this);\r\n    }\r\n  }\r\n\r\n  /** Whether the gesture is currently active */\r\n  get isActive() {\r\n    return this.gesturesRegistry.isGestureActive(this.element, this) ?? false;\r\n  }\r\n\r\n  /**\r\n   * Checks if this gesture should be prevented from activating.\r\n   *\r\n   * @param element - The DOM element to check against\r\n   * @param pointerType - The type of pointer triggering the gesture\r\n   * @returns true if the gesture should be prevented, false otherwise\r\n   */\r\n  shouldPreventGesture(element, pointerType) {\r\n    // Get effective configuration for this pointer type\r\n    const effectiveConfig = this.getEffectiveConfig(pointerType, this.getBaseConfig());\r\n\r\n    // First check if required keyboard keys are pressed\r\n    if (!this.keyboardManager.areKeysPressed(effectiveConfig.requiredKeys)) {\r\n      return true; // Prevent the gesture if required keys are not pressed\r\n    }\r\n    if (this.preventIf.length === 0) {\r\n      return false; // No prevention rules, allow the gesture\r\n    }\r\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\r\n\r\n    // Check if any of the gestures that would prevent this one are active\r\n    return this.preventIf.some(gestureName => activeGestures[gestureName]);\r\n  }\r\n\r\n  /**\r\n   * Checks if the given pointer type is allowed for this gesture based on the pointerMode setting.\r\n   *\r\n   * @param pointerType - The type of pointer to check.\r\n   * @returns true if the pointer type is allowed, false otherwise.\r\n   */\r\n  isPointerTypeAllowed(pointerType) {\r\n    // If no pointer mode is specified, all pointer types are allowed\r\n    if (!this.pointerMode || this.pointerMode.length === 0) {\r\n      return true;\r\n    }\r\n\r\n    // Check if the pointer type is in the allowed types list\r\n    return this.pointerMode.includes(pointerType);\r\n  }\r\n\r\n  /**\r\n   * Clean up the gesture and unregister any listeners\r\n   * Call this method when the gesture is no longer needed to prevent memory leaks\r\n   */\r\n  destroy() {\r\n    const changeOptionsEventName = `${this.name}ChangeOptions`;\r\n    this.element.removeEventListener(changeOptionsEventName, this.handleOptionsChange);\r\n    const changeStateEventName = `${this.name}ChangeState`;\r\n    this.element.removeEventListener(changeStateEventName, this.handleStateChange);\r\n  }\r\n\r\n  /**\r\n   * Reset the gesture state to its initial values\r\n   */\r\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 931, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/PointerGesture.js"],"sourcesContent":["import { Gesture } from \"./Gesture.js\";\r\n\r\n/**\r\n * Base configuration options that can be overridden per pointer mode.\r\n */\r\n\r\n/**\r\n * Configuration options for pointer-based gestures, extending the base GestureOptions.\r\n *\r\n * These options provide fine-grained control over how pointer events are interpreted\r\n * and when the gesture should be recognized.\r\n */\r\n\r\n/**\r\n * Base class for all pointer-based gestures.\r\n *\r\n * This class extends the base Gesture class with specialized functionality for\r\n * handling pointer events via the PointerManager. It provides common logic for\r\n * determining when a gesture should activate, tracking pointer movements, and\r\n * managing pointer thresholds.\r\n *\r\n * All pointer-based gesture implementations should extend this class rather than\r\n * the base Gesture class.\r\n *\r\n * @example\r\n * ```ts\r\n * import { PointerGesture } from './PointerGesture';\r\n *\r\n * class CustomGesture extends PointerGesture {\r\n *   constructor(options) {\r\n *     super(options);\r\n *   }\r\n *\r\n *   clone(overrides) {\r\n *     return new CustomGesture({\r\n *       name: this.name,\r\n *       // ... other options\r\n *       ...overrides,\r\n *     });\r\n *   }\r\n *\r\n *   handlePointerEvent = (pointers, event) => {\r\n *     // Handle pointer events here\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport class PointerGesture extends Gesture {\r\n  /** Function to unregister from the PointerManager when destroying this gesture */\r\n  unregisterHandler = null;\r\n\r\n  /** The original target element when the gesture began, used to prevent limbo state if target is removed */\r\n  originalTarget = null;\r\n\r\n  /**\r\n   * Minimum number of simultaneous pointers required to activate the gesture.\r\n   * The gesture will not start until at least this many pointers are active.\r\n   */\r\n\r\n  /**\r\n   * Maximum number of simultaneous pointers allowed for this gesture.\r\n   * If more than this many pointers are detected, the gesture may be canceled.\r\n   */\r\n\r\n  constructor(options) {\r\n    super(options);\r\n    this.minPointers = options.minPointers ?? 1;\r\n    this.maxPointers = options.maxPointers ?? Infinity;\r\n  }\r\n  init(element, pointerManager, gestureRegistry, keyboardManager) {\r\n    super.init(element, pointerManager, gestureRegistry, keyboardManager);\r\n    this.unregisterHandler = this.pointerManager.registerGestureHandler(this.handlePointerEvent);\r\n  }\r\n  updateOptions(options) {\r\n    super.updateOptions(options);\r\n    this.minPointers = options.minPointers ?? this.minPointers;\r\n    this.maxPointers = options.maxPointers ?? this.maxPointers;\r\n  }\r\n  getBaseConfig() {\r\n    return {\r\n      requiredKeys: this.requiredKeys,\r\n      minPointers: this.minPointers,\r\n      maxPointers: this.maxPointers\r\n    };\r\n  }\r\n  isWithinPointerCount(pointers, pointerMode) {\r\n    const config = this.getEffectiveConfig(pointerMode, this.getBaseConfig());\r\n    return pointers.length >= config.minPointers && pointers.length <= config.maxPointers;\r\n  }\r\n\r\n  /**\r\n   * Handler for pointer events from the PointerManager.\r\n   * Concrete gesture implementations must override this method to provide\r\n   * gesture-specific logic for recognizing and tracking the gesture.\r\n   *\r\n   * @param pointers - Map of active pointers by pointer ID\r\n   * @param event - The original pointer event from the browser\r\n   */\r\n\r\n  /**\r\n   * Calculate the target element for the gesture based on the active pointers.\r\n   *\r\n   * It takes into account the original target element.\r\n   *\r\n   * @param pointers - Map of active pointers by pointer ID\r\n   * @param calculatedTarget - The target element calculated from getTargetElement\r\n   * @returns A list of relevant pointers for this gesture\r\n   */\r\n  getRelevantPointers(pointers, calculatedTarget) {\r\n    return pointers.filter(pointer => this.isPointerTypeAllowed(pointer.pointerType) && (calculatedTarget === pointer.target || pointer.target === this.originalTarget || calculatedTarget === this.originalTarget || 'contains' in calculatedTarget && calculatedTarget.contains(pointer.target)) || 'getRootNode' in calculatedTarget && calculatedTarget.getRootNode() instanceof ShadowRoot && pointer.srcEvent.composedPath().includes(calculatedTarget));\r\n  }\r\n  destroy() {\r\n    if (this.unregisterHandler) {\r\n      this.unregisterHandler();\r\n      this.unregisterHandler = null;\r\n    }\r\n    super.destroy();\r\n  }\r\n}"],"names":[],"mappings":";;;;AAAA;;AA+CO,MAAM,uBAAuB,mLAAO;IACzC,gFAAgF,GAChF,oBAAoB,KAAK;IAEzB,yGAAyG,GACzG,iBAAiB,KAAK;IAEtB;;;GAGC,GAED;;;GAGC,GAED,YAAY,OAAO,CAAE;QACnB,KAAK,CAAC;QACN,IAAI,CAAC,WAAW,GAAG,QAAQ,WAAW,IAAI;QAC1C,IAAI,CAAC,WAAW,GAAG,QAAQ,WAAW,IAAI;IAC5C;IACA,KAAK,OAAO,EAAE,cAAc,EAAE,eAAe,EAAE,eAAe,EAAE;QAC9D,KAAK,CAAC,KAAK,SAAS,gBAAgB,iBAAiB;QACrD,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,cAAc,CAAC,sBAAsB,CAAC,IAAI,CAAC,kBAAkB;IAC7F;IACA,cAAc,OAAO,EAAE;QACrB,KAAK,CAAC,cAAc;QACpB,IAAI,CAAC,WAAW,GAAG,QAAQ,WAAW,IAAI,IAAI,CAAC,WAAW;QAC1D,IAAI,CAAC,WAAW,GAAG,QAAQ,WAAW,IAAI,IAAI,CAAC,WAAW;IAC5D;IACA,gBAAgB;QACd,OAAO;YACL,cAAc,IAAI,CAAC,YAAY;YAC/B,aAAa,IAAI,CAAC,WAAW;YAC7B,aAAa,IAAI,CAAC,WAAW;QAC/B;IACF;IACA,qBAAqB,QAAQ,EAAE,WAAW,EAAE;QAC1C,MAAM,SAAS,IAAI,CAAC,kBAAkB,CAAC,aAAa,IAAI,CAAC,aAAa;QACtE,OAAO,SAAS,MAAM,IAAI,OAAO,WAAW,IAAI,SAAS,MAAM,IAAI,OAAO,WAAW;IACvF;IAEA;;;;;;;GAOC,GAED;;;;;;;;GAQC,GACD,oBAAoB,QAAQ,EAAE,gBAAgB,EAAE;QAC9C,OAAO,SAAS,MAAM,CAAC,CAAA,UAAW,IAAI,CAAC,oBAAoB,CAAC,QAAQ,WAAW,KAAK,CAAC,qBAAqB,QAAQ,MAAM,IAAI,QAAQ,MAAM,KAAK,IAAI,CAAC,cAAc,IAAI,qBAAqB,IAAI,CAAC,cAAc,IAAI,cAAc,oBAAoB,iBAAiB,QAAQ,CAAC,QAAQ,MAAM,CAAC,KAAK,iBAAiB,oBAAoB,iBAAiB,WAAW,cAAc,cAAc,QAAQ,QAAQ,CAAC,YAAY,GAAG,QAAQ,CAAC;IAC1a;IACA,UAAU;QACR,IAAI,IAAI,CAAC,iBAAiB,EAAE;YAC1B,IAAI,CAAC,iBAAiB;YACtB,IAAI,CAAC,iBAAiB,GAAG;QAC3B;QACA,KAAK,CAAC;IACR;AACF","ignoreList":[0]}},
    {"offset": {"line": 1001, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/utils/calculateCentroid.js"],"sourcesContent":["/**\r\n * Calculate the centroid (average position) of multiple pointers\r\n */\r\nexport function calculateCentroid(pointers) {\r\n  if (pointers.length === 0) {\r\n    return {\r\n      x: 0,\r\n      y: 0\r\n    };\r\n  }\r\n  const sum = pointers.reduce((acc, pointer) => {\r\n    acc.x += pointer.clientX;\r\n    acc.y += pointer.clientY;\r\n    return acc;\r\n  }, {\r\n    x: 0,\r\n    y: 0\r\n  });\r\n  return {\r\n    x: sum.x / pointers.length,\r\n    y: sum.y / pointers.length\r\n  };\r\n}"],"names":[],"mappings":"AAAA;;CAEC;;;;AACM,SAAS,kBAAkB,QAAQ;IACxC,IAAI,SAAS,MAAM,KAAK,GAAG;QACzB,OAAO;YACL,GAAG;YACH,GAAG;QACL;IACF;IACA,MAAM,MAAM,SAAS,MAAM,CAAC,CAAC,KAAK;QAChC,IAAI,CAAC,IAAI,QAAQ,OAAO;QACxB,IAAI,CAAC,IAAI,QAAQ,OAAO;QACxB,OAAO;IACT,GAAG;QACD,GAAG;QACH,GAAG;IACL;IACA,OAAO;QACL,GAAG,IAAI,CAAC,GAAG,SAAS,MAAM;QAC1B,GAAG,IAAI,CAAC,GAAG,SAAS,MAAM;IAC5B;AACF","ignoreList":[0]}},
    {"offset": {"line": 1031, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/utils/createEventName.js"],"sourcesContent":["/**\r\n * Creates the event name for a specific gesture and phase\r\n */\r\nexport function createEventName(gesture, phase) {\r\n  return `${gesture}${phase === 'ongoing' ? '' : phase.charAt(0).toUpperCase() + phase.slice(1)}`;\r\n}"],"names":[],"mappings":"AAAA;;CAEC;;;;AACM,SAAS,gBAAgB,OAAO,EAAE,KAAK;IAC5C,OAAO,GAAG,UAAU,UAAU,YAAY,KAAK,MAAM,MAAM,CAAC,GAAG,WAAW,KAAK,MAAM,KAAK,CAAC,IAAI;AACjG","ignoreList":[0]}},
    {"offset": {"line": 1044, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/gestures/MoveGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\r\n/**\r\n * MoveGesture - Detects when a pointer enters, moves within, and leaves an element\r\n *\r\n * This gesture tracks pointer movements over an element, firing events when:\r\n * - A pointer enters the element (start)\r\n * - A pointer moves within the element (ongoing)\r\n * - A pointer leaves the element (end)\r\n *\r\n * Unlike other gestures which often require specific actions to trigger,\r\n * the move gesture fires automatically when pointers interact with the target element.\r\n *\r\n * This gesture only works with mouse pointers, not touch or pen.\r\n */\r\n\r\nimport { PointerGesture } from \"../PointerGesture.js\";\r\nimport { calculateCentroid, createEventName } from \"../utils/index.js\";\r\n\r\n/**\r\n * Configuration options for the MoveGesture\r\n * Extends the base PointerGestureOptions\r\n */\r\n\r\n/**\r\n * Event data specific to move gesture events\r\n * Includes the source pointer event and standard gesture data\r\n */\r\n\r\n/**\r\n * Type definition for the CustomEvent created by MoveGesture\r\n */\r\n\r\n/**\r\n * State tracking for the MoveGesture\r\n */\r\n\r\n/**\r\n * MoveGesture class for handling pointer movement over elements\r\n *\r\n * This gesture detects when pointers enter, move within, or leave target elements,\r\n * and dispatches corresponding custom events.\r\n *\r\n * This gesture only works with hovering mouse pointers, not touch.\r\n */\r\nexport class MoveGesture extends PointerGesture {\r\n  state = {\r\n    lastPosition: null\r\n  };\r\n\r\n  /**\r\n   * Movement threshold in pixels that must be exceeded before the gesture activates.\r\n   * Higher values reduce false positive gesture detection for small movements.\r\n   */\r\n\r\n  constructor(options) {\r\n    super(options);\r\n    this.threshold = options.threshold || 0;\r\n  }\r\n  clone(overrides) {\r\n    return new MoveGesture(_extends({\r\n      name: this.name,\r\n      preventDefault: this.preventDefault,\r\n      stopPropagation: this.stopPropagation,\r\n      threshold: this.threshold,\r\n      minPointers: this.minPointers,\r\n      maxPointers: this.maxPointers,\r\n      requiredKeys: [...this.requiredKeys],\r\n      pointerMode: [...this.pointerMode],\r\n      preventIf: [...this.preventIf],\r\n      pointerOptions: structuredClone(this.pointerOptions)\r\n    }, overrides));\r\n  }\r\n  init(element, pointerManager, gestureRegistry, keyboardManager) {\r\n    super.init(element, pointerManager, gestureRegistry, keyboardManager);\r\n\r\n    // Add event listeners for entering and leaving elements\r\n    // These are different from pointer events handled by PointerManager\r\n    // @ts-expect-error, PointerEvent is correct.\r\n    this.element.addEventListener('pointerenter', this.handleElementEnter);\r\n    // @ts-expect-error, PointerEvent is correct.\r\n    this.element.addEventListener('pointerleave', this.handleElementLeave);\r\n  }\r\n  destroy() {\r\n    // Remove event listeners using the same function references\r\n    // @ts-expect-error, PointerEvent is correct.\r\n    this.element.removeEventListener('pointerenter', this.handleElementEnter);\r\n    // @ts-expect-error, PointerEvent is correct.\r\n    this.element.removeEventListener('pointerleave', this.handleElementLeave);\r\n    this.resetState();\r\n    super.destroy();\r\n  }\r\n  updateOptions(options) {\r\n    // Call parent method to handle common options\r\n    super.updateOptions(options);\r\n  }\r\n  resetState() {\r\n    this.isActive = false;\r\n    this.state = {\r\n      lastPosition: null\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Handle pointer enter events for a specific element\r\n   * @param event The original pointer event\r\n   */\r\n  handleElementEnter = event => {\r\n    if (event.pointerType !== 'mouse' && event.pointerType !== 'pen') {\r\n      return;\r\n    }\r\n\r\n    // Get pointers from the PointerManager\r\n    const pointers = this.pointerManager.getPointers() || new Map();\r\n    const pointersArray = Array.from(pointers.values());\r\n\r\n    // Only activate if we're within pointer count constraints\r\n    if (this.isWithinPointerCount(pointersArray, event.pointerType)) {\r\n      this.isActive = true;\r\n      const currentPosition = {\r\n        x: event.clientX,\r\n        y: event.clientY\r\n      };\r\n      this.state.lastPosition = currentPosition;\r\n\r\n      // Emit start event\r\n      this.emitMoveEvent(this.element, 'start', pointersArray, event);\r\n      this.emitMoveEvent(this.element, 'ongoing', pointersArray, event);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Handle pointer leave events for a specific element\r\n   * @param event The original pointer event\r\n   */\r\n  handleElementLeave = event => {\r\n    if (event.pointerType !== 'mouse' && event.pointerType !== 'pen') {\r\n      return;\r\n    }\r\n    if (!this.isActive) {\r\n      return;\r\n    }\r\n\r\n    // Get pointers from the PointerManager\r\n    const pointers = this.pointerManager.getPointers() || new Map();\r\n    const pointersArray = Array.from(pointers.values());\r\n\r\n    // Emit end event and reset state\r\n    this.emitMoveEvent(this.element, 'end', pointersArray, event);\r\n    this.resetState();\r\n  };\r\n\r\n  /**\r\n   * Handle pointer events for the move gesture (only handles move events now)\r\n   * @param pointers Map of active pointers\r\n   * @param event The original pointer event\r\n   */\r\n  handlePointerEvent = (pointers, event) => {\r\n    if (event.type !== 'pointermove' || event.pointerType !== 'mouse' && event.pointerType !== 'pen') {\r\n      return;\r\n    }\r\n    if (this.preventDefault) {\r\n      event.preventDefault();\r\n    }\r\n    if (this.stopPropagation) {\r\n      event.stopPropagation();\r\n    }\r\n    const pointersArray = Array.from(pointers.values());\r\n\r\n    // Find which element (if any) is being targeted\r\n    const targetElement = this.getTargetElement(event);\r\n    if (!targetElement) {\r\n      return;\r\n    }\r\n    if (!this.isWithinPointerCount(pointersArray, event.pointerType)) {\r\n      return;\r\n    }\r\n    if (this.shouldPreventGesture(targetElement, event.pointerType)) {\r\n      if (!this.isActive) {\r\n        return;\r\n      }\r\n      this.resetState();\r\n      this.emitMoveEvent(targetElement, 'end', pointersArray, event);\r\n      return;\r\n    }\r\n\r\n    // Update position\r\n    const currentPosition = {\r\n      x: event.clientX,\r\n      y: event.clientY\r\n    };\r\n    this.state.lastPosition = currentPosition;\r\n    if (!this.isActive) {\r\n      this.isActive = true;\r\n      this.emitMoveEvent(targetElement, 'start', pointersArray, event);\r\n    }\r\n    // Emit ongoing event\r\n    this.emitMoveEvent(targetElement, 'ongoing', pointersArray, event);\r\n  };\r\n\r\n  /**\r\n   * Emit move-specific events\r\n   * @param element The DOM element the event is related to\r\n   * @param phase The current phase of the gesture (start, ongoing, end)\r\n   * @param pointers Array of active pointers\r\n   * @param event The original pointer event\r\n   */\r\n  emitMoveEvent(element, phase, pointers, event) {\r\n    const currentPosition = this.state.lastPosition || calculateCentroid(pointers);\r\n\r\n    // Get list of active gestures\r\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\r\n\r\n    // Create custom event data\r\n    const customEventData = {\r\n      gestureName: this.name,\r\n      centroid: currentPosition,\r\n      target: event.target,\r\n      srcEvent: event,\r\n      phase,\r\n      pointers,\r\n      timeStamp: event.timeStamp,\r\n      activeGestures,\r\n      customData: this.customData\r\n    };\r\n\r\n    // Event names to trigger\r\n    const eventName = createEventName(this.name, phase);\r\n\r\n    // Dispatch custom events on the element\r\n    const domEvent = new CustomEvent(eventName, {\r\n      bubbles: true,\r\n      cancelable: true,\r\n      composed: true,\r\n      detail: customEventData\r\n    });\r\n    element.dispatchEvent(domEvent);\r\n  }\r\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1248, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/utils/getDirection.js"],"sourcesContent":["const MAIN_THRESHOLD = 0.00001;\r\nconst ANGLE_THRESHOLD = 0.00001;\r\nconst SECONDARY_THRESHOLD = 0.15;\r\n\r\n/**\r\n * Get the direction of movement based on the current and previous positions\r\n */\r\nexport function getDirection(previous, current) {\r\n  const deltaX = current.x - previous.x;\r\n  const deltaY = current.y - previous.y;\r\n  const direction = {\r\n    vertical: null,\r\n    horizontal: null,\r\n    mainAxis: null\r\n  };\r\n  const isDiagonal = isDiagonalMovement(current, previous);\r\n  const mainMovement = Math.abs(deltaX) > Math.abs(deltaY) ? 'horizontal' : 'vertical';\r\n\r\n  // eslint-disable-next-line no-nested-ternary\r\n  const horizontalThreshold = isDiagonal ? MAIN_THRESHOLD : mainMovement === 'horizontal' ? MAIN_THRESHOLD : SECONDARY_THRESHOLD;\r\n  // eslint-disable-next-line no-nested-ternary\r\n  const verticalThreshold = isDiagonal ? MAIN_THRESHOLD : mainMovement === 'horizontal' ? SECONDARY_THRESHOLD : MAIN_THRESHOLD;\r\n\r\n  // Set horizontal direction if there's a significant movement horizontally\r\n  if (Math.abs(deltaX) > horizontalThreshold) {\r\n    // Small threshold to avoid noise\r\n    direction.horizontal = deltaX > 0 ? 'right' : 'left';\r\n  }\r\n\r\n  // Set vertical direction if there's a significant movement vertically\r\n  if (Math.abs(deltaY) > verticalThreshold) {\r\n    // Small threshold to avoid noise\r\n    direction.vertical = deltaY > 0 ? 'down' : 'up';\r\n  }\r\n  direction.mainAxis = isDiagonal ? 'diagonal' : mainMovement;\r\n  return direction;\r\n}\r\nfunction isDiagonalMovement(previous, current) {\r\n  const deltaX = current.x - previous.x;\r\n  const deltaY = current.y - previous.y;\r\n\r\n  // Calculate the angle of movement\r\n  const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;\r\n\r\n  // Check if the angle is within the diagonal range\r\n  return angle >= -45 + ANGLE_THRESHOLD && angle <= -22.5 + ANGLE_THRESHOLD || angle >= 22.5 + ANGLE_THRESHOLD && angle <= 45 + ANGLE_THRESHOLD || angle >= 135 + ANGLE_THRESHOLD && angle <= 157.5 + ANGLE_THRESHOLD || angle >= -157.5 + ANGLE_THRESHOLD && angle <= -135 + ANGLE_THRESHOLD;\r\n}"],"names":[],"mappings":";;;;AAAA,MAAM,iBAAiB;AACvB,MAAM,kBAAkB;AACxB,MAAM,sBAAsB;AAKrB,SAAS,aAAa,QAAQ,EAAE,OAAO;IAC5C,MAAM,SAAS,QAAQ,CAAC,GAAG,SAAS,CAAC;IACrC,MAAM,SAAS,QAAQ,CAAC,GAAG,SAAS,CAAC;IACrC,MAAM,YAAY;QAChB,UAAU;QACV,YAAY;QACZ,UAAU;IACZ;IACA,MAAM,aAAa,mBAAmB,SAAS;IAC/C,MAAM,eAAe,KAAK,GAAG,CAAC,UAAU,KAAK,GAAG,CAAC,UAAU,eAAe;IAE1E,6CAA6C;IAC7C,MAAM,sBAAsB,aAAa,iBAAiB,iBAAiB,eAAe,iBAAiB;IAC3G,6CAA6C;IAC7C,MAAM,oBAAoB,aAAa,iBAAiB,iBAAiB,eAAe,sBAAsB;IAE9G,0EAA0E;IAC1E,IAAI,KAAK,GAAG,CAAC,UAAU,qBAAqB;QAC1C,iCAAiC;QACjC,UAAU,UAAU,GAAG,SAAS,IAAI,UAAU;IAChD;IAEA,sEAAsE;IACtE,IAAI,KAAK,GAAG,CAAC,UAAU,mBAAmB;QACxC,iCAAiC;QACjC,UAAU,QAAQ,GAAG,SAAS,IAAI,SAAS;IAC7C;IACA,UAAU,QAAQ,GAAG,aAAa,aAAa;IAC/C,OAAO;AACT;AACA,SAAS,mBAAmB,QAAQ,EAAE,OAAO;IAC3C,MAAM,SAAS,QAAQ,CAAC,GAAG,SAAS,CAAC;IACrC,MAAM,SAAS,QAAQ,CAAC,GAAG,SAAS,CAAC;IAErC,kCAAkC;IAClC,MAAM,QAAQ,KAAK,KAAK,CAAC,QAAQ,UAAU,MAAM,KAAK,EAAE;IAExD,kDAAkD;IAClD,OAAO,SAAS,CAAC,KAAK,mBAAmB,SAAS,CAAC,OAAO,mBAAmB,SAAS,OAAO,mBAAmB,SAAS,KAAK,mBAAmB,SAAS,MAAM,mBAAmB,SAAS,QAAQ,mBAAmB,SAAS,CAAC,QAAQ,mBAAmB,SAAS,CAAC,MAAM;AAC9Q","ignoreList":[0]}},
    {"offset": {"line": 1294, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/utils/isDirectionAllowed.js"],"sourcesContent":["/**\r\n * Check if a direction matches one of the allowed directions\r\n */\r\nexport function isDirectionAllowed(direction, allowedDirections) {\r\n  if (!direction.vertical && !direction.horizontal) {\r\n    return false;\r\n  }\r\n  if (allowedDirections.length === 0) {\r\n    return true;\r\n  }\r\n\r\n  // Check if the vertical direction is allowed (if it exists)\r\n  const verticalAllowed = direction.vertical === null || allowedDirections.includes(direction.vertical);\r\n\r\n  // Check if the horizontal direction is allowed (if it exists)\r\n  const horizontalAllowed = direction.horizontal === null || allowedDirections.includes(direction.horizontal);\r\n\r\n  // Both directions must be allowed\r\n  return verticalAllowed && horizontalAllowed;\r\n}"],"names":[],"mappings":"AAAA;;CAEC;;;;AACM,SAAS,mBAAmB,SAAS,EAAE,iBAAiB;IAC7D,IAAI,CAAC,UAAU,QAAQ,IAAI,CAAC,UAAU,UAAU,EAAE;QAChD,OAAO;IACT;IACA,IAAI,kBAAkB,MAAM,KAAK,GAAG;QAClC,OAAO;IACT;IAEA,4DAA4D;IAC5D,MAAM,kBAAkB,UAAU,QAAQ,KAAK,QAAQ,kBAAkB,QAAQ,CAAC,UAAU,QAAQ;IAEpG,8DAA8D;IAC9D,MAAM,oBAAoB,UAAU,UAAU,KAAK,QAAQ,kBAAkB,QAAQ,CAAC,UAAU,UAAU;IAE1G,kCAAkC;IAClC,OAAO,mBAAmB;AAC5B","ignoreList":[0]}},
    {"offset": {"line": 1318, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/gestures/PanGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\r\n/**\r\n * PanGesture - Detects panning (dragging) movements\r\n *\r\n * This gesture tracks pointer dragging movements across elements, firing events when:\r\n * - The drag movement begins and passes the threshold distance (start)\r\n * - The drag movement continues (ongoing)\r\n * - The drag movement ends (end)\r\n *\r\n * The gesture can be configured to recognize movement only in specific directions.\r\n */\r\n\r\nimport { PointerGesture } from \"../PointerGesture.js\";\r\nimport { calculateCentroid, createEventName, getDirection, isDirectionAllowed } from \"../utils/index.js\";\r\n\r\n/**\r\n * Configuration options for PanGesture\r\n * Extends PointerGestureOptions with direction constraints\r\n */\r\n\r\n/**\r\n * Event data specific to pan gesture events\r\n * Contains information about movement distance, direction, and velocity\r\n */\r\n\r\n/**\r\n * Type definition for the CustomEvent created by PanGesture\r\n */\r\n\r\n/**\r\n * State tracking for the PanGesture\r\n */\r\n\r\n/**\r\n * PanGesture class for handling panning/dragging interactions\r\n *\r\n * This gesture detects when users drag across elements with one or more pointers,\r\n * and dispatches directional movement events with delta and velocity information.\r\n */\r\nexport class PanGesture extends PointerGesture {\r\n  state = (() => ({\r\n    startPointers: new Map(),\r\n    startCentroid: null,\r\n    lastCentroid: null,\r\n    movementThresholdReached: false,\r\n    totalDeltaX: 0,\r\n    totalDeltaY: 0,\r\n    activeDeltaX: 0,\r\n    activeDeltaY: 0,\r\n    lastDirection: {\r\n      vertical: null,\r\n      horizontal: null,\r\n      mainAxis: null\r\n    },\r\n    lastDeltas: null\r\n  }))();\r\n\r\n  /**\r\n   * Movement threshold in pixels that must be exceeded before the gesture activates.\r\n   * Higher values reduce false positive gesture detection for small movements.\r\n   */\r\n\r\n  /**\r\n   * Allowed directions for the pan gesture\r\n   * Default allows all directions\r\n   */\r\n\r\n  constructor(options) {\r\n    super(options);\r\n    this.direction = options.direction || ['up', 'down', 'left', 'right'];\r\n    this.threshold = options.threshold || 0;\r\n  }\r\n  clone(overrides) {\r\n    return new PanGesture(_extends({\r\n      name: this.name,\r\n      preventDefault: this.preventDefault,\r\n      stopPropagation: this.stopPropagation,\r\n      threshold: this.threshold,\r\n      minPointers: this.minPointers,\r\n      maxPointers: this.maxPointers,\r\n      direction: [...this.direction],\r\n      requiredKeys: [...this.requiredKeys],\r\n      pointerMode: [...this.pointerMode],\r\n      preventIf: [...this.preventIf],\r\n      pointerOptions: structuredClone(this.pointerOptions)\r\n    }, overrides));\r\n  }\r\n  destroy() {\r\n    this.resetState();\r\n    super.destroy();\r\n  }\r\n  updateOptions(options) {\r\n    super.updateOptions(options);\r\n    this.direction = options.direction || this.direction;\r\n    this.threshold = options.threshold ?? this.threshold;\r\n  }\r\n  resetState() {\r\n    this.isActive = false;\r\n    this.state = _extends({}, this.state, {\r\n      startPointers: new Map(),\r\n      startCentroid: null,\r\n      lastCentroid: null,\r\n      lastDeltas: null,\r\n      activeDeltaX: 0,\r\n      activeDeltaY: 0,\r\n      movementThresholdReached: false,\r\n      lastDirection: {\r\n        vertical: null,\r\n        horizontal: null,\r\n        mainAxis: null\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle pointer events for the pan gesture\r\n   */\r\n  handlePointerEvent = (pointers, event) => {\r\n    const pointersArray = Array.from(pointers.values());\r\n\r\n    // Check for our forceCancel event to handle interrupted gestures (from contextmenu, blur)\r\n    if (event.type === 'forceCancel') {\r\n      // Reset all active pan gestures when we get a force reset event\r\n      this.cancel(event.target, pointersArray, event);\r\n      return;\r\n    }\r\n\r\n    // Find which element (if any) is being targeted\r\n    const targetElement = this.getTargetElement(event);\r\n    if (!targetElement) {\r\n      return;\r\n    }\r\n\r\n    // Check if this gesture should be prevented by active gestures\r\n    if (this.shouldPreventGesture(targetElement, event.pointerType)) {\r\n      // If the gesture was active but now should be prevented, cancel it gracefully\r\n      this.cancel(targetElement, pointersArray, event);\r\n      return;\r\n    }\r\n\r\n    // Filter pointers to only include those targeting our element or its children\r\n    const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);\r\n    if (!this.isWithinPointerCount(relevantPointers, event.pointerType)) {\r\n      // Cancel or end the gesture if it was active\r\n      this.cancel(targetElement, relevantPointers, event);\r\n      return;\r\n    }\r\n    switch (event.type) {\r\n      case 'pointerdown':\r\n        if (!this.isActive && !this.state.startCentroid) {\r\n          // Store initial pointers\r\n          relevantPointers.forEach(pointer => {\r\n            this.state.startPointers.set(pointer.pointerId, pointer);\r\n          });\r\n\r\n          // Store the original target element\r\n          this.originalTarget = targetElement;\r\n\r\n          // Calculate and store the starting centroid\r\n          this.state.startCentroid = calculateCentroid(relevantPointers);\r\n          this.state.lastCentroid = _extends({}, this.state.startCentroid);\r\n        }\r\n        break;\r\n      case 'pointermove':\r\n        if (this.state.startCentroid && this.isWithinPointerCount(pointersArray, event.pointerType)) {\r\n          // Calculate current centroid\r\n          const currentCentroid = calculateCentroid(relevantPointers);\r\n\r\n          // Calculate delta from start\r\n          const distanceDeltaX = currentCentroid.x - this.state.startCentroid.x;\r\n          const distanceDeltaY = currentCentroid.y - this.state.startCentroid.y;\r\n\r\n          // Calculate movement distance\r\n          const distance = Math.sqrt(distanceDeltaX * distanceDeltaX + distanceDeltaY * distanceDeltaY);\r\n\r\n          // Determine movement direction\r\n          const moveDirection = getDirection(this.state.lastCentroid ?? this.state.startCentroid, currentCentroid);\r\n\r\n          // Calculate change in position since last move\r\n          const lastDeltaX = this.state.lastCentroid ? currentCentroid.x - this.state.lastCentroid.x : 0;\r\n          const lastDeltaY = this.state.lastCentroid ? currentCentroid.y - this.state.lastCentroid.y : 0;\r\n\r\n          // Check if movement passes the threshold and is in an allowed direction\r\n          if (!this.state.movementThresholdReached && distance >= this.threshold && isDirectionAllowed(moveDirection, this.direction)) {\r\n            this.state.movementThresholdReached = true;\r\n            this.isActive = true;\r\n\r\n            // Update total accumulated delta\r\n            this.state.lastDeltas = {\r\n              x: lastDeltaX,\r\n              y: lastDeltaY\r\n            };\r\n            this.state.totalDeltaX += lastDeltaX;\r\n            this.state.totalDeltaY += lastDeltaY;\r\n            this.state.activeDeltaX += lastDeltaX;\r\n            this.state.activeDeltaY += lastDeltaY;\r\n\r\n            // Emit start event\r\n            this.emitPanEvent(targetElement, 'start', relevantPointers, event, currentCentroid);\r\n            this.emitPanEvent(targetElement, 'ongoing', relevantPointers, event, currentCentroid);\r\n          }\r\n          // If we've already crossed the threshold, continue tracking\r\n          else if (this.state.movementThresholdReached && this.isActive) {\r\n            // Update total accumulated delta\r\n            this.state.lastDeltas = {\r\n              x: lastDeltaX,\r\n              y: lastDeltaY\r\n            };\r\n            this.state.totalDeltaX += lastDeltaX;\r\n            this.state.totalDeltaY += lastDeltaY;\r\n            this.state.activeDeltaX += lastDeltaX;\r\n            this.state.activeDeltaY += lastDeltaY;\r\n\r\n            // Emit ongoing event\r\n            this.emitPanEvent(targetElement, 'ongoing', relevantPointers, event, currentCentroid);\r\n          }\r\n\r\n          // Update last centroid\r\n          this.state.lastCentroid = currentCentroid;\r\n          this.state.lastDirection = moveDirection;\r\n        }\r\n        break;\r\n      case 'pointerup':\r\n      case 'pointercancel':\r\n      case 'forceCancel':\r\n        // If the gesture was active (threshold was reached), emit end event\r\n        if (this.isActive && this.state.movementThresholdReached) {\r\n          const remainingPointers = relevantPointers.filter(p => p.type !== 'pointerup' && p.type !== 'pointercancel');\r\n\r\n          // If we no longer meet the pointer count requirements, end the gesture\r\n          if (!this.isWithinPointerCount(remainingPointers, event.pointerType)) {\r\n            // End the gesture\r\n            const currentCentroid = this.state.lastCentroid || this.state.startCentroid;\r\n            if (event.type === 'pointercancel') {\r\n              this.emitPanEvent(targetElement, 'cancel', relevantPointers, event, currentCentroid);\r\n            }\r\n            this.emitPanEvent(targetElement, 'end', relevantPointers, event, currentCentroid);\r\n            this.resetState();\r\n          }\r\n        } else {\r\n          this.resetState();\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Emit pan-specific events with additional data\r\n   */\r\n  emitPanEvent(element, phase, pointers, event, currentCentroid) {\r\n    if (!this.state.startCentroid) {\r\n      return;\r\n    }\r\n    const deltaX = this.state.lastDeltas?.x ?? 0;\r\n    const deltaY = this.state.lastDeltas?.y ?? 0;\r\n\r\n    // Calculate velocity - time difference in seconds\r\n    const firstPointer = this.state.startPointers.values().next().value;\r\n    const timeElapsed = firstPointer ? (event.timeStamp - firstPointer.timeStamp) / 1000 : 0;\r\n    const velocityX = timeElapsed > 0 ? deltaX / timeElapsed : 0;\r\n    const velocityY = timeElapsed > 0 ? deltaY / timeElapsed : 0;\r\n    const velocity = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\r\n\r\n    // Get list of active gestures\r\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\r\n\r\n    // Create custom event data\r\n    const customEventData = {\r\n      gestureName: this.name,\r\n      initialCentroid: this.state.startCentroid,\r\n      centroid: currentCentroid,\r\n      target: event.target,\r\n      srcEvent: event,\r\n      phase,\r\n      pointers,\r\n      timeStamp: event.timeStamp,\r\n      deltaX,\r\n      deltaY,\r\n      direction: this.state.lastDirection,\r\n      velocityX,\r\n      velocityY,\r\n      velocity,\r\n      totalDeltaX: this.state.totalDeltaX,\r\n      totalDeltaY: this.state.totalDeltaY,\r\n      activeDeltaX: this.state.activeDeltaX,\r\n      activeDeltaY: this.state.activeDeltaY,\r\n      activeGestures,\r\n      customData: this.customData\r\n    };\r\n\r\n    // Event names to trigger\r\n    const eventName = createEventName(this.name, phase);\r\n\r\n    // Dispatch custom events on the element\r\n    const domEvent = new CustomEvent(eventName, {\r\n      bubbles: true,\r\n      cancelable: true,\r\n      composed: true,\r\n      detail: customEventData\r\n    });\r\n    element.dispatchEvent(domEvent);\r\n\r\n    // Apply preventDefault/stopPropagation if configured\r\n    if (this.preventDefault) {\r\n      event.preventDefault();\r\n    }\r\n    if (this.stopPropagation) {\r\n      event.stopPropagation();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cancel the current gesture\r\n   */\r\n  cancel(element, pointers, event) {\r\n    if (this.isActive) {\r\n      const el = element ?? this.element;\r\n      this.emitPanEvent(el, 'cancel', pointers, event, this.state.lastCentroid);\r\n      this.emitPanEvent(el, 'end', pointers, event, this.state.lastCentroid);\r\n    }\r\n    this.resetState();\r\n  }\r\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1608, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/utils/getDistance.js"],"sourcesContent":["/**\r\n * Calculate the distance between two points\r\n */\r\nexport function getDistance(pointA, pointB) {\r\n  const deltaX = pointB.x - pointA.x;\r\n  const deltaY = pointB.y - pointA.y;\r\n  return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\r\n}"],"names":[],"mappings":"AAAA;;CAEC;;;;AACM,SAAS,YAAY,MAAM,EAAE,MAAM;IACxC,MAAM,SAAS,OAAO,CAAC,GAAG,OAAO,CAAC;IAClC,MAAM,SAAS,OAAO,CAAC,GAAG,OAAO,CAAC;IAClC,OAAO,KAAK,IAAI,CAAC,SAAS,SAAS,SAAS;AAC9C","ignoreList":[0]}},
    {"offset": {"line": 1623, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/utils/calculateAverageDistance.js"],"sourcesContent":["import { getDistance } from \"./getDistance.js\";\r\n\r\n/**\r\n * Calculate the average distance between all pairs of pointers\r\n */\r\nexport function calculateAverageDistance(pointers) {\r\n  if (pointers.length < 2) {\r\n    return 0;\r\n  }\r\n  let totalDistance = 0;\r\n  let pairCount = 0;\r\n\r\n  // Calculate distance between each pair of pointers\r\n  for (let i = 0; i < pointers.length; i += 1) {\r\n    for (let j = i + 1; j < pointers.length; j += 1) {\r\n      totalDistance += getDistance({\r\n        x: pointers[i].clientX,\r\n        y: pointers[i].clientY\r\n      }, {\r\n        x: pointers[j].clientX,\r\n        y: pointers[j].clientY\r\n      });\r\n      pairCount += 1;\r\n    }\r\n  }\r\n\r\n  // Return average distance\r\n  return pairCount > 0 ? totalDistance / pairCount : 0;\r\n}"],"names":[],"mappings":";;;;AAAA;;AAKO,SAAS,yBAAyB,QAAQ;IAC/C,IAAI,SAAS,MAAM,GAAG,GAAG;QACvB,OAAO;IACT;IACA,IAAI,gBAAgB;IACpB,IAAI,YAAY;IAEhB,mDAAmD;IACnD,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,MAAM,EAAE,KAAK,EAAG;QAC3C,IAAK,IAAI,IAAI,IAAI,GAAG,IAAI,SAAS,MAAM,EAAE,KAAK,EAAG;YAC/C,iBAAiB,IAAA,oMAAW,EAAC;gBAC3B,GAAG,QAAQ,CAAC,EAAE,CAAC,OAAO;gBACtB,GAAG,QAAQ,CAAC,EAAE,CAAC,OAAO;YACxB,GAAG;gBACD,GAAG,QAAQ,CAAC,EAAE,CAAC,OAAO;gBACtB,GAAG,QAAQ,CAAC,EAAE,CAAC,OAAO;YACxB;YACA,aAAa;QACf;IACF;IAEA,0BAA0B;IAC1B,OAAO,YAAY,IAAI,gBAAgB,YAAY;AACrD","ignoreList":[0]}},
    {"offset": {"line": 1655, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/utils/getPinchDirection.js"],"sourcesContent":["const DIRECTION_THRESHOLD = 0;\r\nexport const getPinchDirection = velocity => {\r\n  if (velocity > DIRECTION_THRESHOLD) {\r\n    return 1; // Zooming in\r\n  }\r\n  if (velocity < -DIRECTION_THRESHOLD) {\r\n    return -1; // Zooming out\r\n  }\r\n  return 0; // No significant movement\r\n};"],"names":[],"mappings":";;;;AAAA,MAAM,sBAAsB;AACrB,MAAM,oBAAoB,CAAA;IAC/B,IAAI,WAAW,qBAAqB;QAClC,OAAO,GAAG,aAAa;IACzB;IACA,IAAI,WAAW,CAAC,qBAAqB;QACnC,OAAO,CAAC,GAAG,cAAc;IAC3B;IACA,OAAO,GAAG,0BAA0B;AACtC","ignoreList":[0]}},
    {"offset": {"line": 1673, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/gestures/PinchGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\r\n/**\r\n * PinchGesture - Detects pinch (zoom) movements with two or more pointers\r\n *\r\n * This gesture tracks when multiple pointers move toward or away from each other, firing events when:\r\n * - Two or more pointers begin moving (start)\r\n * - The pointers continue changing distance (ongoing)\r\n * - One or more pointers are released or lifted (end)\r\n *\r\n * This gesture is commonly used to implement zoom functionality in touch interfaces.\r\n */\r\n\r\nimport { PointerGesture } from \"../PointerGesture.js\";\r\nimport { calculateAverageDistance, calculateCentroid, createEventName, getPinchDirection } from \"../utils/index.js\";\r\n\r\n/**\r\n * Configuration options for the PinchGesture\r\n * Uses the same options as the base PointerGesture\r\n */\r\n\r\n/**\r\n * Event data specific to pinch gesture events\r\n * Contains information about scale, distance, and velocity\r\n */\r\n\r\n/**\r\n * Type definition for the CustomEvent created by PinchGesture\r\n */\r\n\r\n/**\r\n * State tracking for the PinchGesture\r\n */\r\n\r\n/**\r\n * PinchGesture class for handling pinch/zoom interactions\r\n *\r\n * This gesture detects when users move multiple pointers toward or away from each other,\r\n * and dispatches scale-related events with distance and velocity information.\r\n */\r\nexport class PinchGesture extends PointerGesture {\r\n  state = {\r\n    startDistance: 0,\r\n    lastDistance: 0,\r\n    lastScale: 1,\r\n    lastTime: 0,\r\n    velocity: 0,\r\n    totalScale: 1,\r\n    deltaScale: 0\r\n  };\r\n\r\n  /**\r\n   * Movement threshold in pixels that must be exceeded before the gesture activates.\r\n   * Higher values reduce false positive gesture detection for small movements.\r\n   */\r\n\r\n  constructor(options) {\r\n    super(_extends({}, options, {\r\n      minPointers: options.minPointers ?? 2\r\n    }));\r\n    this.threshold = options.threshold ?? 0;\r\n  }\r\n  clone(overrides) {\r\n    return new PinchGesture(_extends({\r\n      name: this.name,\r\n      preventDefault: this.preventDefault,\r\n      stopPropagation: this.stopPropagation,\r\n      threshold: this.threshold,\r\n      minPointers: this.minPointers,\r\n      maxPointers: this.maxPointers,\r\n      requiredKeys: [...this.requiredKeys],\r\n      pointerMode: [...this.pointerMode],\r\n      preventIf: [...this.preventIf],\r\n      pointerOptions: structuredClone(this.pointerOptions)\r\n    }, overrides));\r\n  }\r\n  destroy() {\r\n    this.resetState();\r\n    super.destroy();\r\n  }\r\n  updateOptions(options) {\r\n    super.updateOptions(options);\r\n  }\r\n  resetState() {\r\n    this.isActive = false;\r\n    this.state = _extends({}, this.state, {\r\n      startDistance: 0,\r\n      lastDistance: 0,\r\n      lastScale: 1,\r\n      lastTime: 0,\r\n      velocity: 0,\r\n      deltaScale: 0\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle pointer events for the pinch gesture\r\n   */\r\n  handlePointerEvent = (pointers, event) => {\r\n    const pointersArray = Array.from(pointers.values());\r\n\r\n    // Find which element (if any) is being targeted\r\n    const targetElement = this.getTargetElement(event);\r\n    if (!targetElement) {\r\n      return;\r\n    }\r\n\r\n    // Check if this gesture should be prevented by active gestures\r\n    if (this.shouldPreventGesture(targetElement, event.pointerType)) {\r\n      if (this.isActive) {\r\n        // If the gesture was active but now should be prevented, end it gracefully\r\n        this.emitPinchEvent(targetElement, 'cancel', pointersArray, event);\r\n        this.resetState();\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Filter pointers to only include those targeting our element or its children\r\n    const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);\r\n    switch (event.type) {\r\n      case 'pointerdown':\r\n        if (relevantPointers.length >= 2 && !this.isActive) {\r\n          // Calculate and store the starting distance between pointers\r\n          const initialDistance = calculateAverageDistance(relevantPointers);\r\n          this.state.startDistance = initialDistance;\r\n          this.state.lastDistance = initialDistance;\r\n          this.state.lastTime = event.timeStamp;\r\n\r\n          // Store the original target element\r\n          this.originalTarget = targetElement;\r\n        }\r\n        break;\r\n      case 'pointermove':\r\n        if (this.state.startDistance && this.isWithinPointerCount(relevantPointers, event.pointerType)) {\r\n          // Calculate current distance between pointers\r\n          const currentDistance = calculateAverageDistance(relevantPointers);\r\n\r\n          // Calculate absolute distance change\r\n          const distanceChange = Math.abs(currentDistance - this.state.lastDistance);\r\n\r\n          // Only proceed if the distance between pointers has changed enough\r\n          if (distanceChange !== 0 && distanceChange >= this.threshold) {\r\n            // Calculate scale relative to starting distance\r\n            const scale = this.state.startDistance ? currentDistance / this.state.startDistance : 1;\r\n\r\n            // Calculate the relative scale change since last event\r\n            const scaleChange = scale / this.state.lastScale;\r\n            // Apply this change to the total accumulated scale\r\n            this.state.totalScale *= scaleChange;\r\n            // Calculate velocity (change in scale over time)\r\n            const deltaTime = (event.timeStamp - this.state.lastTime) / 1000; // convert to seconds\r\n            if (this.state.lastDistance) {\r\n              const deltaDistance = currentDistance - this.state.lastDistance;\r\n              const result = deltaDistance / deltaTime;\r\n              this.state.velocity = Number.isNaN(result) ? 0 : result;\r\n            }\r\n\r\n            // Update state\r\n            this.state.lastDistance = currentDistance;\r\n            this.state.deltaScale = scale - this.state.lastScale;\r\n            this.state.lastScale = scale;\r\n            this.state.lastTime = event.timeStamp;\r\n            if (!this.isActive) {\r\n              // Mark gesture as active\r\n              this.isActive = true;\r\n\r\n              // Emit start event\r\n              this.emitPinchEvent(targetElement, 'start', relevantPointers, event);\r\n              this.emitPinchEvent(targetElement, 'ongoing', relevantPointers, event);\r\n            } else {\r\n              // Emit ongoing event\r\n              this.emitPinchEvent(targetElement, 'ongoing', relevantPointers, event);\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      case 'pointerup':\r\n      case 'pointercancel':\r\n      case 'forceCancel':\r\n        if (this.isActive) {\r\n          const remainingPointers = relevantPointers.filter(p => p.type !== 'pointerup' && p.type !== 'pointercancel');\r\n\r\n          // If we no longer meet the pointer count requirements, end the gesture\r\n          if (!this.isWithinPointerCount(remainingPointers, event.pointerType)) {\r\n            if (event.type === 'pointercancel') {\r\n              this.emitPinchEvent(targetElement, 'cancel', relevantPointers, event);\r\n            }\r\n            this.emitPinchEvent(targetElement, 'end', relevantPointers, event);\r\n\r\n            // Reset state\r\n            this.resetState();\r\n          } else if (remainingPointers.length >= 2) {\r\n            // If we still have enough pointers, update the start distance\r\n            // to prevent jumping when a finger is lifted\r\n            const newDistance = calculateAverageDistance(remainingPointers);\r\n            this.state.startDistance = newDistance / this.state.lastScale;\r\n          }\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Emit pinch-specific events with additional data\r\n   */\r\n  emitPinchEvent(element, phase, pointers, event) {\r\n    // Calculate current centroid\r\n    const centroid = calculateCentroid(pointers);\r\n\r\n    // Create custom event data\r\n    const distance = this.state.lastDistance;\r\n    const scale = this.state.lastScale;\r\n\r\n    // Get list of active gestures\r\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\r\n    const customEventData = {\r\n      gestureName: this.name,\r\n      centroid,\r\n      target: event.target,\r\n      srcEvent: event,\r\n      phase,\r\n      pointers,\r\n      timeStamp: event.timeStamp,\r\n      scale,\r\n      deltaScale: this.state.deltaScale,\r\n      totalScale: this.state.totalScale,\r\n      distance,\r\n      velocity: this.state.velocity,\r\n      activeGestures,\r\n      direction: getPinchDirection(this.state.velocity),\r\n      customData: this.customData\r\n    };\r\n\r\n    // Handle default event behavior\r\n    if (this.preventDefault) {\r\n      event.preventDefault();\r\n    }\r\n    if (this.stopPropagation) {\r\n      event.stopPropagation();\r\n    }\r\n\r\n    // Event names to trigger\r\n    const eventName = createEventName(this.name, phase);\r\n\r\n    // Dispatch custom events on the element\r\n    const domEvent = new CustomEvent(eventName, {\r\n      bubbles: true,\r\n      cancelable: true,\r\n      composed: true,\r\n      detail: customEventData\r\n    });\r\n    element.dispatchEvent(domEvent);\r\n  }\r\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1898, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/utils/preventDefault.js"],"sourcesContent":["export const preventDefault = event => {\r\n  if (event.cancelable) {\r\n    event.preventDefault();\r\n  }\r\n};"],"names":[],"mappings":";;;;AAAO,MAAM,iBAAiB,CAAA;IAC5B,IAAI,MAAM,UAAU,EAAE;QACpB,MAAM,cAAc;IACtB;AACF","ignoreList":[0]}},
    {"offset": {"line": 1911, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/gestures/PressGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\r\n/**\r\n * PressGesture - Detects press and hold interactions\r\n *\r\n * This gesture tracks when users press and hold on an element for a specified duration, firing events when:\r\n * - The press begins and passes the holding threshold time (start, ongoing)\r\n * - The press ends (end)\r\n * - The press is canceled by movement beyond threshold (cancel)\r\n *\r\n * This gesture is commonly used for contextual menus, revealing additional options, or alternate actions.\r\n */\r\n\r\nimport { PointerGesture } from \"../PointerGesture.js\";\r\nimport { calculateCentroid, createEventName } from \"../utils/index.js\";\r\n\r\n/**\r\n * Configuration options for PressGesture\r\n * Extends PointerGestureOptions with press-specific options\r\n */\r\n\r\n/**\r\n * Event data specific to press gesture events\r\n * Contains information about the press location and duration\r\n */\r\n\r\n/**\r\n * Type definition for the CustomEvent created by PressGesture\r\n */\r\n\r\n/**\r\n * State tracking for the PressGesture\r\n */\r\n\r\n/**\r\n * PressGesture class for handling press/hold interactions\r\n *\r\n * This gesture detects when users press and hold on an element for a specified duration,\r\n * and dispatches press-related events when the user holds long enough.\r\n *\r\n * The `start` and `ongoing` events are dispatched at the same time once the press threshold is reached.\r\n * If the press is canceled (event.g., by moving too far), a `cancel` event is dispatched before the `end` event.\r\n */\r\nexport class PressGesture extends PointerGesture {\r\n  state = {\r\n    startCentroid: null,\r\n    lastPosition: null,\r\n    timerId: null,\r\n    startTime: 0,\r\n    pressThresholdReached: false\r\n  };\r\n\r\n  /**\r\n   * Duration in milliseconds required to hold before the press gesture is recognized\r\n   */\r\n\r\n  /**\r\n   * Maximum distance a pointer can move for a gesture to still be considered a press\r\n   */\r\n\r\n  constructor(options) {\r\n    super(options);\r\n    this.duration = options.duration ?? 500;\r\n    this.maxDistance = options.maxDistance ?? 10;\r\n  }\r\n  clone(overrides) {\r\n    return new PressGesture(_extends({\r\n      name: this.name,\r\n      preventDefault: this.preventDefault,\r\n      stopPropagation: this.stopPropagation,\r\n      minPointers: this.minPointers,\r\n      maxPointers: this.maxPointers,\r\n      duration: this.duration,\r\n      maxDistance: this.maxDistance,\r\n      requiredKeys: [...this.requiredKeys],\r\n      pointerMode: [...this.pointerMode],\r\n      preventIf: [...this.preventIf],\r\n      pointerOptions: structuredClone(this.pointerOptions)\r\n    }, overrides));\r\n  }\r\n  destroy() {\r\n    this.clearPressTimer();\r\n    this.resetState();\r\n    super.destroy();\r\n  }\r\n  updateOptions(options) {\r\n    super.updateOptions(options);\r\n    this.duration = options.duration ?? this.duration;\r\n    this.maxDistance = options.maxDistance ?? this.maxDistance;\r\n  }\r\n  resetState() {\r\n    this.clearPressTimer();\r\n    this.isActive = false;\r\n    this.state = _extends({}, this.state, {\r\n      startCentroid: null,\r\n      lastPosition: null,\r\n      timerId: null,\r\n      startTime: 0,\r\n      pressThresholdReached: false\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Clear the press timer if it's active\r\n   */\r\n  clearPressTimer() {\r\n    if (this.state.timerId !== null) {\r\n      clearTimeout(this.state.timerId);\r\n      this.state.timerId = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle pointer events for the press gesture\r\n   */\r\n  handlePointerEvent = (pointers, event) => {\r\n    const pointersArray = Array.from(pointers.values());\r\n\r\n    // Check for our forceCancel event to handle interrupted gestures (from contextmenu, blur)\r\n    if (event.type === 'forceCancel') {\r\n      // Reset all active press gestures when we get a force reset event\r\n      this.cancelPress(event.target, pointersArray, event);\r\n      return;\r\n    }\r\n\r\n    // Find which element (if any) is being targeted\r\n    const targetElement = this.getTargetElement(event);\r\n    if (!targetElement) {\r\n      return;\r\n    }\r\n\r\n    // Check if this gesture should be prevented by active gestures\r\n    if (this.shouldPreventGesture(targetElement, event.pointerType)) {\r\n      if (this.isActive) {\r\n        // If the gesture was active but now should be prevented, cancel it gracefully\r\n        this.cancelPress(targetElement, pointersArray, event);\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Filter pointers to only include those targeting our element or its children\r\n    const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);\r\n    if (!this.isWithinPointerCount(relevantPointers, event.pointerType)) {\r\n      if (this.isActive) {\r\n        // Cancel or end the gesture if it was active\r\n        this.cancelPress(targetElement, relevantPointers, event);\r\n      }\r\n      return;\r\n    }\r\n    switch (event.type) {\r\n      case 'pointerdown':\r\n        if (!this.isActive && !this.state.startCentroid) {\r\n          // Calculate and store the starting centroid\r\n          this.state.startCentroid = calculateCentroid(relevantPointers);\r\n          this.state.lastPosition = _extends({}, this.state.startCentroid);\r\n          this.state.startTime = event.timeStamp;\r\n          this.isActive = true;\r\n\r\n          // Store the original target element\r\n          this.originalTarget = targetElement;\r\n\r\n          // Start the timer for press recognition\r\n          this.clearPressTimer(); // Clear any existing timer first\r\n          this.state.timerId = setTimeout(() => {\r\n            if (this.isActive && this.state.startCentroid) {\r\n              this.state.pressThresholdReached = true;\r\n              const lastPosition = this.state.lastPosition;\r\n\r\n              // Emit press start event\r\n              this.emitPressEvent(targetElement, 'start', relevantPointers, event, lastPosition);\r\n              this.emitPressEvent(targetElement, 'ongoing', relevantPointers, event, lastPosition);\r\n            }\r\n          }, this.duration);\r\n        }\r\n        break;\r\n      case 'pointermove':\r\n        if (this.isActive && this.state.startCentroid) {\r\n          // Calculate current position\r\n          const currentPosition = calculateCentroid(relevantPointers);\r\n          this.state.lastPosition = currentPosition;\r\n\r\n          // Calculate distance from start position\r\n          const deltaX = currentPosition.x - this.state.startCentroid.x;\r\n          const deltaY = currentPosition.y - this.state.startCentroid.y;\r\n          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\r\n\r\n          // If moved too far, cancel the press gesture\r\n          if (distance > this.maxDistance) {\r\n            this.cancelPress(targetElement, relevantPointers, event);\r\n          }\r\n        }\r\n        break;\r\n      case 'pointerup':\r\n        if (this.isActive) {\r\n          if (this.state.pressThresholdReached) {\r\n            // Complete the press gesture if we've held long enough\r\n            const position = this.state.lastPosition || this.state.startCentroid;\r\n            this.emitPressEvent(targetElement, 'end', relevantPointers, event, position);\r\n          }\r\n\r\n          // Reset state\r\n          this.resetState();\r\n        }\r\n        break;\r\n      case 'pointercancel':\r\n      case 'forceCancel':\r\n        // Cancel the gesture\r\n        this.cancelPress(targetElement, relevantPointers, event);\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Emit press-specific events with additional data\r\n   */\r\n  emitPressEvent(element, phase, pointers, event, position) {\r\n    // Get list of active gestures\r\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\r\n\r\n    // Calculate current duration of the press\r\n    const currentDuration = event.timeStamp - this.state.startTime;\r\n\r\n    // Create custom event data\r\n    const customEventData = {\r\n      gestureName: this.name,\r\n      centroid: position,\r\n      target: event.target,\r\n      srcEvent: event,\r\n      phase,\r\n      pointers,\r\n      timeStamp: event.timeStamp,\r\n      x: position.x,\r\n      y: position.y,\r\n      duration: currentDuration,\r\n      activeGestures,\r\n      customData: this.customData\r\n    };\r\n\r\n    // Event names to trigger\r\n    const eventName = createEventName(this.name, phase);\r\n\r\n    // Dispatch custom events on the element\r\n    const domEvent = new CustomEvent(eventName, {\r\n      bubbles: true,\r\n      cancelable: true,\r\n      composed: true,\r\n      detail: customEventData\r\n    });\r\n    element.dispatchEvent(domEvent);\r\n\r\n    // Apply preventDefault/stopPropagation if configured\r\n    if (this.preventDefault) {\r\n      event.preventDefault();\r\n    }\r\n    if (this.stopPropagation) {\r\n      event.stopPropagation();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cancel the current press gesture\r\n   */\r\n  cancelPress(element, pointers, event) {\r\n    if (this.isActive && this.state.pressThresholdReached) {\r\n      const position = this.state.lastPosition || this.state.startCentroid;\r\n      this.emitPressEvent(element ?? this.element, 'cancel', pointers, event, position);\r\n      this.emitPressEvent(element ?? this.element, 'end', pointers, event, position);\r\n    }\r\n    this.resetState();\r\n  }\r\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2143, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/gestures/PressAndDragGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\r\n/**\r\n * PressAndDragGesture - Detects press followed by drag gestures using composition\r\n *\r\n * This gesture uses internal PressGesture and PanGesture instances to:\r\n * 1. First, detect a press (hold for specified duration without movement)\r\n * 2. Then, track drag movements from the press position\r\n *\r\n * The gesture fires events when:\r\n * - A press is completed (press phase)\r\n * - Drag movement begins and passes threshold (dragStart)\r\n * - Drag movement continues (drag)\r\n * - Drag movement ends (dragEnd)\r\n * - The gesture is canceled at any point\r\n *\r\n * This is ideal for panning operations where you want to hold first, then drag.\r\n */\r\n\r\nimport { PointerGesture } from \"../PointerGesture.js\";\r\nimport { createEventName, preventDefault } from \"../utils/index.js\";\r\nimport { PanGesture } from \"./PanGesture.js\";\r\nimport { PressGesture } from \"./PressGesture.js\";\r\n\r\n/**\r\n * Configuration options for PressAndDragGesture\r\n * Extends PointerGestureOptions with press and drag specific settings\r\n */\r\n\r\n/**\r\n * Event data specific to press and drag gesture events\r\n * Contains information about the gesture state, position, and movement\r\n */\r\n\r\n/**\r\n * Type definition for the CustomEvent created by PressAndDragGesture\r\n */\r\n\r\n/**\r\n * Represents the current phase of the PressAndDrag gesture\r\n */\r\n\r\n/**\r\n * State tracking for the PressAndDragGesture\r\n */\r\n\r\n/**\r\n * PressAndDragGesture class for handling press followed by drag interactions\r\n *\r\n * This gesture composes press and drag logic patterns from PressGesture and PanGesture\r\n * into a single coordinated gesture that handles press-then-drag interactions.\r\n */\r\nexport class PressAndDragGesture extends PointerGesture {\r\n  state = {\r\n    phase: 'waitingForPress',\r\n    dragTimeoutId: null\r\n  };\r\n\r\n  /**\r\n   * Duration required for press recognition\r\n   */\r\n\r\n  /**\r\n   * Maximum distance a pointer can move during press for it to still be considered a press\r\n   */\r\n\r\n  /**\r\n   * Maximum time between press completion and drag start\r\n   */\r\n\r\n  /**\r\n   * Movement threshold for drag activation\r\n   */\r\n\r\n  /**\r\n   * Allowed directions for the drag gesture\r\n   */\r\n\r\n  constructor(options) {\r\n    super(options);\r\n    this.pressDuration = options.pressDuration ?? 500;\r\n    this.pressMaxDistance = options.pressMaxDistance ?? 10;\r\n    this.dragTimeout = options.dragTimeout ?? 1000;\r\n    this.dragThreshold = options.dragThreshold ?? 0;\r\n    this.dragDirection = options.dragDirection || ['up', 'down', 'left', 'right'];\r\n    this.pressGesture = new PressGesture({\r\n      name: `${this.name}-press`,\r\n      duration: this.pressDuration,\r\n      maxDistance: this.pressMaxDistance,\r\n      maxPointers: this.maxPointers,\r\n      pointerMode: this.pointerMode,\r\n      requiredKeys: this.requiredKeys,\r\n      preventIf: this.preventIf,\r\n      pointerOptions: structuredClone(this.pointerOptions)\r\n    });\r\n    this.panGesture = new PanGesture({\r\n      name: `${this.name}-pan`,\r\n      minPointers: this.minPointers,\r\n      maxPointers: this.maxPointers,\r\n      threshold: this.dragThreshold,\r\n      direction: this.dragDirection,\r\n      pointerMode: this.pointerMode,\r\n      requiredKeys: this.requiredKeys,\r\n      preventIf: this.preventIf,\r\n      pointerOptions: structuredClone(this.pointerOptions)\r\n    });\r\n  }\r\n  clone(overrides) {\r\n    return new PressAndDragGesture(_extends({\r\n      name: this.name,\r\n      preventDefault: this.preventDefault,\r\n      stopPropagation: this.stopPropagation,\r\n      minPointers: this.minPointers,\r\n      maxPointers: this.maxPointers,\r\n      pressDuration: this.pressDuration,\r\n      pressMaxDistance: this.pressMaxDistance,\r\n      dragTimeout: this.dragTimeout,\r\n      dragThreshold: this.dragThreshold,\r\n      dragDirection: [...this.dragDirection],\r\n      requiredKeys: [...this.requiredKeys],\r\n      pointerMode: [...this.pointerMode],\r\n      preventIf: [...this.preventIf],\r\n      pointerOptions: structuredClone(this.pointerOptions)\r\n    }, overrides));\r\n  }\r\n  init(element, pointerManager, gestureRegistry, keyboardManager) {\r\n    super.init(element, pointerManager, gestureRegistry, keyboardManager);\r\n    this.pressGesture.init(element, pointerManager, gestureRegistry, keyboardManager);\r\n    this.panGesture.init(element, pointerManager, gestureRegistry, keyboardManager);\r\n\r\n    // Listen to press gesture events\r\n    this.element.addEventListener(this.pressGesture.name, this.pressHandler);\r\n\r\n    // Listen to pan gesture events for dragging\r\n    // @ts-expect-error, PointerEvent is correct.\r\n    this.element.addEventListener(`${this.panGesture.name}Start`, this.dragStartHandler);\r\n    // @ts-expect-error, PointerEvent is correct.\r\n    this.element.addEventListener(this.panGesture.name, this.dragMoveHandler);\r\n    // @ts-expect-error, PointerEvent is correct.\r\n    this.element.addEventListener(`${this.panGesture.name}End`, this.dragEndHandler);\r\n    // @ts-expect-error, PointerEvent is correct.\r\n    this.element.addEventListener(`${this.panGesture.name}Cancel`, this.dragEndHandler);\r\n  }\r\n  destroy() {\r\n    this.resetState();\r\n    this.pressGesture.destroy();\r\n    this.panGesture.destroy();\r\n    this.element.removeEventListener(this.pressGesture.name, this.pressHandler);\r\n    // @ts-expect-error, PointerEvent is correct.\r\n    this.element.removeEventListener(`${this.panGesture.name}Start`, this.dragStartHandler);\r\n    // @ts-expect-error, PointerEvent is correct.\r\n    this.element.removeEventListener(this.panGesture.name, this.dragMoveHandler);\r\n    // @ts-expect-error, PointerEvent is correct.\r\n    this.element.removeEventListener(`${this.panGesture.name}End`, this.dragEndHandler);\r\n    // @ts-expect-error, PointerEvent is correct.\r\n    this.element.removeEventListener(`${this.panGesture.name}Cancel`, this.dragEndHandler);\r\n    super.destroy();\r\n  }\r\n  updateOptions(options) {\r\n    super.updateOptions(options);\r\n    this.pressDuration = options.pressDuration ?? this.pressDuration;\r\n    this.pressMaxDistance = options.pressMaxDistance ?? this.pressMaxDistance;\r\n    this.dragTimeout = options.dragTimeout ?? this.dragTimeout;\r\n    this.dragThreshold = options.dragThreshold ?? this.dragThreshold;\r\n    this.dragDirection = options.dragDirection || this.dragDirection;\r\n\r\n    // Update internal gesture options\r\n    this.element.dispatchEvent(new CustomEvent(`${this.panGesture.name}ChangeOptions`, {\r\n      detail: {\r\n        minPointers: this.minPointers,\r\n        maxPointers: this.maxPointers,\r\n        threshold: this.dragThreshold,\r\n        direction: this.dragDirection,\r\n        pointerMode: this.pointerMode,\r\n        requiredKeys: this.requiredKeys,\r\n        preventIf: this.preventIf,\r\n        pointerOptions: structuredClone(this.pointerOptions)\r\n      }\r\n    }));\r\n    this.element.dispatchEvent(new CustomEvent(`${this.pressGesture.name}ChangeOptions`, {\r\n      detail: {\r\n        duration: this.pressDuration,\r\n        maxDistance: this.pressMaxDistance,\r\n        maxPointers: this.maxPointers,\r\n        pointerMode: this.pointerMode,\r\n        requiredKeys: this.requiredKeys,\r\n        preventIf: this.preventIf,\r\n        pointerOptions: structuredClone(this.pointerOptions)\r\n      }\r\n    }));\r\n  }\r\n  resetState() {\r\n    if (this.state.dragTimeoutId !== null) {\r\n      clearTimeout(this.state.dragTimeoutId);\r\n    }\r\n    this.restoreTouchAction();\r\n    this.isActive = false;\r\n    this.state = {\r\n      phase: 'waitingForPress',\r\n      dragTimeoutId: null\r\n    };\r\n  }\r\n\r\n  /**\r\n   * This can be empty because the PressAndDragGesture relies on PressGesture and PanGesture to handle pointer events\r\n   * The internal gestures will manage their own state and events, while this class coordinates between them\r\n   */\r\n  handlePointerEvent() {}\r\n  pressHandler = () => {\r\n    if (this.state.phase !== 'waitingForPress') {\r\n      return;\r\n    }\r\n    this.state.phase = 'pressDetected';\r\n    this.setTouchAction();\r\n\r\n    // Start timeout to wait for drag start\r\n    this.state.dragTimeoutId = setTimeout(() => {\r\n      // Timeout expired, reset gesture\r\n      this.resetState();\r\n    }, this.dragTimeout);\r\n  };\r\n  dragStartHandler = event => {\r\n    if (this.state.phase !== 'pressDetected') {\r\n      return;\r\n    }\r\n\r\n    // Clear the drag timeout as drag has started\r\n    if (this.state.dragTimeoutId !== null) {\r\n      clearTimeout(this.state.dragTimeoutId);\r\n      this.state.dragTimeoutId = null;\r\n    }\r\n\r\n    // Restore touch action since we're now dragging\r\n    this.restoreTouchAction();\r\n    this.state.phase = 'dragging';\r\n    this.isActive = true;\r\n\r\n    // Fire start event\r\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\r\n  };\r\n  dragMoveHandler = event => {\r\n    if (this.state.phase !== 'dragging') {\r\n      return;\r\n    }\r\n\r\n    // Fire move event\r\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\r\n  };\r\n  dragEndHandler = event => {\r\n    if (this.state.phase !== 'dragging') {\r\n      return;\r\n    }\r\n    this.resetState();\r\n\r\n    // Fire end event\r\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\r\n  };\r\n  setTouchAction() {\r\n    this.element.addEventListener('touchstart', preventDefault, {\r\n      passive: false\r\n    });\r\n    this.element.addEventListener('touchmove', preventDefault, {\r\n      passive: false\r\n    });\r\n    this.element.addEventListener('touchend', preventDefault, {\r\n      passive: false\r\n    });\r\n  }\r\n  restoreTouchAction() {\r\n    this.element.removeEventListener('touchstart', preventDefault);\r\n    this.element.removeEventListener('touchmove', preventDefault);\r\n    this.element.removeEventListener('touchend', preventDefault);\r\n  }\r\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2390, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/gestures/TapGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\r\n/**\r\n * TapGesture - Detects tap (quick touch without movement) gestures\r\n *\r\n * This gesture tracks simple tap interactions on elements, firing a single event when:\r\n * - A complete tap is detected (pointerup after brief touch without excessive movement)\r\n * - The tap is canceled (event.g., moved too far or held too long)\r\n */\r\n\r\nimport { PointerGesture } from \"../PointerGesture.js\";\r\nimport { calculateCentroid, createEventName } from \"../utils/index.js\";\r\n\r\n/**\r\n * Configuration options for TapGesture\r\n * Extends PointerGestureOptions with tap-specific settings\r\n */\r\n\r\n/**\r\n * Event data specific to tap gesture events\r\n * Contains information about the tap location and counts\r\n */\r\n\r\n/**\r\n * Type definition for the CustomEvent created by TapGesture\r\n */\r\n\r\n/**\r\n * State tracking for the TapGesture\r\n */\r\n\r\n/**\r\n * TapGesture class for handling tap interactions\r\n *\r\n * This gesture detects when users tap on elements without significant movement,\r\n * and can recognize single taps, double taps, or other multi-tap sequences.\r\n */\r\nexport class TapGesture extends PointerGesture {\r\n  state = {\r\n    startCentroid: null,\r\n    currentTapCount: 0,\r\n    lastTapTime: 0,\r\n    lastPosition: null\r\n  };\r\n\r\n  /**\r\n   * Maximum distance a pointer can move for a gesture to still be considered a tap\r\n   */\r\n\r\n  /**\r\n   * Number of consecutive taps to detect\r\n   */\r\n\r\n  constructor(options) {\r\n    super(options);\r\n    this.maxDistance = options.maxDistance ?? 10;\r\n    this.taps = options.taps ?? 1;\r\n  }\r\n  clone(overrides) {\r\n    return new TapGesture(_extends({\r\n      name: this.name,\r\n      preventDefault: this.preventDefault,\r\n      stopPropagation: this.stopPropagation,\r\n      minPointers: this.minPointers,\r\n      maxPointers: this.maxPointers,\r\n      maxDistance: this.maxDistance,\r\n      taps: this.taps,\r\n      requiredKeys: [...this.requiredKeys],\r\n      pointerMode: [...this.pointerMode],\r\n      preventIf: [...this.preventIf],\r\n      pointerOptions: structuredClone(this.pointerOptions)\r\n    }, overrides));\r\n  }\r\n  destroy() {\r\n    this.resetState();\r\n    super.destroy();\r\n  }\r\n  updateOptions(options) {\r\n    super.updateOptions(options);\r\n    this.maxDistance = options.maxDistance ?? this.maxDistance;\r\n    this.taps = options.taps ?? this.taps;\r\n  }\r\n  resetState() {\r\n    this.isActive = false;\r\n    this.state = {\r\n      startCentroid: null,\r\n      currentTapCount: 0,\r\n      lastTapTime: 0,\r\n      lastPosition: null\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Handle pointer events for the tap gesture\r\n   */\r\n  handlePointerEvent = (pointers, event) => {\r\n    const pointersArray = Array.from(pointers.values());\r\n\r\n    // Find which element (if any) is being targeted\r\n    const targetElement = this.getTargetElement(event);\r\n    if (!targetElement) {\r\n      return;\r\n    }\r\n\r\n    // Filter pointers to only include those targeting our element or its children\r\n    const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);\r\n    if (this.shouldPreventGesture(targetElement, event.pointerType) || !this.isWithinPointerCount(relevantPointers, event.pointerType)) {\r\n      if (this.isActive) {\r\n        // Cancel the gesture if it was active\r\n        this.cancelTap(targetElement, relevantPointers, event);\r\n      }\r\n      return;\r\n    }\r\n    switch (event.type) {\r\n      case 'pointerdown':\r\n        if (!this.isActive) {\r\n          // Calculate and store the starting centroid\r\n          this.state.startCentroid = calculateCentroid(relevantPointers);\r\n          this.state.lastPosition = _extends({}, this.state.startCentroid);\r\n          this.isActive = true;\r\n\r\n          // Store the original target element\r\n          this.originalTarget = targetElement;\r\n        }\r\n        break;\r\n      case 'pointermove':\r\n        if (this.isActive && this.state.startCentroid) {\r\n          // Calculate current position\r\n          const currentPosition = calculateCentroid(relevantPointers);\r\n          this.state.lastPosition = currentPosition;\r\n\r\n          // Calculate distance from start position\r\n          const deltaX = currentPosition.x - this.state.startCentroid.x;\r\n          const deltaY = currentPosition.y - this.state.startCentroid.y;\r\n          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\r\n\r\n          // If moved too far, cancel the tap gesture\r\n          if (distance > this.maxDistance) {\r\n            this.cancelTap(targetElement, relevantPointers, event);\r\n          }\r\n        }\r\n        break;\r\n      case 'pointerup':\r\n        if (this.isActive) {\r\n          // For valid tap: increment tap count\r\n          this.state.currentTapCount += 1;\r\n\r\n          // Make sure we have a valid position before firing the tap event\r\n          const position = this.state.lastPosition || this.state.startCentroid;\r\n          if (!position) {\r\n            this.cancelTap(targetElement, relevantPointers, event);\r\n            return;\r\n          }\r\n\r\n          // Check if we've reached the desired number of taps\r\n          if (this.state.currentTapCount >= this.taps) {\r\n            // The complete tap sequence has been detected - fire the tap event\r\n            this.fireTapEvent(targetElement, relevantPointers, event, position);\r\n\r\n            // Reset state after successful tap\r\n            this.resetState();\r\n          } else {\r\n            // Store the time of this tap for multi-tap detection\r\n            this.state.lastTapTime = event.timeStamp;\r\n\r\n            // Reset active state but keep the tap count for multi-tap detection\r\n            this.isActive = false;\r\n\r\n            // For multi-tap detection: keep track of the last tap position\r\n            // but clear the start centroid to prepare for next tap\r\n            this.state.startCentroid = null;\r\n\r\n            // Start a timeout to reset the tap count if the next tap doesn't come soon enough\r\n            setTimeout(() => {\r\n              if (this.state && this.state.currentTapCount > 0 && this.state.currentTapCount < this.taps) {\r\n                this.state.currentTapCount = 0;\r\n              }\r\n            }, 300); // 300ms is a typical double-tap detection window\r\n          }\r\n        }\r\n        break;\r\n      case 'pointercancel':\r\n      case 'forceCancel':\r\n        // Cancel the gesture\r\n        this.cancelTap(targetElement, relevantPointers, event);\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Fire the main tap event when a valid tap is detected\r\n   */\r\n  fireTapEvent(element, pointers, event, position) {\r\n    // Get list of active gestures\r\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\r\n\r\n    // Create custom event data for the tap event\r\n    const customEventData = {\r\n      gestureName: this.name,\r\n      centroid: position,\r\n      target: event.target,\r\n      srcEvent: event,\r\n      phase: 'end',\r\n      // The tap is complete, so we use 'end' state for the event data\r\n      pointers,\r\n      timeStamp: event.timeStamp,\r\n      x: position.x,\r\n      y: position.y,\r\n      tapCount: this.state.currentTapCount,\r\n      activeGestures,\r\n      customData: this.customData\r\n    };\r\n\r\n    // Dispatch a single 'tap' event (not 'tapStart', 'tapEnd', etc.)\r\n    const domEvent = new CustomEvent(this.name, {\r\n      bubbles: true,\r\n      cancelable: true,\r\n      composed: true,\r\n      detail: customEventData\r\n    });\r\n    element.dispatchEvent(domEvent);\r\n\r\n    // Apply preventDefault/stopPropagation if configured\r\n    if (this.preventDefault) {\r\n      event.preventDefault();\r\n    }\r\n    if (this.stopPropagation) {\r\n      event.stopPropagation();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cancel the current tap gesture\r\n   */\r\n  cancelTap(element, pointers, event) {\r\n    if (this.state.startCentroid || this.state.lastPosition) {\r\n      const position = this.state.lastPosition || this.state.startCentroid;\r\n\r\n      // Get list of active gestures\r\n      const activeGestures = this.gesturesRegistry.getActiveGestures(element);\r\n\r\n      // Create custom event data for the cancel event\r\n      const customEventData = {\r\n        gestureName: this.name,\r\n        centroid: position,\r\n        target: event.target,\r\n        srcEvent: event,\r\n        phase: 'cancel',\r\n        pointers,\r\n        timeStamp: event.timeStamp,\r\n        x: position.x,\r\n        y: position.y,\r\n        tapCount: this.state.currentTapCount,\r\n        activeGestures,\r\n        customData: this.customData\r\n      };\r\n\r\n      // Dispatch a 'tapCancel' event\r\n      const eventName = createEventName(this.name, 'cancel');\r\n      const domEvent = new CustomEvent(eventName, {\r\n        bubbles: true,\r\n        cancelable: true,\r\n        composed: true,\r\n        detail: customEventData\r\n      });\r\n      element.dispatchEvent(domEvent);\r\n    }\r\n    this.resetState();\r\n  }\r\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2624, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/gestures/TapAndDragGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\r\n/**\r\n * TapAndDragGesture - Detects tap followed by drag gestures using composition\r\n *\r\n * This gesture uses internal TapGesture and PanGesture instances to:\r\n * 1. First, detect a tap (quick touch without movement)\r\n * 2. Then, track drag movements on the next pointer down\r\n *\r\n * The gesture fires events when:\r\n * - A tap is completed (tap phase)\r\n * - Drag movement begins and passes threshold (dragStart)\r\n * - Drag movement continues (drag)\r\n * - Drag movement ends (dragEnd)\r\n * - The gesture is canceled at any point\r\n */\r\n\r\nimport { PointerGesture } from \"../PointerGesture.js\";\r\nimport { createEventName, preventDefault } from \"../utils/index.js\";\r\nimport { PanGesture } from \"./PanGesture.js\";\r\nimport { TapGesture } from \"./TapGesture.js\";\r\n\r\n/**\r\n * Configuration options for TapAndDragGesture\r\n * Extends PointerGestureOptions with tap and drag specific settings\r\n */\r\n\r\n/**\r\n * Event data specific to tap and drag gesture events\r\n * Contains information about the gesture state, position, and movement\r\n */\r\n\r\n/**\r\n * Type definition for the CustomEvent created by TapAndDragGesture\r\n */\r\n\r\n/**\r\n * Represents the current phase of the TapAndDrag gesture\r\n */\r\n\r\n/**\r\n * State tracking for the TapAndDragGesture\r\n */\r\n\r\n/**\r\n * TapAndDragGesture class for handling tap followed by drag interactions\r\n *\r\n * This gesture composes tap and drag logic patterns from TapGesture and PanGesture\r\n * into a single coordinated gesture that handles tap-then-drag interactions.\r\n */\r\nexport class TapAndDragGesture extends PointerGesture {\r\n  state = {\r\n    phase: 'waitingForTap',\r\n    dragTimeoutId: null\r\n  };\r\n\r\n  /**\r\n   * Maximum distance a pointer can move during tap for it to still be considered a tap\r\n   * (Following TapGesture pattern)\r\n   */\r\n\r\n  /**\r\n   * Maximum time between tap completion and drag start\r\n   */\r\n\r\n  /**\r\n   * Movement threshold for drag activation\r\n   */\r\n\r\n  /**\r\n   * Allowed directions for the drag gesture\r\n   */\r\n\r\n  constructor(options) {\r\n    super(options);\r\n    this.tapMaxDistance = options.tapMaxDistance ?? 10;\r\n    this.dragTimeout = options.dragTimeout ?? 1000;\r\n    this.dragThreshold = options.dragThreshold ?? 0;\r\n    this.dragDirection = options.dragDirection || ['up', 'down', 'left', 'right'];\r\n    this.tapGesture = new TapGesture({\r\n      name: `${this.name}-tap`,\r\n      maxDistance: this.tapMaxDistance,\r\n      maxPointers: this.maxPointers,\r\n      pointerMode: this.pointerMode,\r\n      requiredKeys: this.requiredKeys,\r\n      preventIf: this.preventIf,\r\n      pointerOptions: structuredClone(this.pointerOptions)\r\n    });\r\n    this.panGesture = new PanGesture({\r\n      name: `${this.name}-pan`,\r\n      minPointers: this.minPointers,\r\n      maxPointers: this.maxPointers,\r\n      threshold: this.dragThreshold,\r\n      direction: this.dragDirection,\r\n      pointerMode: this.pointerMode,\r\n      requiredKeys: this.requiredKeys,\r\n      preventIf: this.preventIf,\r\n      pointerOptions: structuredClone(this.pointerOptions)\r\n    });\r\n  }\r\n  clone(overrides) {\r\n    return new TapAndDragGesture(_extends({\r\n      name: this.name,\r\n      preventDefault: this.preventDefault,\r\n      stopPropagation: this.stopPropagation,\r\n      minPointers: this.minPointers,\r\n      maxPointers: this.maxPointers,\r\n      tapMaxDistance: this.tapMaxDistance,\r\n      dragTimeout: this.dragTimeout,\r\n      dragThreshold: this.dragThreshold,\r\n      dragDirection: [...this.dragDirection],\r\n      requiredKeys: [...this.requiredKeys],\r\n      pointerMode: [...this.pointerMode],\r\n      preventIf: [...this.preventIf],\r\n      pointerOptions: structuredClone(this.pointerOptions)\r\n    }, overrides));\r\n  }\r\n  init(element, pointerManager, gestureRegistry, keyboardManager) {\r\n    super.init(element, pointerManager, gestureRegistry, keyboardManager);\r\n    this.tapGesture.init(element, pointerManager, gestureRegistry, keyboardManager);\r\n    this.panGesture.init(element, pointerManager, gestureRegistry, keyboardManager);\r\n    this.element.addEventListener(this.tapGesture.name, this.tapHandler);\r\n    // @ts-expect-error, PointerEvent is correct.\r\n    this.element.addEventListener(`${this.panGesture.name}Start`, this.dragStartHandler);\r\n    // @ts-expect-error, PointerEvent is correct.\r\n    this.element.addEventListener(this.panGesture.name, this.dragMoveHandler);\r\n    // @ts-expect-error, PointerEvent is correct.\r\n    this.element.addEventListener(`${this.panGesture.name}End`, this.dragEndHandler);\r\n    // @ts-expect-error, PointerEvent is correct.\r\n    this.element.addEventListener(`${this.panGesture.name}Cancel`, this.dragEndHandler);\r\n  }\r\n  destroy() {\r\n    this.resetState();\r\n    this.tapGesture.destroy();\r\n    this.panGesture.destroy();\r\n    this.element.removeEventListener(this.tapGesture.name, this.tapHandler);\r\n    // @ts-expect-error, PointerEvent is correct.\r\n    this.element.removeEventListener(`${this.panGesture.name}Start`, this.dragStartHandler);\r\n    // @ts-expect-error, PointerEvent is correct.\r\n    this.element.removeEventListener(this.panGesture.name, this.dragMoveHandler);\r\n    // @ts-expect-error, PointerEvent is correct.\r\n    this.element.removeEventListener(`${this.panGesture.name}End`, this.dragEndHandler);\r\n    // @ts-expect-error, PointerEvent is correct.\r\n    this.element.removeEventListener(`${this.panGesture.name}Cancel`, this.dragEndHandler);\r\n    super.destroy();\r\n  }\r\n  updateOptions(options) {\r\n    super.updateOptions(options);\r\n    this.tapMaxDistance = options.tapMaxDistance ?? this.tapMaxDistance;\r\n    this.dragTimeout = options.dragTimeout ?? this.dragTimeout;\r\n    this.dragThreshold = options.dragThreshold ?? this.dragThreshold;\r\n    this.dragDirection = options.dragDirection || this.dragDirection;\r\n    this.element.dispatchEvent(new CustomEvent(`${this.panGesture.name}ChangeOptions`, {\r\n      detail: {\r\n        minPointers: this.minPointers,\r\n        maxPointers: this.maxPointers,\r\n        threshold: this.dragThreshold,\r\n        direction: this.dragDirection,\r\n        pointerMode: this.pointerMode,\r\n        requiredKeys: this.requiredKeys,\r\n        preventIf: this.preventIf,\r\n        pointerOptions: structuredClone(this.pointerOptions)\r\n      }\r\n    }));\r\n    this.element.dispatchEvent(new CustomEvent(`${this.tapGesture.name}ChangeOptions`, {\r\n      detail: {\r\n        maxDistance: this.tapMaxDistance,\r\n        maxPointers: this.maxPointers,\r\n        pointerMode: this.pointerMode,\r\n        requiredKeys: this.requiredKeys,\r\n        preventIf: this.preventIf,\r\n        pointerOptions: structuredClone(this.pointerOptions)\r\n      }\r\n    }));\r\n  }\r\n  resetState() {\r\n    if (this.state.dragTimeoutId !== null) {\r\n      clearTimeout(this.state.dragTimeoutId);\r\n    }\r\n    this.restoreTouchAction();\r\n    this.isActive = false;\r\n    this.state = {\r\n      phase: 'waitingForTap',\r\n      dragTimeoutId: null\r\n    };\r\n  }\r\n\r\n  /**\r\n   * This can be empty because the TapAndDragGesture relies on TapGesture and PanGesture to handle pointer events\r\n   * The internal gestures will manage their own state and events, while this class coordinates between them\r\n   */\r\n  handlePointerEvent() {}\r\n  tapHandler = () => {\r\n    if (this.state.phase !== 'waitingForTap') {\r\n      return;\r\n    }\r\n    this.state.phase = 'tapDetected';\r\n    this.setTouchAction();\r\n\r\n    // Start timeout to wait for drag start\r\n    this.state.dragTimeoutId = setTimeout(() => {\r\n      // Timeout expired, reset gesture\r\n      this.resetState();\r\n    }, this.dragTimeout);\r\n  };\r\n  dragStartHandler = event => {\r\n    if (this.state.phase !== 'tapDetected') {\r\n      return;\r\n    }\r\n\r\n    // Clear the drag timeout as drag has started\r\n    if (this.state.dragTimeoutId !== null) {\r\n      clearTimeout(this.state.dragTimeoutId);\r\n      this.state.dragTimeoutId = null;\r\n    }\r\n    this.restoreTouchAction();\r\n    this.state.phase = 'dragging';\r\n    this.isActive = true;\r\n\r\n    // Fire start event\r\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\r\n  };\r\n  dragMoveHandler = event => {\r\n    if (this.state.phase !== 'dragging') {\r\n      return;\r\n    }\r\n\r\n    // Fire move event\r\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\r\n  };\r\n  dragEndHandler = event => {\r\n    if (this.state.phase !== 'dragging') {\r\n      return;\r\n    }\r\n    this.resetState();\r\n\r\n    // Fire end event\r\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\r\n  };\r\n  setTouchAction() {\r\n    this.element.addEventListener('touchstart', preventDefault, {\r\n      passive: false\r\n    });\r\n  }\r\n  restoreTouchAction() {\r\n    this.element.removeEventListener('touchstart', preventDefault);\r\n  }\r\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2851, "column": 0}, "map": {"version":3,"sources":["file:///D:/Assignment/interview/frontend/node_modules/%40mui/x-internal-gestures/esm/core/gestures/TurnWheelGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\r\n/**\r\n * TurnWheelGesture - Detects wheel events on an element\r\n *\r\n * This gesture tracks mouse wheel or touchpad scroll events on elements, firing events when:\r\n * - The user scrolls/wheels on the element (ongoing)\r\n *\r\n * Unlike other gestures which may have start/ongoing/end states,\r\n * wheel gestures are always considered \"ongoing\" since they are discrete events.\r\n */\r\n\r\nimport { Gesture } from \"../Gesture.js\";\r\nimport { calculateCentroid, createEventName } from \"../utils/index.js\";\r\n\r\n/**\r\n * Configuration options for the TurnWheelGesture\r\n * Uses the base gesture options with additional wheel-specific options\r\n */\r\n\r\n/**\r\n * Event data specific to wheel gesture events\r\n * Contains information about scroll delta amounts and mode\r\n */\r\n\r\n/**\r\n * Type definition for the CustomEvent created by TurnWheelGesture\r\n */\r\n\r\n/**\r\n * State tracking for the TurnWheelGesture\r\n */\r\n\r\n/**\r\n * TurnWheelGesture class for handling wheel/scroll interactions\r\n *\r\n * This gesture detects when users scroll or use the mouse wheel on elements,\r\n * and dispatches corresponding scroll events with delta information.\r\n * Unlike most gestures, it extends directly from Gesture rather than PointerGesture.\r\n */\r\nexport class TurnWheelGesture extends Gesture {\r\n  state = {\r\n    totalDeltaX: 0,\r\n    totalDeltaY: 0,\r\n    totalDeltaZ: 0\r\n  };\r\n\r\n  /**\r\n   * Scaling factor for delta values\r\n   * Values > 1 increase sensitivity, values < 1 decrease sensitivity\r\n   */\r\n\r\n  /**\r\n   * Maximum value for totalDelta values\r\n   * Limits how large the accumulated wheel deltas can be\r\n   */\r\n\r\n  /**\r\n   * Minimum value for totalDelta values\r\n   * Sets a lower bound for accumulated wheel deltas\r\n   */\r\n\r\n  /**\r\n   * Initial value for totalDelta values\r\n   * Sets the starting value for delta trackers\r\n   */\r\n\r\n  /**\r\n   * Whether to invert the direction of delta changes\r\n   * When true, reverses the sign of deltaX, deltaY, and deltaZ values\r\n   */\r\n\r\n  constructor(options) {\r\n    super(options);\r\n    this.sensitivity = options.sensitivity ?? 1;\r\n    this.max = options.max ?? Number.MAX_SAFE_INTEGER;\r\n    this.min = options.min ?? Number.MIN_SAFE_INTEGER;\r\n    this.initialDelta = options.initialDelta ?? 0;\r\n    this.invert = options.invert ?? false;\r\n    this.state.totalDeltaX = this.initialDelta;\r\n    this.state.totalDeltaY = this.initialDelta;\r\n    this.state.totalDeltaZ = this.initialDelta;\r\n  }\r\n  clone(overrides) {\r\n    return new TurnWheelGesture(_extends({\r\n      name: this.name,\r\n      preventDefault: this.preventDefault,\r\n      stopPropagation: this.stopPropagation,\r\n      sensitivity: this.sensitivity,\r\n      max: this.max,\r\n      min: this.min,\r\n      initialDelta: this.initialDelta,\r\n      invert: this.invert,\r\n      requiredKeys: [...this.requiredKeys],\r\n      preventIf: [...this.preventIf]\r\n    }, overrides));\r\n  }\r\n  init(element, pointerManager, gestureRegistry, keyboardManager) {\r\n    super.init(element, pointerManager, gestureRegistry, keyboardManager);\r\n\r\n    // Add event listener directly to the element\r\n    // @ts-expect-error, WheelEvent is correct.\r\n    this.element.addEventListener('wheel', this.handleWheelEvent);\r\n  }\r\n  destroy() {\r\n    // Remove the element-specific event listener\r\n    // @ts-expect-error, WheelEvent is correct.\r\n    this.element.removeEventListener('wheel', this.handleWheelEvent);\r\n    this.resetState();\r\n    super.destroy();\r\n  }\r\n  resetState() {\r\n    this.isActive = false;\r\n    this.state = {\r\n      totalDeltaX: 0,\r\n      totalDeltaY: 0,\r\n      totalDeltaZ: 0\r\n    };\r\n  }\r\n  updateOptions(options) {\r\n    super.updateOptions(options);\r\n    this.sensitivity = options.sensitivity ?? this.sensitivity;\r\n    this.max = options.max ?? this.max;\r\n    this.min = options.min ?? this.min;\r\n    this.initialDelta = options.initialDelta ?? this.initialDelta;\r\n    this.invert = options.invert ?? this.invert;\r\n  }\r\n\r\n  /**\r\n   * Handle wheel events for a specific element\r\n   * @param element The element that received the wheel event\r\n   * @param event The original wheel event\r\n   */\r\n  handleWheelEvent = event => {\r\n    // Check if this gesture should be prevented by active gestures\r\n    if (this.shouldPreventGesture(this.element, 'mouse')) {\r\n      return;\r\n    }\r\n\r\n    // Get pointers from the PointerManager to use for centroid calculation\r\n    const pointers = this.pointerManager.getPointers() || new Map();\r\n    const pointersArray = Array.from(pointers.values());\r\n\r\n    // Update total deltas with scaled values\r\n    this.state.totalDeltaX += event.deltaX * this.sensitivity * (this.invert ? -1 : 1);\r\n    this.state.totalDeltaY += event.deltaY * this.sensitivity * (this.invert ? -1 : 1);\r\n    this.state.totalDeltaZ += event.deltaZ * this.sensitivity * (this.invert ? -1 : 1);\r\n\r\n    // Apply proper min/max clamping for each axis\r\n    // Ensure values stay between min and max bounds\r\n    ['totalDeltaX', 'totalDeltaY', 'totalDeltaZ'].forEach(axis => {\r\n      // First clamp at the minimum bound\r\n      if (this.state[axis] < this.min) {\r\n        this.state[axis] = this.min;\r\n      }\r\n\r\n      // Then clamp at the maximum bound\r\n      if (this.state[axis] > this.max) {\r\n        this.state[axis] = this.max;\r\n      }\r\n    });\r\n\r\n    // Emit the wheel event\r\n    this.emitWheelEvent(pointersArray, event);\r\n  };\r\n\r\n  /**\r\n   * Emit wheel-specific events\r\n   * @param pointers The current pointers on the element\r\n   * @param event The original wheel event\r\n   */\r\n  emitWheelEvent(pointers, event) {\r\n    // Calculate centroid - either from existing pointers or from the wheel event position\r\n    const centroid = pointers.length > 0 ? calculateCentroid(pointers) : {\r\n      x: event.clientX,\r\n      y: event.clientY\r\n    };\r\n\r\n    // Get list of active gestures\r\n    const activeGestures = this.gesturesRegistry.getActiveGestures(this.element);\r\n\r\n    // Create custom event data\r\n    const customEventData = {\r\n      gestureName: this.name,\r\n      centroid,\r\n      target: event.target,\r\n      srcEvent: event,\r\n      phase: 'ongoing',\r\n      // Wheel events are always in \"ongoing\" state\r\n      pointers,\r\n      timeStamp: event.timeStamp,\r\n      deltaX: event.deltaX * this.sensitivity * (this.invert ? -1 : 1),\r\n      deltaY: event.deltaY * this.sensitivity * (this.invert ? -1 : 1),\r\n      deltaZ: event.deltaZ * this.sensitivity * (this.invert ? -1 : 1),\r\n      deltaMode: event.deltaMode,\r\n      totalDeltaX: this.state.totalDeltaX,\r\n      totalDeltaY: this.state.totalDeltaY,\r\n      totalDeltaZ: this.state.totalDeltaZ,\r\n      activeGestures,\r\n      customData: this.customData\r\n    };\r\n\r\n    // Apply default event behavior if configured\r\n    if (this.preventDefault) {\r\n      event.preventDefault();\r\n    }\r\n    if (this.stopPropagation) {\r\n      event.stopPropagation();\r\n    }\r\n\r\n    // Event names to trigger\r\n    const eventName = createEventName(this.name, 'ongoing');\r\n\r\n    // Dispatch custom events on the element\r\n    const domEvent = new CustomEvent(eventName, {\r\n      bubbles: true,\r\n      cancelable: true,\r\n      composed: true,\r\n      detail: customEventData\r\n    });\r\n    this.element.dispatchEvent(domEvent);\r\n  }\r\n}"],"names":[],"mappings":"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","ignoreList":[0]}}]
}